--  Copyright <YEAR> <COPYRIGHT HOLDER>
--
--  Permission is hereby granted, free of charge, to any person obtaining a
--  copy of this software and associated documentation files (the "Software"),
--  to deal in the Software without restriction, including without limitation
--  the rights to use, copy, modify, merge, publish, distribute, sublicense,
--  and/or sell copies of the Software, and to permit persons to whom the
--  Software is furnished to do so, subject to the following conditions:
--
--  The above copyright notice and this permission notice shall be included in
--  all copies or substantial portions of the Software.
--
--  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
--  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
--  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
--  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
--  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
--  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
--  DEALINGS IN THE SOFTWARE.
--
--  DON'T EDIT THIS FILE! It was generated from JSON Schema.

pragma Style_Checks ("M99");  --  suppress style warning unitl gnatpp is fixed
with Ada.Containers.Doubly_Linked_Lists;
with Ada.Finalization;
with VSS.JSON.Streams;
with VSS.Strings;
with VSS.String_Vectors;

package DAP.Tools is
package JSON_Event_Lists is new Ada.Containers.Doubly_Linked_Lists
(VSS.JSON.Streams.JSON_Stream_Element, VSS.JSON.Streams."=");

type Any_Value is new JSON_Event_Lists.List with null record;
type Any_Object is new Any_Value with null record;

type Optional_Integer (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : Integer;
when False => null;
end case; end record;

type Optional_Float (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : Float;
when False => null;
end case; end record;

type Integer_Or_String (Is_String : Boolean := False) is record
case Is_String is
when False =>
Integer : Standard.Integer;
when True =>
String : VSS.Strings.Virtual_String;
end case;
end record;

type Optional_Integer_Or_String (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : Integer_Or_String;
when False => null;
end case; end record;


type Thread_Vector is tagged private
with Variable_Indexing => Get_Thread_Variable_Reference,
Constant_Indexing => Get_Thread_Constant_Reference;

type Checksum_Vector is tagged private
with Variable_Indexing => Get_Checksum_Variable_Reference,
Constant_Indexing => Get_Checksum_Constant_Reference;

type Breakpoint_Vector is tagged private
with Variable_Indexing => Get_Breakpoint_Variable_Reference,
Constant_Indexing => Get_Breakpoint_Constant_Reference;

type StepInTarget_Vector is tagged private
with Variable_Indexing => Get_StepInTarget_Variable_Reference,
Constant_Indexing => Get_StepInTarget_Constant_Reference;

type FunctionBreakpoint_Vector is tagged private
with Variable_Indexing => Get_FunctionBreakpoint_Variable_Reference,
Constant_Indexing => Get_FunctionBreakpoint_Constant_Reference;

type DataBreakpoint_Vector is tagged private
with Variable_Indexing => Get_DataBreakpoint_Variable_Reference,
Constant_Indexing => Get_DataBreakpoint_Constant_Reference;

type ExceptionOptions_Vector is tagged private
with Variable_Indexing => Get_ExceptionOptions_Variable_Reference,
Constant_Indexing => Get_ExceptionOptions_Constant_Reference;

type Integer_Vector is tagged private
with Variable_Indexing => Get_Integer_Variable_Reference,
Constant_Indexing => Get_Integer_Constant_Reference;

type GotoTarget_Vector is tagged private
with Variable_Indexing => Get_GotoTarget_Variable_Reference,
Constant_Indexing => Get_GotoTarget_Constant_Reference;

type InvalidatedAreas_Vector is tagged private
with Variable_Indexing => Get_InvalidatedAreas_Variable_Reference,
Constant_Indexing => Get_InvalidatedAreas_Constant_Reference;

type BreakpointLocation_Vector is tagged private
with Variable_Indexing => Get_BreakpointLocation_Variable_Reference,
Constant_Indexing => Get_BreakpointLocation_Constant_Reference;

type InstructionBreakpoint_Vector is tagged private
with Variable_Indexing => Get_InstructionBreakpoint_Variable_Reference,
Constant_Indexing => Get_InstructionBreakpoint_Constant_Reference;

type StackFrame_Vector is tagged private
with Variable_Indexing => Get_StackFrame_Variable_Reference,
Constant_Indexing => Get_StackFrame_Constant_Reference;

type Scope_Vector is tagged private
with Variable_Indexing => Get_Scope_Variable_Reference,
Constant_Indexing => Get_Scope_Constant_Reference;

type Variable_Vector is tagged private
with Variable_Indexing => Get_Variable_Variable_Reference,
Constant_Indexing => Get_Variable_Constant_Reference;

type Source_Vector is tagged private
with Variable_Indexing => Get_Source_Variable_Reference,
Constant_Indexing => Get_Source_Constant_Reference;

type VariablePresentationHint_attributes_Vector is tagged private
with Variable_Indexing => Get_VariablePresentationHint_attributes_Variable_Reference,
Constant_Indexing => Get_VariablePresentationHint_attributes_Constant_Reference;

type SourceBreakpoint_Vector is tagged private
with Variable_Indexing => Get_SourceBreakpoint_Variable_Reference,
Constant_Indexing => Get_SourceBreakpoint_Constant_Reference;

type ChecksumAlgorithm_Vector is tagged private
with Variable_Indexing => Get_ChecksumAlgorithm_Variable_Reference,
Constant_Indexing => Get_ChecksumAlgorithm_Constant_Reference;

type ExceptionBreakpointsFilter_Vector is tagged private
with Variable_Indexing => Get_ExceptionBreakpointsFilter_Variable_Reference,
Constant_Indexing => Get_ExceptionBreakpointsFilter_Constant_Reference;

type CompletionItem_Vector is tagged private
with Variable_Indexing => Get_CompletionItem_Variable_Reference,
Constant_Indexing => Get_CompletionItem_Constant_Reference;

type ExceptionPathSegment_Vector is tagged private
with Variable_Indexing => Get_ExceptionPathSegment_Variable_Reference,
Constant_Indexing => Get_ExceptionPathSegment_Constant_Reference;

type DataBreakpointAccessType_Vector is tagged private
with Variable_Indexing => Get_DataBreakpointAccessType_Variable_Reference,
Constant_Indexing => Get_DataBreakpointAccessType_Constant_Reference;

type DisassembledInstruction_Vector is tagged private
with Variable_Indexing => Get_DisassembledInstruction_Variable_Reference,
Constant_Indexing => Get_DisassembledInstruction_Constant_Reference;

type Module_Vector is tagged private
with Variable_Indexing => Get_Module_Variable_Reference,
Constant_Indexing => Get_Module_Constant_Reference;

type ExceptionFilterOptions_Vector is tagged private
with Variable_Indexing => Get_ExceptionFilterOptions_Variable_Reference,
Constant_Indexing => Get_ExceptionFilterOptions_Constant_Reference;

type ColumnDescriptor_Vector is tagged private
with Variable_Indexing => Get_ColumnDescriptor_Variable_Reference,
Constant_Indexing => Get_ColumnDescriptor_Constant_Reference;

type ExceptionDetails_Vector is tagged private
with Variable_Indexing => Get_ExceptionDetails_Variable_Reference,
Constant_Indexing => Get_ExceptionDetails_Constant_Reference;


package Enum is

type ModuleEvent_reason is (a_new, changed, removed);

type ColumnDescriptor_type is (string, number, a_boolean, unixTimestampUTC);

type Optional_ColumnDescriptor_type (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : ColumnDescriptor_type;
when False => null;
end case; end record;

type StackFrame_presentationHint is (normal, label, subtle);

type Optional_StackFrame_presentationHint (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : StackFrame_presentationHint;
when False => null;
end case; end record;

type ExceptionBreakMode is (never, always, unhandled, userUnhandled);

type StoppedEvent_reason_Value is (step, breakpoint, a_exception, pause, a_entry, a_goto, function_breakpoint, data_breakpoint, instruction_breakpoint, Custom_Value);

subtype StoppedEvent_reason_Predefined is StoppedEvent_reason_Value range step .. instruction_breakpoint;

type StoppedEvent_reason (Kind : StoppedEvent_reason_Value := Custom_Value) is record
case Kind is
   when Custom_Value =>
      Custom_Value : VSS.Strings.Virtual_String;
   when StoppedEvent_reason_Predefined =>
      null;
end case;
end record;

function step return StoppedEvent_reason is (Kind => step);

function breakpoint return StoppedEvent_reason is (Kind => breakpoint);

function a_exception return StoppedEvent_reason is (Kind => a_exception);

function pause return StoppedEvent_reason is (Kind => pause);

function a_entry return StoppedEvent_reason is (Kind => a_entry);

function a_goto return StoppedEvent_reason is (Kind => a_goto);

function function_breakpoint return StoppedEvent_reason is (Kind => function_breakpoint);

function data_breakpoint return StoppedEvent_reason is (Kind => data_breakpoint);

function instruction_breakpoint return StoppedEvent_reason is (Kind => instruction_breakpoint);


type StartDebuggingRequestArguments_request is (launch, attach);

type OutputEvent_category_Value is (console, important, stdout, stderr, telemetry, Custom_Value);

subtype OutputEvent_category_Predefined is OutputEvent_category_Value range console .. telemetry;

type OutputEvent_category (Kind : OutputEvent_category_Value := Custom_Value) is record
case Kind is
   when Custom_Value =>
      Custom_Value : VSS.Strings.Virtual_String;
   when OutputEvent_category_Predefined =>
      null;
end case;
end record;

function console return OutputEvent_category is (Kind => console);
      --  Show the output in the client's default message UI, e.g. a 'debug console'. This category should only be used for informational output from the debugger (as opposed to the debuggee).

function important return OutputEvent_category is (Kind => important);
      --  A hint for the client to show the output in the client's UI for important and highly visible information, e.g. as a popup notification. This category should only be used for important messages from the debugger (as opposed to the debuggee). Since this category value is a hint, clients might ignore the hint and assume the `console` category.

function stdout return OutputEvent_category is (Kind => stdout);
      --  Show the output as normal program output from the debuggee.

function stderr return OutputEvent_category is (Kind => stderr);
      --  Show the output as error program output from the debuggee.

function telemetry return OutputEvent_category is (Kind => telemetry);
      --  Send the output to telemetry instead of showing it to the user.


type Optional_OutputEvent_category (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : OutputEvent_category;
when False => null;
end case; end record;

type OutputEvent_group is (start, startCollapsed, a_end);

type Optional_OutputEvent_group (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : OutputEvent_group;
when False => null;
end case; end record;

type ChecksumAlgorithm is (MD5, SHA1, SHA256, timestamp);

type ProcessEvent_startMethod is (launch, attach, attachForSuspendedLaunch);

type Optional_ProcessEvent_startMethod (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : ProcessEvent_startMethod;
when False => null;
end case; end record;

type Scope_presentationHint_Value is (arguments, locals, registers, Custom_Value);

subtype Scope_presentationHint_Predefined is Scope_presentationHint_Value range arguments .. registers;

type Scope_presentationHint (Kind : Scope_presentationHint_Value := Custom_Value) is record
case Kind is
   when Custom_Value =>
      Custom_Value : VSS.Strings.Virtual_String;
   when Scope_presentationHint_Predefined =>
      null;
end case;
end record;

function arguments return Scope_presentationHint is (Kind => arguments);
      --  Scope contains method arguments.

function locals return Scope_presentationHint is (Kind => locals);
      --  Scope contains local variables.

function registers return Scope_presentationHint is (Kind => registers);
      --  Scope contains registers. Only a single `registers` scope should be returned from a `scopes` request.


type Optional_Scope_presentationHint (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : Scope_presentationHint;
when False => null;
end case; end record;

type Response_message_Value is (cancelled, notStopped, Custom_Value);

subtype Response_message_Predefined is Response_message_Value range cancelled .. notStopped;

type Response_message (Kind : Response_message_Value := Custom_Value) is record
case Kind is
   when Custom_Value =>
      Custom_Value : VSS.Strings.Virtual_String;
   when Response_message_Predefined =>
      null;
end case;
end record;

function cancelled return Response_message is (Kind => cancelled);
      --  the request was cancelled.

function notStopped return Response_message is (Kind => notStopped);
      --  the request may be retried once the adapter is in a 'stopped' state.


type Optional_Response_message (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : Response_message;
when False => null;
end case; end record;

type CompletionItemType is (method, a_function, constructor, field, variable, class, an_interface, module, property, unit, value, enum, keyword, snippet, text, color, file, reference, customcolor);

type Optional_CompletionItemType (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : CompletionItemType;
when False => null;
end case; end record;

type InvalidatedAreas_Value is (an_all, stacks, threads, variables, Custom_Value);

subtype InvalidatedAreas_Predefined is InvalidatedAreas_Value range an_all .. variables;

type InvalidatedAreas (Kind : InvalidatedAreas_Value := Custom_Value) is record
case Kind is
   when Custom_Value =>
      Custom_Value : VSS.Strings.Virtual_String;
   when InvalidatedAreas_Predefined =>
      null;
end case;
end record;

function an_all return InvalidatedAreas is (Kind => an_all);
      --  All previously fetched data has become invalid and needs to be refetched.

function stacks return InvalidatedAreas is (Kind => stacks);
      --  Previously fetched stack related data has become invalid and needs to be refetched.

function threads return InvalidatedAreas is (Kind => threads);
      --  Previously fetched thread related data has become invalid and needs to be refetched.

function variables return InvalidatedAreas is (Kind => variables);
      --  Previously fetched variable data has become invalid and needs to be refetched.


type Source_presentationHint is (normal, emphasize, deemphasize);

type Optional_Source_presentationHint (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : Source_presentationHint;
when False => null;
end case; end record;

type LoadedSourceEvent_reason is (a_new, changed, removed);

type ProtocolMessage_type_Value is (request, response, event, Custom_Value);

subtype ProtocolMessage_type_Predefined is ProtocolMessage_type_Value range request .. event;

type ProtocolMessage_type (Kind : ProtocolMessage_type_Value := Custom_Value) is record
case Kind is
   when Custom_Value =>
      Custom_Value : VSS.Strings.Virtual_String;
   when ProtocolMessage_type_Predefined =>
      null;
end case;
end record;

function request return ProtocolMessage_type is (Kind => request);

function response return ProtocolMessage_type is (Kind => response);

function event return ProtocolMessage_type is (Kind => event);


type RunInTerminalRequestArguments_kind is (integrated, external);

type Optional_RunInTerminalRequestArguments_kind (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : RunInTerminalRequestArguments_kind;
when False => null;
end case; end record;

type VariablesArguments_filter is (indexed, named);

type Optional_VariablesArguments_filter (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : VariablesArguments_filter;
when False => null;
end case; end record;

type VariablePresentationHint_kind_Value is (property, method, class, data, event, baseClass, innerClass, an_interface, mostDerivedClass, virtual, dataBreakpoint, Custom_Value);

subtype VariablePresentationHint_kind_Predefined is VariablePresentationHint_kind_Value range property .. dataBreakpoint;

type VariablePresentationHint_kind (Kind : VariablePresentationHint_kind_Value := Custom_Value) is record
case Kind is
   when Custom_Value =>
      Custom_Value : VSS.Strings.Virtual_String;
   when VariablePresentationHint_kind_Predefined =>
      null;
end case;
end record;

function property return VariablePresentationHint_kind is (Kind => property);
      --  Indicates that the object is a property.

function method return VariablePresentationHint_kind is (Kind => method);
      --  Indicates that the object is a method.

function class return VariablePresentationHint_kind is (Kind => class);
      --  Indicates that the object is a class.

function data return VariablePresentationHint_kind is (Kind => data);
      --  Indicates that the object is data.

function event return VariablePresentationHint_kind is (Kind => event);
      --  Indicates that the object is an event.

function baseClass return VariablePresentationHint_kind is (Kind => baseClass);
      --  Indicates that the object is a base class.

function innerClass return VariablePresentationHint_kind is (Kind => innerClass);
      --  Indicates that the object is an inner class.

function an_interface return VariablePresentationHint_kind is (Kind => an_interface);
      --  Indicates that the object is an interface.

function mostDerivedClass return VariablePresentationHint_kind is (Kind => mostDerivedClass);
      --  Indicates that the object is the most derived class.

function virtual return VariablePresentationHint_kind is (Kind => virtual);
      --  Indicates that the object is virtual, that means it is a synthetic object introduced by the adapter for rendering purposes, e.g. an index range for large arrays.

function dataBreakpoint return VariablePresentationHint_kind is (Kind => dataBreakpoint);
      --  Deprecated: Indicates that a data breakpoint is registered for the object. The `hasDataBreakpoint` attribute should generally be used instead.


type Optional_VariablePresentationHint_kind (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : VariablePresentationHint_kind;
when False => null;
end case; end record;

type VariablePresentationHint_attributes_Value is (static, a_constant, readOnly, rawString, hasObjectId, canHaveObjectId, hasSideEffects, hasDataBreakpoint, Custom_Value);

subtype VariablePresentationHint_attributes_Predefined is VariablePresentationHint_attributes_Value range static .. hasDataBreakpoint;

type VariablePresentationHint_attributes (Kind : VariablePresentationHint_attributes_Value := Custom_Value) is record
case Kind is
   when Custom_Value =>
      Custom_Value : VSS.Strings.Virtual_String;
   when VariablePresentationHint_attributes_Predefined =>
      null;
end case;
end record;

function static return VariablePresentationHint_attributes is (Kind => static);
      --  Indicates that the object is static.

function a_constant return VariablePresentationHint_attributes is (Kind => a_constant);
      --  Indicates that the object is a constant.

function readOnly return VariablePresentationHint_attributes is (Kind => readOnly);
      --  Indicates that the object is read only.

function rawString return VariablePresentationHint_attributes is (Kind => rawString);
      --  Indicates that the object is a raw string.

function hasObjectId return VariablePresentationHint_attributes is (Kind => hasObjectId);
      --  Indicates that the object can have an Object ID created for it.

function canHaveObjectId return VariablePresentationHint_attributes is (Kind => canHaveObjectId);
      --  Indicates that the object has an Object ID associated with it.

function hasSideEffects return VariablePresentationHint_attributes is (Kind => hasSideEffects);
      --  Indicates that the evaluation had side effects.

function hasDataBreakpoint return VariablePresentationHint_attributes is (Kind => hasDataBreakpoint);
      --  Indicates that the object has its value tracked by a data breakpoint.


type VariablePresentationHint_visibility_Value is (public, a_private, a_protected, internal, final, Custom_Value);

subtype VariablePresentationHint_visibility_Predefined is VariablePresentationHint_visibility_Value range public .. final;

type VariablePresentationHint_visibility (Kind : VariablePresentationHint_visibility_Value := Custom_Value) is record
case Kind is
   when Custom_Value =>
      Custom_Value : VSS.Strings.Virtual_String;
   when VariablePresentationHint_visibility_Predefined =>
      null;
end case;
end record;

function public return VariablePresentationHint_visibility is (Kind => public);

function a_private return VariablePresentationHint_visibility is (Kind => a_private);

function a_protected return VariablePresentationHint_visibility is (Kind => a_protected);

function internal return VariablePresentationHint_visibility is (Kind => internal);

function final return VariablePresentationHint_visibility is (Kind => final);


type Optional_VariablePresentationHint_visibility (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : VariablePresentationHint_visibility;
when False => null;
end case; end record;

type InitializeRequestArguments_pathFormat_Value is (path, uri, Custom_Value);

subtype InitializeRequestArguments_pathFormat_Predefined is InitializeRequestArguments_pathFormat_Value range path .. uri;

type InitializeRequestArguments_pathFormat (Kind : InitializeRequestArguments_pathFormat_Value := Custom_Value) is record
case Kind is
   when Custom_Value =>
      Custom_Value : VSS.Strings.Virtual_String;
   when InitializeRequestArguments_pathFormat_Predefined =>
      null;
end case;
end record;

function path return InitializeRequestArguments_pathFormat is (Kind => path);

function uri return InitializeRequestArguments_pathFormat is (Kind => uri);


type Optional_InitializeRequestArguments_pathFormat (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : InitializeRequestArguments_pathFormat;
when False => null;
end case; end record;

type ThreadEvent_reason_Value is (started, exited, Custom_Value);

subtype ThreadEvent_reason_Predefined is ThreadEvent_reason_Value range started .. exited;

type ThreadEvent_reason (Kind : ThreadEvent_reason_Value := Custom_Value) is record
case Kind is
   when Custom_Value =>
      Custom_Value : VSS.Strings.Virtual_String;
   when ThreadEvent_reason_Predefined =>
      null;
end case;
end record;

function started return ThreadEvent_reason is (Kind => started);

function exited return ThreadEvent_reason is (Kind => exited);


type DataBreakpointAccessType is (read, write, readWrite);

type Optional_DataBreakpointAccessType (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : DataBreakpointAccessType;
when False => null;
end case; end record;

type BreakpointEvent_reason_Value is (changed, a_new, removed, Custom_Value);

subtype BreakpointEvent_reason_Predefined is BreakpointEvent_reason_Value range changed .. removed;

type BreakpointEvent_reason (Kind : BreakpointEvent_reason_Value := Custom_Value) is record
case Kind is
   when Custom_Value =>
      Custom_Value : VSS.Strings.Virtual_String;
   when BreakpointEvent_reason_Predefined =>
      null;
end case;
end record;

function changed return BreakpointEvent_reason is (Kind => changed);

function a_new return BreakpointEvent_reason is (Kind => a_new);

function removed return BreakpointEvent_reason is (Kind => removed);


type EvaluateArguments_context_Value is (watch, repl, hover, clipboard, variables, Custom_Value);

subtype EvaluateArguments_context_Predefined is EvaluateArguments_context_Value range watch .. variables;

type EvaluateArguments_context (Kind : EvaluateArguments_context_Value := Custom_Value) is record
case Kind is
   when Custom_Value =>
      Custom_Value : VSS.Strings.Virtual_String;
   when EvaluateArguments_context_Predefined =>
      null;
end case;
end record;

function watch return EvaluateArguments_context is (Kind => watch);
      --  evaluate is called from a watch view context.

function repl return EvaluateArguments_context is (Kind => repl);
      --  evaluate is called from a REPL context.

function hover return EvaluateArguments_context is (Kind => hover);
      --  evaluate is called to generate the debug hover contents.
      --  This value should only be used if the corresponding capability `supportsEvaluateForHovers` is true.

function clipboard return EvaluateArguments_context is (Kind => clipboard);
      --  evaluate is called to generate clipboard contents.
      --  This value should only be used if the corresponding capability `supportsClipboardContext` is true.

function variables return EvaluateArguments_context is (Kind => variables);
      --  evaluate is called from a variables view context.


type Optional_EvaluateArguments_context (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : EvaluateArguments_context;
when False => null;
end case; end record;

type SteppingGranularity is (statement, line, instruction);

type Optional_SteppingGranularity (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : SteppingGranularity;
when False => null;
end case; end record;

end Enum;

type ProtocolMessage is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
a_type : Enum.ProtocolMessage_type;
      --  Message type.
end record;

type Response is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : Any_Value;
      --  Contains request result if success is true and error details if success is false.
end record;

type GotoResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : Any_Value;
      --  Contains request result if success is true and error details if success is false.
end record;

type ExceptionDetails is record
message : VSS.Strings.Virtual_String;
      --  Message contained in the exception.
typeName : VSS.Strings.Virtual_String;
      --  Short type name of the exception object.
fullTypeName : VSS.Strings.Virtual_String;
      --  Fully-qualified type name of the exception object.
evaluateName : VSS.Strings.Virtual_String;
      --  An expression that can be evaluated in the current scope to obtain the exception object.
stackTrace : VSS.Strings.Virtual_String;
      --  Stack trace at the time the exception was thrown.
innerException : ExceptionDetails_Vector;
      --  Details of the exception contained by this exception, if any.
end record;

type Optional_ExceptionDetails (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : ExceptionDetails;
when False => null;
end case; end record;

type Request is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
command : VSS.Strings.Virtual_String;
      --  The command to execute.
arguments : Any_Value;
      --  Object containing arguments for the command.
end record;

type StepInTargetsArguments is record
frameId : Integer;
      --  The stack frame for which to retrieve the possible step-in targets.
end record;

type StepInTargetsRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : StepInTargetsArguments;
end record;

type ModulesResponse_body is record
modules : Module_Vector;
      --  All modules or range of modules.
totalModules : Optional_Integer;
      --  The total number of modules available.
end record;

type Optional_ModulesResponse_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : ModulesResponse_body;
when False => null;
end case; end record;

type ModulesResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : ModulesResponse_body;
end record;

type NextArguments is record
threadId : Integer;
      --  Specifies the thread for which to resume execution for one step (of the given granularity).
singleThread : Boolean := Boolean'First;
      --  If this flag is true, all other suspended threads are not resumed.
granularity : Enum.Optional_SteppingGranularity;
      --  Stepping granularity. If no granularity is specified, a granularity of `statement` is assumed.
end record;

type ExceptionInfoArguments is record
threadId : Integer;
      --  Thread for which exception information should be retrieved.
end record;

type ExceptionInfoRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : ExceptionInfoArguments;
end record;

type TerminateThreadsArguments is record
threadIds : Integer_Vector;
      --  Ids of threads to be terminated.
end record;

type DataBreakpointInfoArguments is record
variablesReference : Optional_Integer;
      --  Reference to the variable container if the data breakpoint is requested for a child of the container. The `variablesReference` must have been obtained in the current suspended state. See 'Lifetime of Object References' in the Overview section for details.
name : VSS.Strings.Virtual_String;
      --  The name of the variable's child to obtain data breakpoint information for.
      --  If `variablesReference` isn't specified, this can be an expression.
frameId : Optional_Integer;
      --  When `name` is an expression, evaluate it in the scope of this stack frame. If not specified, the expression is evaluated in the global scope. When `variablesReference` is specified, this property has no effect.
end record;

type DataBreakpointInfoRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : DataBreakpointInfoArguments;
end record;

type TerminateThreadsRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : TerminateThreadsArguments;
end record;

type Source is record
name : VSS.Strings.Virtual_String;
      --  The short name of the source. Every source returned from the debug adapter has a name.
      --  When sending a source to the debug adapter this name is optional.
path : VSS.Strings.Virtual_String;
      --  The path of the source to be shown in the UI.
      --  It is only used to locate and load the content of the source if no `sourceReference` is specified (or its value is 0).
sourceReference : Optional_Integer;
      --  If the value > 0 the contents of the source must be retrieved through the `source` request (even if a path is specified).
      --  Since a `sourceReference` is only valid for a session, it can not be used to persist a source.
      --  The value should be less than or equal to 2147483647 (2^31-1).
presentationHint : Enum.Optional_Source_presentationHint;
      --  A hint for how to present the source in the UI.
      --  A value of `deemphasize` can be used to indicate that the source is not available or that it is skipped on stepping.
origin : VSS.Strings.Virtual_String;
      --  The origin of this source. For example, 'internal module', 'inlined content from source map', etc.
sources : Source_Vector;
      --  A list of sources that are related to this source. These may be the source that generated this source.
adapterData : Any_Value;
      --  Additional data that a debug adapter might want to loop through the client.
      --  The client should leave the data intact and persist it across sessions. The client should not interpret the data.
checksums : Checksum_Vector;
      --  The checksums associated with this file.
end record;

type Optional_Source (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : Source;
when False => null;
end case; end record;

type SetBreakpointsArguments is record
source : DAP.Tools.Source;
      --  The source location of the breakpoints; either `source.path` or `source.sourceReference` must be specified.
breakpoints : SourceBreakpoint_Vector;
      --  The code locations of the breakpoints.
lines : Integer_Vector;
      --  Deprecated: The code locations of the breakpoints.
sourceModified : Boolean := Boolean'First;
      --  A value of true indicates that the underlying source has been modified which results in new breakpoint locations.
end record;

type Event is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
event : VSS.Strings.Virtual_String;
      --  Type of event.
a_body : Any_Value;
      --  Event-specific information.
end record;

type Module is record
id : Integer_Or_String;
      --  Unique identifier for the module.
name : VSS.Strings.Virtual_String;
      --  A name of the module.
path : VSS.Strings.Virtual_String;
      --  Logical full path to the module. The exact definition is implementation defined, but usually this would be a full path to the on-disk file for the module.
isOptimized : Boolean := Boolean'First;
      --  True if the module is optimized.
isUserCode : Boolean := Boolean'First;
      --  True if the module is considered 'user code' by a debugger that supports 'Just My Code'.
version : VSS.Strings.Virtual_String;
      --  Version of Module.
symbolStatus : VSS.Strings.Virtual_String;
      --  User-understandable description of if symbols were found for the module (ex: 'Symbols Loaded', 'Symbols not found', etc.)
symbolFilePath : VSS.Strings.Virtual_String;
      --  Logical full path to the symbol file. The exact definition is implementation defined.
dateTimeStamp : VSS.Strings.Virtual_String;
      --  Module created or modified, encoded as a RFC 3339 timestamp.
addressRange : VSS.Strings.Virtual_String;
      --  Address range covered by this module.
end record;

type ModuleEvent_body is record
reason : Enum.ModuleEvent_reason;
      --  The reason for the event.
module : DAP.Tools.Module;
      --  The new, changed, or removed module. In case of `removed` only the module id is used.
end record;

type Optional_ModuleEvent_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : ModuleEvent_body;
when False => null;
end case; end record;

type ModuleEvent is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
a_body : ModuleEvent_body;
end record;

type ContinuedEvent_body is record
threadId : Integer;
      --  The thread which was continued.
allThreadsContinued : Boolean := Boolean'First;
      --  If `allThreadsContinued` is true, a debug adapter can announce that all threads have continued.
end record;

type Optional_ContinuedEvent_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : ContinuedEvent_body;
when False => null;
end case; end record;

type ContinuedEvent is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
a_body : ContinuedEvent_body;
end record;

type AttachRequestArguments is record
restart : Any_Value;
      --  Arbitrary data from the previous, restarted session.
      --  The data is sent as the `restart` attribute of the `terminated` event.
      --  The client should leave the data intact.
pid : Optional_Integer;
      --  Extension. The process ID to which gdb should attach. See Attach.
target : VSS.Strings.Virtual_String;
      --  Extension. The target to which gdb should connect. This is a string and is passed to the target remote
      --  command. See Connecting.
end record;

type Optional_AttachRequestArguments (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : AttachRequestArguments;
when False => null;
end case; end record;

type RestartArguments is record
arguments : Optional_AttachRequestArguments;
      --  The latest version of the `launch` or `attach` configuration.
end record;

type Optional_RestartArguments (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : RestartArguments;
when False => null;
end case; end record;

type ValueFormat is record
hex : Boolean := Boolean'First;
      --  Display the value in hex.
end record;

type Optional_ValueFormat (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : ValueFormat;
when False => null;
end case; end record;

type SetVariableArguments is record
variablesReference : Integer;
      --  The reference of the variable container. The `variablesReference` must have been obtained in the current suspended state. See 'Lifetime of Object References' in the Overview section for details.
name : VSS.Strings.Virtual_String;
      --  The name of the variable in the container.
value : VSS.Strings.Virtual_String;
      --  The value of the variable.
format : Optional_ValueFormat;
      --  Specifies details on how to format the response value.
end record;

type Checksum is record
algorithm : Enum.ChecksumAlgorithm;
      --  The algorithm used to calculate this checksum.
checksum : VSS.Strings.Virtual_String;
      --  Value of the checksum, encoded as a hexadecimal value.
end record;

type BreakpointLocationsArguments is record
source : DAP.Tools.Source;
      --  The source location of the breakpoints; either `source.path` or `source.reference` must be specified.
line : Integer;
      --  Start line of range to search possible breakpoint locations in. If only the line is specified, the request returns all possible locations in that line.
column : Optional_Integer;
      --  Start position within `line` to search possible breakpoint locations in. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based. If no column is given, the first position in the start line is assumed.
endLine : Optional_Integer;
      --  End line of range to search possible breakpoint locations in. If no end line is given, then the end line is assumed to be the start line.
endColumn : Optional_Integer;
      --  End position within `endLine` to search possible breakpoint locations in. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based. If no end column is given, the last position in the end line is assumed.
end record;

type Optional_BreakpointLocationsArguments (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : BreakpointLocationsArguments;
when False => null;
end case; end record;

type BreakpointLocationsRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : Optional_BreakpointLocationsArguments;
end record;

type ModulesViewDescriptor is record
columns : ColumnDescriptor_Vector;
end record;

type ColumnDescriptor is record
attributeName : VSS.Strings.Virtual_String;
      --  Name of the attribute rendered in this column.
label : VSS.Strings.Virtual_String;
      --  Header UI label of column.
format : VSS.Strings.Virtual_String;
      --  Format to use for the rendered values in this column. TBD how the format strings looks like.
a_type : Enum.Optional_ColumnDescriptor_type;
      --  Datatype of values in this column. Defaults to `string` if not specified.
width : Optional_Integer;
      --  Width of this column in characters (hint only).
end record;

type Capabilities is record
supportsConfigurationDoneRequest : Boolean := Boolean'First;
      --  The debug adapter supports the `configurationDone` request.
supportsFunctionBreakpoints : Boolean := Boolean'First;
      --  The debug adapter supports function breakpoints.
supportsConditionalBreakpoints : Boolean := Boolean'First;
      --  The debug adapter supports conditional breakpoints.
supportsHitConditionalBreakpoints : Boolean := Boolean'First;
      --  The debug adapter supports breakpoints that break execution after a specified number of hits.
supportsEvaluateForHovers : Boolean := Boolean'First;
      --  The debug adapter supports a (side effect free) `evaluate` request for data hovers.
exceptionBreakpointFilters : ExceptionBreakpointsFilter_Vector;
      --  Available exception filter options for the `setExceptionBreakpoints` request.
supportsStepBack : Boolean := Boolean'First;
      --  The debug adapter supports stepping back via the `stepBack` and `reverseContinue` requests.
supportsSetVariable : Boolean := Boolean'First;
      --  The debug adapter supports setting a variable to a value.
supportsRestartFrame : Boolean := Boolean'First;
      --  The debug adapter supports restarting a frame.
supportsGotoTargetsRequest : Boolean := Boolean'First;
      --  The debug adapter supports the `gotoTargets` request.
supportsStepInTargetsRequest : Boolean := Boolean'First;
      --  The debug adapter supports the `stepInTargets` request.
supportsCompletionsRequest : Boolean := Boolean'First;
      --  The debug adapter supports the `completions` request.
completionTriggerCharacters : VSS.String_Vectors.Virtual_String_Vector;
      --  The set of characters that should trigger completion in a REPL. If not specified, the UI should assume the `.` character.
supportsModulesRequest : Boolean := Boolean'First;
      --  The debug adapter supports the `modules` request.
additionalModuleColumns : ColumnDescriptor_Vector;
      --  The set of additional module information exposed by the debug adapter.
supportedChecksumAlgorithms : ChecksumAlgorithm_Vector;
      --  Checksum algorithms supported by the debug adapter.
supportsRestartRequest : Boolean := Boolean'First;
      --  The debug adapter supports the `restart` request. In this case a client should not implement `restart` by terminating and relaunching the adapter but by calling the `restart` request.
supportsExceptionOptions : Boolean := Boolean'First;
      --  The debug adapter supports `exceptionOptions` on the `setExceptionBreakpoints` request.
supportsValueFormattingOptions : Boolean := Boolean'First;
      --  The debug adapter supports a `format` attribute on the `stackTrace`, `variables`, and `evaluate` requests.
supportsExceptionInfoRequest : Boolean := Boolean'First;
      --  The debug adapter supports the `exceptionInfo` request.
supportTerminateDebuggee : Boolean := Boolean'First;
      --  The debug adapter supports the `terminateDebuggee` attribute on the `disconnect` request.
supportSuspendDebuggee : Boolean := Boolean'First;
      --  The debug adapter supports the `suspendDebuggee` attribute on the `disconnect` request.
supportsDelayedStackTraceLoading : Boolean := Boolean'First;
      --  The debug adapter supports the delayed loading of parts of the stack, which requires that both the `startFrame` and `levels` arguments and the `totalFrames` result of the `stackTrace` request are supported.
supportsLoadedSourcesRequest : Boolean := Boolean'First;
      --  The debug adapter supports the `loadedSources` request.
supportsLogPoints : Boolean := Boolean'First;
      --  The debug adapter supports log points by interpreting the `logMessage` attribute of the `SourceBreakpoint`.
supportsTerminateThreadsRequest : Boolean := Boolean'First;
      --  The debug adapter supports the `terminateThreads` request.
supportsSetExpression : Boolean := Boolean'First;
      --  The debug adapter supports the `setExpression` request.
supportsTerminateRequest : Boolean := Boolean'First;
      --  The debug adapter supports the `terminate` request.
supportsDataBreakpoints : Boolean := Boolean'First;
      --  The debug adapter supports data breakpoints.
supportsReadMemoryRequest : Boolean := Boolean'First;
      --  The debug adapter supports the `readMemory` request.
supportsWriteMemoryRequest : Boolean := Boolean'First;
      --  The debug adapter supports the `writeMemory` request.
supportsDisassembleRequest : Boolean := Boolean'First;
      --  The debug adapter supports the `disassemble` request.
supportsCancelRequest : Boolean := Boolean'First;
      --  The debug adapter supports the `cancel` request.
supportsBreakpointLocationsRequest : Boolean := Boolean'First;
      --  The debug adapter supports the `breakpointLocations` request.
supportsClipboardContext : Boolean := Boolean'First;
      --  The debug adapter supports the `clipboard` context value in the `evaluate` request.
supportsSteppingGranularity : Boolean := Boolean'First;
      --  The debug adapter supports stepping granularities (argument `granularity`) for the stepping requests.
supportsInstructionBreakpoints : Boolean := Boolean'First;
      --  The debug adapter supports adding breakpoints based on instruction references.
supportsExceptionFilterOptions : Boolean := Boolean'First;
      --  The debug adapter supports `filterOptions` as an argument on the `setExceptionBreakpoints` request.
supportsSingleThreadExecutionRequests : Boolean := Boolean'First;
      --  The debug adapter supports the `singleThread` property on the execution requests (`continue`, `next`, `stepIn`, `stepOut`, `reverseContinue`, `stepBack`).
end record;

type Optional_Capabilities (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : Capabilities;
when False => null;
end case; end record;

type StackTraceResponse_body is record
stackFrames : StackFrame_Vector;
      --  The frames of the stack frame. If the array has length zero, there are no stack frames available.
      --  This means that there is no location information available.
totalFrames : Optional_Integer;
      --  The total number of frames available in the stack. If omitted or if `totalFrames` is larger than the available frames, a client is expected to request frames until a request returns less frames than requested (which indicates the end of the stack). Returning monotonically increasing `totalFrames` values for subsequent requests can be used to enforce paging in the client.
end record;

type Optional_StackTraceResponse_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : StackTraceResponse_body;
when False => null;
end case; end record;

type StackTraceResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : StackTraceResponse_body;
end record;

type LoadedSourcesArguments is new Any_Object with null record;
type Optional_LoadedSourcesArguments (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : LoadedSourcesArguments;
when False => null;
end case; end record;

type ConfigurationDoneArguments is new Any_Object with null record;
type Optional_ConfigurationDoneArguments (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : ConfigurationDoneArguments;
when False => null;
end case; end record;

type ConfigurationDoneRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : Optional_ConfigurationDoneArguments;
end record;

type StepInTargetsResponse_body is record
targets : StepInTarget_Vector;
      --  The possible step-in targets of the specified source location.
end record;

type Optional_StepInTargetsResponse_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : StepInTargetsResponse_body;
when False => null;
end case; end record;

type StepInTargetsResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : StepInTargetsResponse_body;
end record;

type StackFrame is record
id : Integer;
      --  An identifier for the stack frame. It must be unique across all threads.
      --  This id can be used to retrieve the scopes of the frame with the `scopes` request or to restart the execution of a stack frame.
name : VSS.Strings.Virtual_String;
      --  The name of the stack frame, typically a method name.
source : Optional_Source;
      --  The source of the frame.
line : Integer;
      --  The line within the source of the frame. If the source attribute is missing or doesn't exist, `line` is 0 and should be ignored by the client.
column : Integer;
      --  Start position of the range covered by the stack frame. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based. If attribute `source` is missing or doesn't exist, `column` is 0 and should be ignored by the client.
endLine : Optional_Integer;
      --  The end line of the range covered by the stack frame.
endColumn : Optional_Integer;
      --  End position of the range covered by the stack frame. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based.
canRestart : Boolean := Boolean'First;
      --  Indicates whether this frame can be restarted with the `restart` request. Clients should only use this if the debug adapter supports the `restart` request and the corresponding capability `supportsRestartRequest` is true. If a debug adapter has this capability, then `canRestart` defaults to `true` if the property is absent.
instructionPointerReference : VSS.Strings.Virtual_String;
      --  A memory reference for the current instruction pointer in this frame.
moduleId : Optional_Integer_Or_String;
      --  The module associated with this frame, if any.
presentationHint : Enum.Optional_StackFrame_presentationHint;
      --  A hint for how to present this frame in the UI.
      --  A value of `label` can be used to indicate that the frame is an artificial frame that is used as a visual label or separator. A value of `subtle` can be used to change the appearance of a frame in a 'subtle' way.
end record;

type SetExpressionArguments is record
expression : VSS.Strings.Virtual_String;
      --  The l-value expression to assign to.
value : VSS.Strings.Virtual_String;
      --  The value expression to assign to the l-value expression.
frameId : Optional_Integer;
      --  Evaluate the expressions in the scope of this stack frame. If not specified, the expressions are evaluated in the global scope.
format : Optional_ValueFormat;
      --  Specifies how the resulting value should be formatted.
end record;

type SetExpressionRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : SetExpressionArguments;
end record;

type SourceArguments is record
source : Optional_Source;
      --  Specifies the source content to load. Either `source.path` or `source.sourceReference` must be specified.
sourceReference : Integer;
      --  The reference to the source. This is the same as `source.sourceReference`.
      --  This is provided for backward compatibility since old clients do not understand the `source` attribute.
end record;

type ExceptionFilterOptions is record
filterId : VSS.Strings.Virtual_String;
      --  ID of an exception filter returned by the `exceptionBreakpointFilters` capability.
condition : VSS.Strings.Virtual_String;
      --  An expression for conditional exceptions.
      --  The exception breaks into the debugger if the result of the condition is true.
end record;

type ExceptionBreakpointsFilter is record
filter : VSS.Strings.Virtual_String;
      --  The internal ID of the filter option. This value is passed to the `setExceptionBreakpoints` request.
label : VSS.Strings.Virtual_String;
      --  The name of the filter option. This is shown in the UI.
description : VSS.Strings.Virtual_String;
      --  A help text providing additional information about the exception filter. This string is typically shown as a hover and can be translated.
default : Boolean := Boolean'First;
      --  Initial value of the filter option. If not specified a value false is assumed.
supportsCondition : Boolean := Boolean'First;
      --  Controls whether a condition can be specified for this filter option. If false or missing, a condition can not be set.
conditionDescription : VSS.Strings.Virtual_String;
      --  A help text providing information about the condition. This string is shown as the placeholder text for a text box and can be translated.
end record;

type SetVariableRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : SetVariableArguments;
end record;

type AttachRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : AttachRequestArguments;
end record;

type MemoryEvent_body is record
memoryReference : VSS.Strings.Virtual_String;
      --  Memory reference of a memory range that has been updated.
offset : Integer;
      --  Starting offset in bytes where memory has been updated. Can be negative.
count : Integer;
      --  Number of bytes updated.
end record;

type Optional_MemoryEvent_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : MemoryEvent_body;
when False => null;
end case; end record;

type MemoryEvent is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
a_body : MemoryEvent_body;
end record;

type ReadMemoryArguments is record
memoryReference : VSS.Strings.Virtual_String;
      --  Memory reference to the base location from which data should be read.
offset : Optional_Integer;
      --  Offset (in bytes) to be applied to the reference location before reading data. Can be negative.
count : Integer;
      --  Number of bytes to read at the specified location and offset.
end record;

type LoadedSourcesRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : Optional_LoadedSourcesArguments;
end record;

type LaunchRequestArguments is record
noDebug : Boolean := Boolean'First;
      --  If true, the launch request should launch the program without enabling debugging.
restart : Any_Value;
      --  Arbitrary data from the previous, restarted session.
      --  The data is sent as the `restart` attribute of the `terminated` event.
      --  The client should leave the data intact.
program : VSS.Strings.Virtual_String;
      --  Extension. If provided, this is a string that specifies the program to use. This corresponds to the file command. See Files.
args : VSS.String_Vectors.Virtual_String_Vector;
      --  Extension. If provided, this should be an array of strings.
      --  These strings are provided as command-line
      --  arguments to the inferior, as if by set args.
cwd : VSS.Strings.Virtual_String;
      --  Extension. If provided, this should be a string. gdb will change its working directory to this directory, as if by
      --  the cd command (see Working Directory). The launched program will inherit this as its working
      --  directory. Note that change of directory happens before the program parameter is processed. This
      --  will affect the result if program is a relative filename.
stopAtBeginningOfMainSubprogram : Boolean := Boolean'First;
      --  Extension. If provided, this must be a boolean. When ‘True’, gdb will set a temporary breakpoint at the
      --  program's main procedure, using the same approach as the start command. See Starting.
end record;

type ExitedEvent_body is record
exitCode : Integer;
      --  The exit code returned from the debuggee.
end record;

type Optional_ExitedEvent_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : ExitedEvent_body;
when False => null;
end case; end record;

type ExitedEvent is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
a_body : ExitedEvent_body;
end record;

type SetBreakpointsRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : SetBreakpointsArguments;
end record;

type TerminateResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : Any_Value;
      --  Contains request result if success is true and error details if success is false.
end record;

type VariablePresentationHint is record
kind : Enum.Optional_VariablePresentationHint_kind;
      --  The kind of variable. Before introducing additional values, try to use the listed values.
attributes : VariablePresentationHint_attributes_Vector;
      --  Set of attributes represented as an array of strings. Before introducing additional values, try to use the listed values.
visibility : Enum.Optional_VariablePresentationHint_visibility;
      --  Visibility of variable. Before introducing additional values, try to use the listed values.
lazy : Boolean := Boolean'First;
      --  If true, clients can present the variable with a UI that supports a specific gesture to trigger its evaluation.
      --  This mechanism can be used for properties that require executing code when retrieving their value and where the code execution can be expensive and/or produce side-effects. A typical example are properties based on a getter function.
      --  Please note that in addition to the `lazy` flag, the variable's `variablesReference` is expected to refer to a variable that will provide the value through another `variable` request.
end record;

type Optional_VariablePresentationHint (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : VariablePresentationHint;
when False => null;
end case; end record;

type Variable is record
name : VSS.Strings.Virtual_String;
      --  The variable's name.
value : VSS.Strings.Virtual_String;
      --  The variable's value.
      --  This can be a multi-line text, e.g. for a function the body of a function.
      --  For structured variables (which do not have a simple value), it is recommended to provide a one-line representation of the structured object. This helps to identify the structured object in the collapsed state when its children are not yet visible.
      --  An empty string can be used if no value should be shown in the UI.
a_type : VSS.Strings.Virtual_String;
      --  The type of the variable's value. Typically shown in the UI when hovering over the value.
      --  This attribute should only be returned by a debug adapter if the corresponding capability `supportsVariableType` is true.
presentationHint : Optional_VariablePresentationHint;
      --  Properties of a variable that can be used to determine how to render the variable in the UI.
evaluateName : VSS.Strings.Virtual_String;
      --  The evaluatable name of this variable which can be passed to the `evaluate` request to fetch the variable's value.
variablesReference : Integer;
      --  If `variablesReference` is > 0, the variable is structured and its children can be retrieved by passing `variablesReference` to the `variables` request as long as execution remains suspended. See 'Lifetime of Object References' in the Overview section for details.
namedVariables : Optional_Integer;
      --  The number of named child variables.
      --  The client can use this information to present the children in a paged UI and fetch them in chunks.
indexedVariables : Optional_Integer;
      --  The number of indexed child variables.
      --  The client can use this information to present the children in a paged UI and fetch them in chunks.
memoryReference : VSS.Strings.Virtual_String;
      --  The memory reference for the variable if the variable represents executable code, such as a function pointer.
      --  This attribute is only required if the corresponding capability `supportsMemoryReferences` is true.
end record;

type StoppedEvent_body is record
reason : Enum.StoppedEvent_reason;
      --  The reason for the event.
      --  For backward compatibility this string is shown in the UI if the `description` attribute is missing (but it must not be translated).
description : VSS.Strings.Virtual_String;
      --  The full reason for the event, e.g. 'Paused on exception'. This string is shown in the UI as is and can be translated.
threadId : Optional_Integer;
      --  The thread which was stopped.
preserveFocusHint : Boolean := Boolean'First;
      --  A value of true hints to the client that this event should not change the focus.
text : VSS.Strings.Virtual_String;
      --  Additional information. E.g. if reason is `exception`, text contains the exception name. This string is shown in the UI.
allThreadsStopped : Boolean := Boolean'First;
      --  If `allThreadsStopped` is true, a debug adapter can announce that all threads have stopped.
      --  - The client should use this information to enable that all threads can be expanded to access their stacktraces.
      --  - If the attribute is missing or false, only the thread with the given `threadId` can be expanded.
hitBreakpointIds : Integer_Vector;
      --  Ids of the breakpoints that triggered the event. In most cases there is only a single breakpoint but here are some examples for multiple breakpoints:
      --  - Different types of breakpoints map to the same location.
      --  - Multiple source breakpoints get collapsed to the same instruction by the compiler/runtime.
      --  - Multiple function breakpoints with different function names map to the same location.
end record;

type Optional_StoppedEvent_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : StoppedEvent_body;
when False => null;
end case; end record;

type StoppedEvent is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
a_body : StoppedEvent_body;
end record;

type RestartFrameArguments is record
frameId : Integer;
      --  Restart the stack frame identified by `frameId`. The `frameId` must have been obtained in the current suspended state. See 'Lifetime of Object References' in the Overview section for details.
end record;

type RestartFrameRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : RestartFrameArguments;
end record;

type ScopesResponse_body is record
scopes : Scope_Vector;
      --  The scopes of the stack frame. If the array has length zero, there are no scopes available.
end record;

type Optional_ScopesResponse_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : ScopesResponse_body;
when False => null;
end case; end record;

type ScopesResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : ScopesResponse_body;
end record;

type StepOutArguments is record
threadId : Integer;
      --  Specifies the thread for which to resume execution for one step-out (of the given granularity).
singleThread : Boolean := Boolean'First;
      --  If this flag is true, all other suspended threads are not resumed.
granularity : Enum.Optional_SteppingGranularity;
      --  Stepping granularity. If no granularity is specified, a granularity of `statement` is assumed.
end record;

type CompletionsArguments is record
frameId : Optional_Integer;
      --  Returns completions in the scope of this stack frame. If not specified, the completions are returned for the global scope.
text : VSS.Strings.Virtual_String;
      --  One or more source lines. Typically this is the text users have typed into the debug console before they asked for completion.
column : Integer;
      --  The position within `text` for which to determine the completion proposals. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based.
line : Optional_Integer;
      --  A line for which to determine the completion proposals. If missing the first line of the text is assumed.
end record;

type CompletionsRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : CompletionsArguments;
end record;

type StartDebuggingRequestArguments is record
configuration : Any_Object;
      --  Arguments passed to the new debug session. The arguments must only contain properties understood by the `launch` or `attach` requests of the debug adapter and they must not contain any client-specific properties (e.g. `type`) or client-specific features (e.g. substitutable 'variables').
request : Enum.StartDebuggingRequestArguments_request;
      --  Indicates whether the new debug session should be started with a `launch` or `attach` request.
end record;

type ProgressUpdateEvent_body is record
progressId : VSS.Strings.Virtual_String;
      --  The ID that was introduced in the initial `progressStart` event.
message : VSS.Strings.Virtual_String;
      --  More detailed progress message. If omitted, the previous message (if any) is used.
percentage : Optional_Float;
      --  Progress percentage to display (value range: 0 to 100). If omitted no percentage is shown.
end record;

type Optional_ProgressUpdateEvent_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : ProgressUpdateEvent_body;
when False => null;
end case; end record;

type ProgressUpdateEvent is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
a_body : ProgressUpdateEvent_body;
end record;

type ExceptionInfoResponse_body is record
exceptionId : VSS.Strings.Virtual_String;
      --  ID of the exception that was thrown.
description : VSS.Strings.Virtual_String;
      --  Descriptive text for the exception.
breakMode : Enum.ExceptionBreakMode;
      --  Mode that caused the exception notification to be raised.
details : Optional_ExceptionDetails;
      --  Detailed information about the exception.
end record;

type Optional_ExceptionInfoResponse_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : ExceptionInfoResponse_body;
when False => null;
end case; end record;

type ExceptionInfoResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : ExceptionInfoResponse_body;
end record;

type InitializedEvent is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
a_body : Any_Value;
      --  Event-specific information.
end record;

type SetExpressionResponse_body is record
value : VSS.Strings.Virtual_String;
      --  The new value of the expression.
a_type : VSS.Strings.Virtual_String;
      --  The type of the value.
      --  This attribute should only be returned by a debug adapter if the corresponding capability `supportsVariableType` is true.
presentationHint : Optional_VariablePresentationHint;
      --  Properties of a value that can be used to determine how to render the result in the UI.
variablesReference : Optional_Integer;
      --  If `variablesReference` is > 0, the evaluate result is structured and its children can be retrieved by passing `variablesReference` to the `variables` request as long as execution remains suspended. See 'Lifetime of Object References' in the Overview section for details.
namedVariables : Optional_Integer;
      --  The number of named child variables.
      --  The client can use this information to present the variables in a paged UI and fetch them in chunks.
      --  The value should be less than or equal to 2147483647 (2^31-1).
indexedVariables : Optional_Integer;
      --  The number of indexed child variables.
      --  The client can use this information to present the variables in a paged UI and fetch them in chunks.
      --  The value should be less than or equal to 2147483647 (2^31-1).
end record;

type Optional_SetExpressionResponse_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : SetExpressionResponse_body;
when False => null;
end case; end record;

type SetExpressionResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : SetExpressionResponse_body;
end record;

type StepInTarget is record
id : Integer;
      --  Unique identifier for a step-in target.
label : VSS.Strings.Virtual_String;
      --  The name of the step-in target (shown in the UI).
line : Optional_Integer;
      --  The line of the step-in target.
column : Optional_Integer;
      --  Start position of the range covered by the step in target. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based.
endLine : Optional_Integer;
      --  The end line of the range covered by the step-in target.
endColumn : Optional_Integer;
      --  End position of the range covered by the step in target. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based.
end record;

type ReverseContinueResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : Any_Value;
      --  Contains request result if success is true and error details if success is false.
end record;

type OutputEvent_body is record
category : Enum.Optional_OutputEvent_category;
      --  The output category. If not specified or if the category is not understood by the client, `console` is assumed.
output : VSS.Strings.Virtual_String;
      --  The output to report.
group : Enum.Optional_OutputEvent_group;
      --  Support for keeping an output log organized by grouping related messages.
variablesReference : Optional_Integer;
      --  If an attribute `variablesReference` exists and its value is > 0, the output contains objects which can be retrieved by passing `variablesReference` to the `variables` request as long as execution remains suspended. See 'Lifetime of Object References' in the Overview section for details.
source : Optional_Source;
      --  The source location where the output was produced.
line : Optional_Integer;
      --  The source location's line where the output was produced.
column : Optional_Integer;
      --  The position in `line` where the output was produced. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based.
data : Any_Value;
      --  Additional data to report. For the `telemetry` category the data is sent to telemetry, for the other categories the data is shown in JSON format.
end record;

type Optional_OutputEvent_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : OutputEvent_body;
when False => null;
end case; end record;

type OutputEvent is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
a_body : OutputEvent_body;
end record;

type RestartRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : Optional_RestartArguments;
end record;

type StackFrameFormat is record
hex : Boolean := Boolean'First;
      --  Display the value in hex.
parameters : Boolean := Boolean'First;
      --  Displays parameters for the stack frame.
parameterTypes : Boolean := Boolean'First;
      --  Displays the types of parameters for the stack frame.
parameterNames : Boolean := Boolean'First;
      --  Displays the names of parameters for the stack frame.
parameterValues : Boolean := Boolean'First;
      --  Displays the values of parameters for the stack frame.
line : Boolean := Boolean'First;
      --  Displays the line number of the stack frame.
module : Boolean := Boolean'First;
      --  Displays the module of the stack frame.
includeAll : Boolean := Boolean'First;
      --  Includes all stack frames, including those the debug adapter might otherwise hide.
end record;

type Optional_StackFrameFormat (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : StackFrameFormat;
when False => null;
end case; end record;

type StackTraceArguments is record
threadId : Integer;
      --  Retrieve the stacktrace for this thread.
startFrame : Optional_Integer;
      --  The index of the first frame to return; if omitted frames start at 0.
levels : Optional_Integer;
      --  The maximum number of frames to return. If levels is not specified or 0, all frames are returned.
format : Optional_StackFrameFormat;
      --  Specifies details on how to format the stack frames.
      --  The attribute is only honored by a debug adapter if the corresponding capability `supportsValueFormattingOptions` is true.
end record;

type Thread is record
id : Integer;
      --  Unique identifier for the thread.
name : VSS.Strings.Virtual_String;
      --  The name of the thread.
end record;

type SetDataBreakpointsArguments is record
breakpoints : DataBreakpoint_Vector;
      --  The contents of this array replaces all existing data breakpoints. An empty array clears all data breakpoints.
end record;

type SetDataBreakpointsRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : SetDataBreakpointsArguments;
end record;

type SourceRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : SourceArguments;
end record;

type PauseResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : Any_Value;
      --  Contains request result if success is true and error details if success is false.
end record;

type SetFunctionBreakpointsArguments is record
breakpoints : FunctionBreakpoint_Vector;
      --  The function names of the breakpoints.
end record;

type SetFunctionBreakpointsRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : SetFunctionBreakpointsArguments;
end record;

type ProcessEvent_body is record
name : VSS.Strings.Virtual_String;
      --  The logical name of the process. This is usually the full path to process's executable file. Example: /home/example/myproj/program.js.
systemProcessId : Optional_Integer;
      --  The system process id of the debugged process. This property is missing for non-system processes.
isLocalProcess : Boolean := Boolean'First;
      --  If true, the process is running on the same computer as the debug adapter.
startMethod : Enum.Optional_ProcessEvent_startMethod;
      --  Describes how the debug engine started debugging this process.
pointerSize : Optional_Integer;
      --  The size of a pointer or address for this process, in bits. This value may be used by clients when formatting addresses for display.
end record;

type Optional_ProcessEvent_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : ProcessEvent_body;
when False => null;
end case; end record;

type ProcessEvent is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
a_body : ProcessEvent_body;
end record;

type NextResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : Any_Value;
      --  Contains request result if success is true and error details if success is false.
end record;

type AttachResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : Any_Value;
      --  Contains request result if success is true and error details if success is false.
end record;

type RestartResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : Any_Value;
      --  Contains request result if success is true and error details if success is false.
end record;

type CapabilitiesEvent_body is record
capabilities : DAP.Tools.Capabilities;
      --  The set of updated capabilities.
end record;

type Optional_CapabilitiesEvent_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : CapabilitiesEvent_body;
when False => null;
end case; end record;

type CapabilitiesEvent is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
a_body : CapabilitiesEvent_body;
end record;

type Scope is record
name : VSS.Strings.Virtual_String;
      --  Name of the scope such as 'Arguments', 'Locals', or 'Registers'. This string is shown in the UI as is and can be translated.
presentationHint : Enum.Optional_Scope_presentationHint;
      --  A hint for how to present this scope in the UI. If this attribute is missing, the scope is shown with a generic UI.
variablesReference : Integer;
      --  The variables of this scope can be retrieved by passing the value of `variablesReference` to the `variables` request as long as execution remains suspended. See 'Lifetime of Object References' in the Overview section for details.
namedVariables : Optional_Integer;
      --  The number of named variables in this scope.
      --  The client can use this information to present the variables in a paged UI and fetch them in chunks.
indexedVariables : Optional_Integer;
      --  The number of indexed variables in this scope.
      --  The client can use this information to present the variables in a paged UI and fetch them in chunks.
expensive : Boolean;
      --  If true, the number of variables in this scope is large or expensive to retrieve.
source : Optional_Source;
      --  The source for this scope.
line : Optional_Integer;
      --  The start line of the range covered by this scope.
column : Optional_Integer;
      --  Start position of the range covered by the scope. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based.
endLine : Optional_Integer;
      --  The end line of the range covered by this scope.
endColumn : Optional_Integer;
      --  End position of the range covered by the scope. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based.
end record;

type DisassembleArguments is record
memoryReference : VSS.Strings.Virtual_String;
      --  Memory reference to the base location containing the instructions to disassemble.
offset : Optional_Integer;
      --  Offset (in bytes) to be applied to the reference location before disassembling. Can be negative.
instructionOffset : Optional_Integer;
      --  Offset (in instructions) to be applied after the byte offset (if any) before disassembling. Can be negative.
instructionCount : Integer;
      --  Number of instructions to disassemble starting at the specified location and offset.
      --  An adapter must return exactly this number of instructions - any unavailable instructions should be replaced with an implementation-defined 'invalid instruction' value.
resolveSymbols : Boolean := Boolean'First;
      --  If true, the adapter should attempt to resolve memory addresses and other values to symbolic names.
end record;

type SetInstructionBreakpointsArguments is record
breakpoints : InstructionBreakpoint_Vector;
      --  The instruction references of the breakpoints
end record;

type SetInstructionBreakpointsRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : SetInstructionBreakpointsArguments;
end record;

type DataBreakpointInfoResponse_body is record
dataId : VSS.Strings.Virtual_String;
      --  An identifier for the data on which a data breakpoint can be registered with the `setDataBreakpoints` request or null if no data breakpoint is available.
description : VSS.Strings.Virtual_String;
      --  UI string that describes on what data the breakpoint is set on or why a data breakpoint is not available.
accessTypes : DataBreakpointAccessType_Vector;
      --  Attribute lists the available access types for a potential data breakpoint. A UI client could surface this information.
canPersist : Boolean := Boolean'First;
      --  Attribute indicates that a potential data breakpoint could be persisted across sessions.
end record;

type Optional_DataBreakpointInfoResponse_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : DataBreakpointInfoResponse_body;
when False => null;
end case; end record;

type DataBreakpointInfoResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : DataBreakpointInfoResponse_body;
end record;

type SourceBreakpoint is record
line : Integer;
      --  The source line of the breakpoint or logpoint.
column : Optional_Integer;
      --  Start position within source line of the breakpoint or logpoint. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based.
condition : VSS.Strings.Virtual_String;
      --  The expression for conditional breakpoints.
      --  It is only honored by a debug adapter if the corresponding capability `supportsConditionalBreakpoints` is true.
hitCondition : VSS.Strings.Virtual_String;
      --  The expression that controls how many hits of the breakpoint are ignored.
      --  The debug adapter is expected to interpret the expression as needed.
      --  The attribute is only honored by a debug adapter if the corresponding capability `supportsHitConditionalBreakpoints` is true.
      --  If both this property and `condition` are specified, `hitCondition` should be evaluated only if the `condition` is met, and the debug adapter should stop only if both conditions are met.
logMessage : VSS.Strings.Virtual_String;
      --  If this attribute exists and is non-empty, the debug adapter must not 'break' (stop)
      --  but log the message instead. Expressions within `{}` are interpolated.
      --  The attribute is only honored by a debug adapter if the corresponding capability `supportsLogPoints` is true.
      --  If either `hitCondition` or `condition` is specified, then the message should only be logged if those conditions are met.
end record;

type PauseArguments is record
threadId : Integer;
      --  Pause execution for this thread.
end record;

type PauseRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : PauseArguments;
end record;

type FunctionBreakpoint is record
name : VSS.Strings.Virtual_String;
      --  The name of the function.
condition : VSS.Strings.Virtual_String;
      --  An expression for conditional breakpoints.
      --  It is only honored by a debug adapter if the corresponding capability `supportsConditionalBreakpoints` is true.
hitCondition : VSS.Strings.Virtual_String;
      --  An expression that controls how many hits of the breakpoint are ignored.
      --  The debug adapter is expected to interpret the expression as needed.
      --  The attribute is only honored by a debug adapter if the corresponding capability `supportsHitConditionalBreakpoints` is true.
end record;

type SetExceptionBreakpointsArguments is record
filters : VSS.String_Vectors.Virtual_String_Vector;
      --  Set of exception filters specified by their ID. The set of all possible exception filters is defined by the `exceptionBreakpointFilters` capability. The `filter` and `filterOptions` sets are additive.
filterOptions : ExceptionFilterOptions_Vector;
      --  Set of exception filters and their options. The set of all possible exception filters is defined by the `exceptionBreakpointFilters` capability. This attribute is only honored by a debug adapter if the corresponding capability `supportsExceptionFilterOptions` is true. The `filter` and `filterOptions` sets are additive.
exceptionOptions : ExceptionOptions_Vector;
      --  Configuration options for selected exceptions.
      --  The attribute is only honored by a debug adapter if the corresponding capability `supportsExceptionOptions` is true.
end record;

type RunInTerminalRequestArguments is record
kind : Enum.Optional_RunInTerminalRequestArguments_kind;
      --  What kind of terminal to launch. Defaults to `integrated` if not specified.
title : VSS.Strings.Virtual_String;
      --  Title of the terminal.
cwd : VSS.Strings.Virtual_String;
      --  Working directory for the command. For non-empty, valid paths this typically results in execution of a change directory command.
args : VSS.String_Vectors.Virtual_String_Vector;
      --  List of arguments. The first argument is the command to run.
env : Any_Object;
      --  Environment key-value pairs that are added to or removed from the default environment.
argsCanBeInterpretedByShell : Boolean := Boolean'First;
      --  This property should only be set if the corresponding capability `supportsArgsCanBeInterpretedByShell` is true. If the client uses an intermediary shell to launch the application, then the client must not attempt to escape characters with special meanings for the shell. The user is fully responsible for escaping as needed and that arguments using special characters may not be portable across shells.
end record;

type RunInTerminalRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : RunInTerminalRequestArguments;
end record;

type WriteMemoryResponse_body is record
offset : Optional_Integer;
      --  Property that should be returned when `allowPartial` is true to indicate the offset of the first byte of data successfully written. Can be negative.
bytesWritten : Optional_Integer;
      --  Property that should be returned when `allowPartial` is true to indicate the number of bytes starting from address that were successfully written.
end record;

type Optional_WriteMemoryResponse_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : WriteMemoryResponse_body;
when False => null;
end case; end record;

type WriteMemoryResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : Optional_WriteMemoryResponse_body;
end record;

type ReverseContinueArguments is record
threadId : Integer;
      --  Specifies the active thread. If the debug adapter supports single thread execution (see `supportsSingleThreadExecutionRequests`) and the `singleThread` argument is true, only the thread with this ID is resumed.
singleThread : Boolean := Boolean'First;
      --  If this flag is true, backward execution is resumed only for the thread with given `threadId`.
end record;

type RunInTerminalResponse_body is record
processId : Optional_Integer;
      --  The process ID. The value should be less than or equal to 2147483647 (2^31-1).
shellProcessId : Optional_Integer;
      --  The process ID of the terminal shell. The value should be less than or equal to 2147483647 (2^31-1).
end record;

type Optional_RunInTerminalResponse_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : RunInTerminalResponse_body;
when False => null;
end case; end record;

type RunInTerminalResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : RunInTerminalResponse_body;
end record;

type DisconnectArguments is record
restart : Boolean := Boolean'First;
      --  A value of true indicates that this `disconnect` request is part of a restart sequence.
terminateDebuggee : Boolean := Boolean'First;
      --  Indicates whether the debuggee should be terminated when the debugger is disconnected.
      --  If unspecified, the debug adapter is free to do whatever it thinks is best.
      --  The attribute is only honored by a debug adapter if the corresponding capability `supportTerminateDebuggee` is true.
suspendDebuggee : Boolean := Boolean'First;
      --  Indicates whether the debuggee should stay suspended when the debugger is disconnected.
      --  If unspecified, the debuggee should resume execution.
      --  The attribute is only honored by a debug adapter if the corresponding capability `supportSuspendDebuggee` is true.
end record;

type Optional_DisconnectArguments (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : DisconnectArguments;
when False => null;
end case; end record;

type GotoTargetsArguments is record
source : DAP.Tools.Source;
      --  The source location for which the goto targets are determined.
line : Integer;
      --  The line location for which the goto targets are determined.
column : Optional_Integer;
      --  The position within `line` for which the goto targets are determined. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based.
end record;

type GotoTargetsRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : GotoTargetsArguments;
end record;

type ThreadsResponse_body is record
threads : Thread_Vector;
      --  All threads.
end record;

type Optional_ThreadsResponse_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : ThreadsResponse_body;
when False => null;
end case; end record;

type ThreadsResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : ThreadsResponse_body;
end record;

type SetDataBreakpointsResponse_body is record
breakpoints : Breakpoint_Vector;
      --  Information about the data breakpoints. The array elements correspond to the elements of the input argument `breakpoints` array.
end record;

type Optional_SetDataBreakpointsResponse_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : SetDataBreakpointsResponse_body;
when False => null;
end case; end record;

type SetDataBreakpointsResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : SetDataBreakpointsResponse_body;
end record;

type DataBreakpoint is record
dataId : VSS.Strings.Virtual_String;
      --  An id representing the data. This id is returned from the `dataBreakpointInfo` request.
accessType : Enum.Optional_DataBreakpointAccessType;
      --  The access type of the data.
condition : VSS.Strings.Virtual_String;
      --  An expression for conditional breakpoints.
hitCondition : VSS.Strings.Virtual_String;
      --  An expression that controls how many hits of the breakpoint are ignored.
      --  The debug adapter is expected to interpret the expression as needed.
end record;

type ExceptionPathSegment is record
negate : Boolean := Boolean'First;
      --  If false or missing this segment matches the names provided, otherwise it matches anything except the names provided.
names : VSS.String_Vectors.Virtual_String_Vector;
      --  Depending on the value of `negate` the names that should match or not match.
end record;

type Message is record
id : Integer;
      --  Unique (within a debug adapter implementation) identifier for the message. The purpose of these error IDs is to help extension authors that have the requirement that every user visible error message needs a corresponding error number, so that users or customer support can find information about the specific error more easily.
format : VSS.Strings.Virtual_String;
      --  A format string for the message. Embedded variables have the form `{name}`.
      --  If variable name starts with an underscore character, the variable does not contain user data (PII) and can be safely used for telemetry purposes.
variables : Any_Object;
      --  An object used as a dictionary for looking up the variables in the format string.
sendTelemetry : Boolean := Boolean'First;
      --  If true send to telemetry.
showUser : Boolean := Boolean'First;
      --  If true show user.
url : VSS.Strings.Virtual_String;
      --  A url where additional information about this message can be found.
urlLabel : VSS.Strings.Virtual_String;
      --  A label that is presented to the user as the UI for opening the url.
end record;

type Optional_Message (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : Message;
when False => null;
end case; end record;

type SourceResponse_body is record
content : VSS.Strings.Virtual_String;
      --  Content of the source reference.
mimeType : VSS.Strings.Virtual_String;
      --  Content type (MIME type) of the source.
end record;

type Optional_SourceResponse_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : SourceResponse_body;
when False => null;
end case; end record;

type SourceResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : SourceResponse_body;
end record;

type ContinueResponse_body is record
allThreadsContinued : Boolean := Boolean'First;
      --  The value true (or a missing property) signals to the client that all threads have been resumed. The value false indicates that not all threads were resumed.
end record;

type Optional_ContinueResponse_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : ContinueResponse_body;
when False => null;
end case; end record;

type ContinueResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : ContinueResponse_body;
end record;

type RestartFrameResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : Any_Value;
      --  Contains request result if success is true and error details if success is false.
end record;

type StepInArguments is record
threadId : Integer;
      --  Specifies the thread for which to resume execution for one step-into (of the given granularity).
singleThread : Boolean := Boolean'First;
      --  If this flag is true, all other suspended threads are not resumed.
targetId : Optional_Integer;
      --  Id of the target to step into.
granularity : Enum.Optional_SteppingGranularity;
      --  Stepping granularity. If no granularity is specified, a granularity of `statement` is assumed.
end record;

type LaunchResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : Any_Value;
      --  Contains request result if success is true and error details if success is false.
end record;

type StepInResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : Any_Value;
      --  Contains request result if success is true and error details if success is false.
end record;

type TerminateArguments is record
restart : Boolean := Boolean'First;
      --  A value of true indicates that this `terminate` request is part of a restart sequence.
end record;

type Optional_TerminateArguments (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : TerminateArguments;
when False => null;
end case; end record;

type LaunchRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : LaunchRequestArguments;
end record;

type StepOutResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : Any_Value;
      --  Contains request result if success is true and error details if success is false.
end record;

type EvaluateArguments is record
expression : VSS.Strings.Virtual_String;
      --  The expression to evaluate.
frameId : Optional_Integer;
      --  Evaluate the expression in the scope of this stack frame. If not specified, the expression is evaluated in the global scope.
context : Enum.Optional_EvaluateArguments_context;
      --  The context in which the evaluate request is used.
format : Optional_ValueFormat;
      --  Specifies details on how to format the result.
      --  The attribute is only honored by a debug adapter if the corresponding capability `supportsValueFormattingOptions` is true.
end record;

type EvaluateRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : EvaluateArguments;
end record;

type ContinueArguments is record
threadId : Integer;
      --  Specifies the active thread. If the debug adapter supports single thread execution (see `supportsSingleThreadExecutionRequests`) and the argument `singleThread` is true, only the thread with this ID is resumed.
singleThread : Boolean := Boolean'First;
      --  If this flag is true, execution is resumed only for the thread with given `threadId`.
end record;

type StepBackArguments is record
threadId : Integer;
      --  Specifies the thread for which to resume execution for one step backwards (of the given granularity).
singleThread : Boolean := Boolean'First;
      --  If this flag is true, all other suspended threads are not resumed.
granularity : Enum.Optional_SteppingGranularity;
      --  Stepping granularity to step. If no granularity is specified, a granularity of `statement` is assumed.
end record;

type CancelArguments is record
requestId : Optional_Integer;
      --  The ID (attribute `seq`) of the request to cancel. If missing no request is cancelled.
      --  Both a `requestId` and a `progressId` can be specified in one request.
progressId : VSS.Strings.Virtual_String;
      --  The ID (attribute `progressId`) of the progress to cancel. If missing no progress is cancelled.
      --  Both a `requestId` and a `progressId` can be specified in one request.
end record;

type Optional_CancelArguments (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : CancelArguments;
when False => null;
end case; end record;

type CompletionsResponse_body is record
targets : CompletionItem_Vector;
      --  The possible completions for .
end record;

type Optional_CompletionsResponse_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : CompletionsResponse_body;
when False => null;
end case; end record;

type CompletionsResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : CompletionsResponse_body;
end record;

type Breakpoint is record
id : Optional_Integer;
      --  The identifier for the breakpoint. It is needed if breakpoint events are used to update or remove breakpoints.
verified : Boolean;
      --  If true, the breakpoint could be set (but not necessarily at the desired location).
message : VSS.Strings.Virtual_String;
      --  A message about the state of the breakpoint.
      --  This is shown to the user and can be used to explain why a breakpoint could not be verified.
source : Optional_Source;
      --  The source where the breakpoint is located.
line : Optional_Integer;
      --  The start line of the actual range covered by the breakpoint.
column : Optional_Integer;
      --  Start position of the source range covered by the breakpoint. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based.
endLine : Optional_Integer;
      --  The end line of the actual range covered by the breakpoint.
endColumn : Optional_Integer;
      --  End position of the source range covered by the breakpoint. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based.
      --  If no end line is given, then the end column is assumed to be in the start line.
instructionReference : VSS.Strings.Virtual_String;
      --  A memory reference to where the breakpoint is set.
offset : Optional_Integer;
      --  The offset from the instruction reference.
      --  This can be negative.
end record;

type WriteMemoryArguments is record
memoryReference : VSS.Strings.Virtual_String;
      --  Memory reference to the base location to which data should be written.
offset : Optional_Integer;
      --  Offset (in bytes) to be applied to the reference location before writing data. Can be negative.
allowPartial : Boolean := Boolean'First;
      --  Property to control partial writes. If true, the debug adapter should attempt to write memory even if the entire memory region is not writable. In such a case the debug adapter should stop after hitting the first byte of memory that cannot be written and return the number of bytes written in the response via the `offset` and `bytesWritten` properties.
      --  If false or missing, a debug adapter should attempt to verify the region is writable before writing, and fail the response if it is not.
data : VSS.Strings.Virtual_String;
      --  Bytes to write, encoded using base64.
end record;

type StepOutRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : StepOutArguments;
end record;

type LoadedSourceEvent_body is record
reason : Enum.LoadedSourceEvent_reason;
      --  The reason for the event.
source : DAP.Tools.Source;
      --  The new, changed, or removed source.
end record;

type Optional_LoadedSourceEvent_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : LoadedSourceEvent_body;
when False => null;
end case; end record;

type LoadedSourceEvent is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
a_body : LoadedSourceEvent_body;
end record;

type DisassembleRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : DisassembleArguments;
end record;

type ReadMemoryResponse_body is record
address : VSS.Strings.Virtual_String;
      --  The address of the first byte of data returned.
      --  Treated as a hex value if prefixed with `0x`, or as a decimal value otherwise.
unreadableBytes : Optional_Integer;
      --  The number of unreadable bytes encountered after the last successfully read byte.
      --  This can be used to determine the number of bytes that should be skipped before a subsequent `readMemory` request succeeds.
data : VSS.Strings.Virtual_String;
      --  The bytes read from memory, encoded using base64. If the decoded length of `data` is less than the requested `count` in the original `readMemory` request, and `unreadableBytes` is zero or omitted, then the client should assume it's reached the end of readable memory.
end record;

type Optional_ReadMemoryResponse_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : ReadMemoryResponse_body;
when False => null;
end case; end record;

type ReadMemoryResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : Optional_ReadMemoryResponse_body;
end record;

type StepBackRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : StepBackArguments;
end record;

type ThreadsRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : Any_Value;
      --  Object containing arguments for the command.
end record;

type VariablesResponse_body is record
variables : Variable_Vector;
      --  All (or a range) of variables for the given variable reference.
end record;

type Optional_VariablesResponse_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : VariablesResponse_body;
when False => null;
end case; end record;

type VariablesResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : VariablesResponse_body;
end record;

type TerminateRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : Optional_TerminateArguments;
end record;

type VariablesArguments is record
variablesReference : Integer;
      --  The variable for which to retrieve its children. The `variablesReference` must have been obtained in the current suspended state. See 'Lifetime of Object References' in the Overview section for details.
filter : Enum.Optional_VariablesArguments_filter;
      --  Filter to limit the child variables to either named or indexed. If omitted, both types are fetched.
start : Optional_Integer;
      --  The index of the first variable to return; if omitted children start at 0.
count : Optional_Integer;
      --  The number of variables to return. If count is missing or 0, all variables are returned.
format : Optional_ValueFormat;
      --  Specifies details on how to format the Variable values.
      --  The attribute is only honored by a debug adapter if the corresponding capability `supportsValueFormattingOptions` is true.
end record;

type InitializeRequestArguments is record
clientID : VSS.Strings.Virtual_String;
      --  The ID of the client using this adapter.
clientName : VSS.Strings.Virtual_String;
      --  The human-readable name of the client using this adapter.
adapterID : VSS.Strings.Virtual_String;
      --  The ID of the debug adapter.
locale : VSS.Strings.Virtual_String;
      --  The ISO-639 locale of the client using this adapter, e.g. en-US or de-CH.
linesStartAt1 : Boolean := Boolean'First;
      --  If true all line numbers are 1-based (default).
columnsStartAt1 : Boolean := Boolean'First;
      --  If true all column numbers are 1-based (default).
pathFormat : Enum.Optional_InitializeRequestArguments_pathFormat;
      --  Determines in what format paths are specified. The default is `path`, which is the native format.
supportsVariableType : Boolean := Boolean'First;
      --  Client supports the `type` attribute for variables.
supportsVariablePaging : Boolean := Boolean'First;
      --  Client supports the paging of variables.
supportsRunInTerminalRequest : Boolean := Boolean'First;
      --  Client supports the `runInTerminal` request.
supportsMemoryReferences : Boolean := Boolean'First;
      --  Client supports memory references.
supportsProgressReporting : Boolean := Boolean'First;
      --  Client supports progress reporting.
supportsInvalidatedEvent : Boolean := Boolean'First;
      --  Client supports the `invalidated` event.
supportsMemoryEvent : Boolean := Boolean'First;
      --  Client supports the `memory` event.
supportsArgsCanBeInterpretedByShell : Boolean := Boolean'First;
      --  Client supports the `argsCanBeInterpretedByShell` attribute on the `runInTerminal` request.
supportsStartDebuggingRequest : Boolean := Boolean'First;
      --  Client supports the `startDebugging` request.
end record;

type InitializeRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : InitializeRequestArguments;
end record;

type BreakpointLocationsResponse_body is record
breakpoints : BreakpointLocation_Vector;
      --  Sorted set of possible breakpoint locations.
end record;

type Optional_BreakpointLocationsResponse_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : BreakpointLocationsResponse_body;
when False => null;
end case; end record;

type BreakpointLocationsResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : BreakpointLocationsResponse_body;
end record;

type DisassembledInstruction is record
address : VSS.Strings.Virtual_String;
      --  The address of the instruction. Treated as a hex value if prefixed with `0x`, or as a decimal value otherwise.
instructionBytes : VSS.Strings.Virtual_String;
      --  Raw bytes representing the instruction and its operands, in an implementation-defined format.
instruction : VSS.Strings.Virtual_String;
      --  Text representing the instruction and its operands, in an implementation-defined format.
symbol : VSS.Strings.Virtual_String;
      --  Name of the symbol that corresponds with the location of this instruction, if any.
location : Optional_Source;
      --  Source location that corresponds to this instruction, if any.
      --  Should always be set (if available) on the first instruction returned,
      --  but can be omitted afterwards if this instruction maps to the same source file as the previous instruction.
line : Optional_Integer;
      --  The line within the source location that corresponds to this instruction, if any.
column : Optional_Integer;
      --  The column within the line that corresponds to this instruction, if any.
endLine : Optional_Integer;
      --  The end line of the range that corresponds to this instruction, if any.
endColumn : Optional_Integer;
      --  The end column of the range that corresponds to this instruction, if any.
end record;

type CancelResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : Any_Value;
      --  Contains request result if success is true and error details if success is false.
end record;

type SetInstructionBreakpointsResponse_body is record
breakpoints : Breakpoint_Vector;
      --  Information about the breakpoints. The array elements correspond to the elements of the `breakpoints` array.
end record;

type Optional_SetInstructionBreakpointsResponse_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : SetInstructionBreakpointsResponse_body;
when False => null;
end case; end record;

type SetInstructionBreakpointsResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : SetInstructionBreakpointsResponse_body;
end record;

type CancelRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : Optional_CancelArguments;
end record;

type ProgressEndEvent_body is record
progressId : VSS.Strings.Virtual_String;
      --  The ID that was introduced in the initial `ProgressStartEvent`.
message : VSS.Strings.Virtual_String;
      --  More detailed progress message. If omitted, the previous message (if any) is used.
end record;

type Optional_ProgressEndEvent_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : ProgressEndEvent_body;
when False => null;
end case; end record;

type ProgressEndEvent is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
a_body : ProgressEndEvent_body;
end record;

type VariablesRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : VariablesArguments;
end record;

type ExceptionOptions is record
path : ExceptionPathSegment_Vector;
      --  A path that selects a single or multiple exceptions in a tree. If `path` is missing, the whole tree is selected.
      --  By convention the first segment of the path is a category that is used to group exceptions in the UI.
breakMode : Enum.ExceptionBreakMode;
      --  Condition when a thrown exception should result in a break.
end record;

type TerminatedEvent_body is record
restart : Any_Value;
      --  A debug adapter may set `restart` to true (or to an arbitrary object) to request that the client restarts the session.
      --  The value is not interpreted by the client and passed unmodified as an attribute `__restart` to the `launch` and `attach` requests.
end record;

type Optional_TerminatedEvent_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : TerminatedEvent_body;
when False => null;
end case; end record;

type TerminatedEvent is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
a_body : Optional_TerminatedEvent_body;
end record;

type StartDebuggingRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : StartDebuggingRequestArguments;
end record;

type ThreadEvent_body is record
reason : Enum.ThreadEvent_reason;
      --  The reason for the event.
threadId : Integer;
      --  The identifier of the thread.
end record;

type Optional_ThreadEvent_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : ThreadEvent_body;
when False => null;
end case; end record;

type ThreadEvent is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
a_body : ThreadEvent_body;
end record;

type GotoTargetsResponse_body is record
targets : GotoTarget_Vector;
      --  The possible goto targets of the specified location.
end record;

type Optional_GotoTargetsResponse_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : GotoTargetsResponse_body;
when False => null;
end case; end record;

type GotoTargetsResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : GotoTargetsResponse_body;
end record;

type CompletionItem is record
label : VSS.Strings.Virtual_String;
      --  The label of this completion item. By default this is also the text that is inserted when selecting this completion.
text : VSS.Strings.Virtual_String;
      --  If text is returned and not an empty string, then it is inserted instead of the label.
sortText : VSS.Strings.Virtual_String;
      --  A string that should be used when comparing this item with other items. If not returned or an empty string, the `label` is used instead.
detail : VSS.Strings.Virtual_String;
      --  A human-readable string with additional information about this item, like type or symbol information.
a_type : Enum.Optional_CompletionItemType;
      --  The item's type. Typically the client uses this information to render the item in the UI with an icon.
start : Optional_Integer;
      --  Start position (within the `text` attribute of the `completions` request) where the completion text is added. The position is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based. If the start position is omitted the text is added at the location specified by the `column` attribute of the `completions` request.
length : Optional_Integer;
      --  Length determines how many characters are overwritten by the completion text and it is measured in UTF-16 code units. If missing the value 0 is assumed which results in the completion text being inserted.
selectionStart : Optional_Integer;
      --  Determines the start of the new selection after the text has been inserted (or replaced). `selectionStart` is measured in UTF-16 code units and must be in the range 0 and length of the completion text. If omitted the selection starts at the end of the completion text.
selectionLength : Optional_Integer;
      --  Determines the length of the new selection after the text has been inserted (or replaced) and it is measured in UTF-16 code units. The selection can not extend beyond the bounds of the completion text. If omitted the length is assumed to be 0.
end record;

type ScopesArguments is record
frameId : Integer;
      --  Retrieve the scopes for the stack frame identified by `frameId`. The `frameId` must have been obtained in the current suspended state. See 'Lifetime of Object References' in the Overview section for details.
end record;

type ErrorResponse_body is record
error : Optional_Message;
      --  A structured error message.
end record;

type Optional_ErrorResponse_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : ErrorResponse_body;
when False => null;
end case; end record;

type ErrorResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : ErrorResponse_body;
end record;

type GotoArguments is record
threadId : Integer;
      --  Set the goto target for this thread.
targetId : Integer;
      --  The location where the debuggee will continue to run.
end record;

type BreakpointEvent_body is record
reason : Enum.BreakpointEvent_reason;
      --  The reason for the event.
breakpoint : DAP.Tools.Breakpoint;
      --  The `id` attribute is used to find the target breakpoint, the other attributes are used as the new values.
end record;

type Optional_BreakpointEvent_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : BreakpointEvent_body;
when False => null;
end case; end record;

type BreakpointEvent is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
a_body : BreakpointEvent_body;
end record;

type GotoTarget is record
id : Integer;
      --  Unique identifier for a goto target. This is used in the `goto` request.
label : VSS.Strings.Virtual_String;
      --  The name of the goto target (shown in the UI).
line : Integer;
      --  The line of the goto target.
column : Optional_Integer;
      --  The column of the goto target.
endLine : Optional_Integer;
      --  The end line of the range covered by the goto target.
endColumn : Optional_Integer;
      --  The end column of the range covered by the goto target.
instructionPointerReference : VSS.Strings.Virtual_String;
      --  A memory reference for the instruction pointer value represented by this target.
end record;

type ReadMemoryRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : ReadMemoryArguments;
end record;

type ModulesArguments is record
startModule : Optional_Integer;
      --  The index of the first module to return; if omitted modules start at 0.
moduleCount : Optional_Integer;
      --  The number of modules to return. If `moduleCount` is not specified or 0, all modules are returned.
end record;

type NextRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : NextArguments;
end record;

type ProgressStartEvent_body is record
progressId : VSS.Strings.Virtual_String;
      --  An ID that can be used in subsequent `progressUpdate` and `progressEnd` events to make them refer to the same progress reporting.
      --  IDs must be unique within a debug session.
title : VSS.Strings.Virtual_String;
      --  Short title of the progress reporting. Shown in the UI to describe the long running operation.
requestId : Optional_Integer;
      --  The request ID that this progress report is related to. If specified a debug adapter is expected to emit progress events for the long running request until the request has been either completed or cancelled.
      --  If the request ID is omitted, the progress report is assumed to be related to some general activity of the debug adapter.
cancellable : Boolean := Boolean'First;
      --  If true, the request that reports progress may be cancelled with a `cancel` request.
      --  So this property basically controls whether the client should use UX that supports cancellation.
      --  Clients that don't support cancellation are allowed to ignore the setting.
message : VSS.Strings.Virtual_String;
      --  More detailed progress message.
percentage : Optional_Float;
      --  Progress percentage to display (value range: 0 to 100). If omitted no percentage is shown.
end record;

type Optional_ProgressStartEvent_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : ProgressStartEvent_body;
when False => null;
end case; end record;

type ProgressStartEvent is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
a_body : ProgressStartEvent_body;
end record;

type SetVariableResponse_body is record
value : VSS.Strings.Virtual_String;
      --  The new value of the variable.
a_type : VSS.Strings.Virtual_String;
      --  The type of the new value. Typically shown in the UI when hovering over the value.
variablesReference : Optional_Integer;
      --  If `variablesReference` is > 0, the new value is structured and its children can be retrieved by passing `variablesReference` to the `variables` request as long as execution remains suspended. See 'Lifetime of Object References' in the Overview section for details.
namedVariables : Optional_Integer;
      --  The number of named child variables.
      --  The client can use this information to present the variables in a paged UI and fetch them in chunks.
      --  The value should be less than or equal to 2147483647 (2^31-1).
indexedVariables : Optional_Integer;
      --  The number of indexed child variables.
      --  The client can use this information to present the variables in a paged UI and fetch them in chunks.
      --  The value should be less than or equal to 2147483647 (2^31-1).
end record;

type Optional_SetVariableResponse_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : SetVariableResponse_body;
when False => null;
end case; end record;

type SetVariableResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : SetVariableResponse_body;
end record;

type BreakpointLocation is record
line : Integer;
      --  Start line of breakpoint location.
column : Optional_Integer;
      --  The start position of a breakpoint location. Position is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based.
endLine : Optional_Integer;
      --  The end line of breakpoint location if the location covers a range.
endColumn : Optional_Integer;
      --  The end position of a breakpoint location (if the location covers a range). Position is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based.
end record;

type DisconnectResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : Any_Value;
      --  Contains request result if success is true and error details if success is false.
end record;

type SetExceptionBreakpointsRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : SetExceptionBreakpointsArguments;
end record;

type WriteMemoryRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : WriteMemoryArguments;
end record;

type InitializeResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : Optional_Capabilities;
      --  The capabilities of this debug adapter.
end record;

type ConfigurationDoneResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : Any_Value;
      --  Contains request result if success is true and error details if success is false.
end record;

type GotoRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : GotoArguments;
end record;

type SetFunctionBreakpointsResponse_body is record
breakpoints : Breakpoint_Vector;
      --  Information about the breakpoints. The array elements correspond to the elements of the `breakpoints` array.
end record;

type Optional_SetFunctionBreakpointsResponse_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : SetFunctionBreakpointsResponse_body;
when False => null;
end case; end record;

type SetFunctionBreakpointsResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : SetFunctionBreakpointsResponse_body;
end record;

type StackTraceRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : StackTraceArguments;
end record;

type EvaluateResponse_body is record
result : VSS.Strings.Virtual_String;
      --  The result of the evaluate request.
a_type : VSS.Strings.Virtual_String;
      --  The type of the evaluate result.
      --  This attribute should only be returned by a debug adapter if the corresponding capability `supportsVariableType` is true.
presentationHint : Optional_VariablePresentationHint;
      --  Properties of an evaluate result that can be used to determine how to render the result in the UI.
variablesReference : Integer;
      --  If `variablesReference` is > 0, the evaluate result is structured and its children can be retrieved by passing `variablesReference` to the `variables` request as long as execution remains suspended. See 'Lifetime of Object References' in the Overview section for details.
namedVariables : Optional_Integer;
      --  The number of named child variables.
      --  The client can use this information to present the variables in a paged UI and fetch them in chunks.
      --  The value should be less than or equal to 2147483647 (2^31-1).
indexedVariables : Optional_Integer;
      --  The number of indexed child variables.
      --  The client can use this information to present the variables in a paged UI and fetch them in chunks.
      --  The value should be less than or equal to 2147483647 (2^31-1).
memoryReference : VSS.Strings.Virtual_String;
      --  A memory reference to a location appropriate for this result.
      --  For pointer type eval results, this is generally a reference to the memory address contained in the pointer.
      --  This attribute should be returned by a debug adapter if corresponding capability `supportsMemoryReferences` is true.
end record;

type Optional_EvaluateResponse_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : EvaluateResponse_body;
when False => null;
end case; end record;

type EvaluateResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : EvaluateResponse_body;
end record;

type ReverseContinueRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : ReverseContinueArguments;
end record;

type ModulesRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : ModulesArguments;
end record;

type SetBreakpointsResponse_body is record
breakpoints : Breakpoint_Vector;
      --  Information about the breakpoints.
      --  The array elements are in the same order as the elements of the `breakpoints` (or the deprecated `lines`) array in the arguments.
end record;

type Optional_SetBreakpointsResponse_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : SetBreakpointsResponse_body;
when False => null;
end case; end record;

type SetBreakpointsResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : SetBreakpointsResponse_body;
end record;

type InstructionBreakpoint is record
instructionReference : VSS.Strings.Virtual_String;
      --  The instruction reference of the breakpoint.
      --  This should be a memory or instruction pointer reference from an `EvaluateResponse`, `Variable`, `StackFrame`, `GotoTarget`, or `Breakpoint`.
offset : Optional_Integer;
      --  The offset from the instruction reference.
      --  This can be negative.
condition : VSS.Strings.Virtual_String;
      --  An expression for conditional breakpoints.
      --  It is only honored by a debug adapter if the corresponding capability `supportsConditionalBreakpoints` is true.
hitCondition : VSS.Strings.Virtual_String;
      --  An expression that controls how many hits of the breakpoint are ignored.
      --  The debug adapter is expected to interpret the expression as needed.
      --  The attribute is only honored by a debug adapter if the corresponding capability `supportsHitConditionalBreakpoints` is true.
end record;

type DisconnectRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : Optional_DisconnectArguments;
end record;

type TerminateThreadsResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : Any_Value;
      --  Contains request result if success is true and error details if success is false.
end record;

type ScopesRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : ScopesArguments;
end record;

type SetExceptionBreakpointsResponse_body is record
breakpoints : Breakpoint_Vector;
      --  Information about the exception breakpoints or filters.
      --  The breakpoints returned are in the same order as the elements of the `filters`, `filterOptions`, `exceptionOptions` arrays in the arguments. If both `filters` and `filterOptions` are given, the returned array must start with `filters` information first, followed by `filterOptions` information.
end record;

type Optional_SetExceptionBreakpointsResponse_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : SetExceptionBreakpointsResponse_body;
when False => null;
end case; end record;

type SetExceptionBreakpointsResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : Optional_SetExceptionBreakpointsResponse_body;
end record;

type StepBackResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : Any_Value;
      --  Contains request result if success is true and error details if success is false.
end record;

type DisassembleResponse_body is record
instructions : DisassembledInstruction_Vector;
      --  The list of disassembled instructions.
end record;

type Optional_DisassembleResponse_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : DisassembleResponse_body;
when False => null;
end case; end record;

type DisassembleResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : Optional_DisassembleResponse_body;
end record;

type InvalidatedEvent_body is record
areas : InvalidatedAreas_Vector;
      --  Set of logical areas that got invalidated. This property has a hint characteristic: a client can only be expected to make a 'best effort' in honoring the areas but there are no guarantees. If this property is missing, empty, or if values are not understood, the client should assume a single value `all`.
threadId : Optional_Integer;
      --  If specified, the client only needs to refetch data related to this thread.
stackFrameId : Optional_Integer;
      --  If specified, the client only needs to refetch data related to this stack frame (and the `threadId` is ignored).
end record;

type Optional_InvalidatedEvent_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : InvalidatedEvent_body;
when False => null;
end case; end record;

type InvalidatedEvent is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
a_body : InvalidatedEvent_body;
end record;

type StepInRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : StepInArguments;
end record;

type ContinueRequest is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
arguments : ContinueArguments;
end record;

type LoadedSourcesResponse_body is record
sources : Source_Vector;
      --  Set of loaded sources.
end record;

type Optional_LoadedSourcesResponse_body (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : LoadedSourcesResponse_body;
when False => null;
end case; end record;

type LoadedSourcesResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : LoadedSourcesResponse_body;
end record;

type StartDebuggingResponse is record
seq : Integer;
      --  Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
request_seq : Integer;
      --  Sequence number of the corresponding request.
success : Boolean;
      --  Outcome of the request.
      --  If true, the request was successful and the `body` attribute may contain the result of the request.
      --  If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
command : VSS.Strings.Virtual_String;
      --  The command requested.
message : Enum.Optional_Response_message;
      --  Contains the raw error in short form if `success` is false.
      --  This raw error might be interpreted by the client and is not shown in the UI.
      --  Some predefined values exist.
a_body : Any_Value;
      --  Contains request result if success is true and error details if success is false.
end record;

function Length (Self : Thread_Vector) return Natural;

procedure Clear (Self : in out Thread_Vector);

procedure Append
(Self : in out Thread_Vector;
Value : Thread);

type Thread_Variable_Reference
(Element : not null access Thread) is null record
with Implicit_Dereference => Element;

not overriding function Get_Thread_Variable_Reference
(Self : aliased in out Thread_Vector;
Index : Positive)
return Thread_Variable_Reference
with Inline;

type Thread_Constant_Reference
(Element : not null access constant Thread) is null record
with Implicit_Dereference => Element;

not overriding function Get_Thread_Constant_Reference
(Self : aliased Thread_Vector;
Index : Positive)
return Thread_Constant_Reference
with Inline;

function Length (Self : Checksum_Vector) return Natural;

procedure Clear (Self : in out Checksum_Vector);

procedure Append
(Self : in out Checksum_Vector;
Value : Checksum);

type Checksum_Variable_Reference
(Element : not null access Checksum) is null record
with Implicit_Dereference => Element;

not overriding function Get_Checksum_Variable_Reference
(Self : aliased in out Checksum_Vector;
Index : Positive)
return Checksum_Variable_Reference
with Inline;

type Checksum_Constant_Reference
(Element : not null access constant Checksum) is null record
with Implicit_Dereference => Element;

not overriding function Get_Checksum_Constant_Reference
(Self : aliased Checksum_Vector;
Index : Positive)
return Checksum_Constant_Reference
with Inline;

function Length (Self : Breakpoint_Vector) return Natural;

procedure Clear (Self : in out Breakpoint_Vector);

procedure Append
(Self : in out Breakpoint_Vector;
Value : Breakpoint);

type Breakpoint_Variable_Reference
(Element : not null access Breakpoint) is null record
with Implicit_Dereference => Element;

not overriding function Get_Breakpoint_Variable_Reference
(Self : aliased in out Breakpoint_Vector;
Index : Positive)
return Breakpoint_Variable_Reference
with Inline;

type Breakpoint_Constant_Reference
(Element : not null access constant Breakpoint) is null record
with Implicit_Dereference => Element;

not overriding function Get_Breakpoint_Constant_Reference
(Self : aliased Breakpoint_Vector;
Index : Positive)
return Breakpoint_Constant_Reference
with Inline;

function Length (Self : StepInTarget_Vector) return Natural;

procedure Clear (Self : in out StepInTarget_Vector);

procedure Append
(Self : in out StepInTarget_Vector;
Value : StepInTarget);

type StepInTarget_Variable_Reference
(Element : not null access StepInTarget) is null record
with Implicit_Dereference => Element;

not overriding function Get_StepInTarget_Variable_Reference
(Self : aliased in out StepInTarget_Vector;
Index : Positive)
return StepInTarget_Variable_Reference
with Inline;

type StepInTarget_Constant_Reference
(Element : not null access constant StepInTarget) is null record
with Implicit_Dereference => Element;

not overriding function Get_StepInTarget_Constant_Reference
(Self : aliased StepInTarget_Vector;
Index : Positive)
return StepInTarget_Constant_Reference
with Inline;

function Length (Self : FunctionBreakpoint_Vector) return Natural;

procedure Clear (Self : in out FunctionBreakpoint_Vector);

procedure Append
(Self : in out FunctionBreakpoint_Vector;
Value : FunctionBreakpoint);

type FunctionBreakpoint_Variable_Reference
(Element : not null access FunctionBreakpoint) is null record
with Implicit_Dereference => Element;

not overriding function Get_FunctionBreakpoint_Variable_Reference
(Self : aliased in out FunctionBreakpoint_Vector;
Index : Positive)
return FunctionBreakpoint_Variable_Reference
with Inline;

type FunctionBreakpoint_Constant_Reference
(Element : not null access constant FunctionBreakpoint) is null record
with Implicit_Dereference => Element;

not overriding function Get_FunctionBreakpoint_Constant_Reference
(Self : aliased FunctionBreakpoint_Vector;
Index : Positive)
return FunctionBreakpoint_Constant_Reference
with Inline;

function Length (Self : DataBreakpoint_Vector) return Natural;

procedure Clear (Self : in out DataBreakpoint_Vector);

procedure Append
(Self : in out DataBreakpoint_Vector;
Value : DataBreakpoint);

type DataBreakpoint_Variable_Reference
(Element : not null access DataBreakpoint) is null record
with Implicit_Dereference => Element;

not overriding function Get_DataBreakpoint_Variable_Reference
(Self : aliased in out DataBreakpoint_Vector;
Index : Positive)
return DataBreakpoint_Variable_Reference
with Inline;

type DataBreakpoint_Constant_Reference
(Element : not null access constant DataBreakpoint) is null record
with Implicit_Dereference => Element;

not overriding function Get_DataBreakpoint_Constant_Reference
(Self : aliased DataBreakpoint_Vector;
Index : Positive)
return DataBreakpoint_Constant_Reference
with Inline;

function Length (Self : ExceptionOptions_Vector) return Natural;

procedure Clear (Self : in out ExceptionOptions_Vector);

procedure Append
(Self : in out ExceptionOptions_Vector;
Value : ExceptionOptions);

type ExceptionOptions_Variable_Reference
(Element : not null access ExceptionOptions) is null record
with Implicit_Dereference => Element;

not overriding function Get_ExceptionOptions_Variable_Reference
(Self : aliased in out ExceptionOptions_Vector;
Index : Positive)
return ExceptionOptions_Variable_Reference
with Inline;

type ExceptionOptions_Constant_Reference
(Element : not null access constant ExceptionOptions) is null record
with Implicit_Dereference => Element;

not overriding function Get_ExceptionOptions_Constant_Reference
(Self : aliased ExceptionOptions_Vector;
Index : Positive)
return ExceptionOptions_Constant_Reference
with Inline;

function Length (Self : Integer_Vector) return Natural;

procedure Clear (Self : in out Integer_Vector);

procedure Append
(Self : in out Integer_Vector;
Value : Integer);

type Integer_Variable_Reference
(Element : not null access Integer) is null record
with Implicit_Dereference => Element;

not overriding function Get_Integer_Variable_Reference
(Self : aliased in out Integer_Vector;
Index : Positive)
return Integer_Variable_Reference
with Inline;

type Integer_Constant_Reference
(Element : not null access constant Integer) is null record
with Implicit_Dereference => Element;

not overriding function Get_Integer_Constant_Reference
(Self : aliased Integer_Vector;
Index : Positive)
return Integer_Constant_Reference
with Inline;

function Length (Self : GotoTarget_Vector) return Natural;

procedure Clear (Self : in out GotoTarget_Vector);

procedure Append
(Self : in out GotoTarget_Vector;
Value : GotoTarget);

type GotoTarget_Variable_Reference
(Element : not null access GotoTarget) is null record
with Implicit_Dereference => Element;

not overriding function Get_GotoTarget_Variable_Reference
(Self : aliased in out GotoTarget_Vector;
Index : Positive)
return GotoTarget_Variable_Reference
with Inline;

type GotoTarget_Constant_Reference
(Element : not null access constant GotoTarget) is null record
with Implicit_Dereference => Element;

not overriding function Get_GotoTarget_Constant_Reference
(Self : aliased GotoTarget_Vector;
Index : Positive)
return GotoTarget_Constant_Reference
with Inline;

function Length (Self : InvalidatedAreas_Vector) return Natural;

procedure Clear (Self : in out InvalidatedAreas_Vector);

procedure Append
(Self : in out InvalidatedAreas_Vector;
Value : Enum.InvalidatedAreas);

type InvalidatedAreas_Variable_Reference
(Element : not null access Enum.InvalidatedAreas) is null record
with Implicit_Dereference => Element;

not overriding function Get_InvalidatedAreas_Variable_Reference
(Self : aliased in out InvalidatedAreas_Vector;
Index : Positive)
return InvalidatedAreas_Variable_Reference
with Inline;

type InvalidatedAreas_Constant_Reference
(Element : not null access constant Enum.InvalidatedAreas) is null record
with Implicit_Dereference => Element;

not overriding function Get_InvalidatedAreas_Constant_Reference
(Self : aliased InvalidatedAreas_Vector;
Index : Positive)
return InvalidatedAreas_Constant_Reference
with Inline;

function Length (Self : BreakpointLocation_Vector) return Natural;

procedure Clear (Self : in out BreakpointLocation_Vector);

procedure Append
(Self : in out BreakpointLocation_Vector;
Value : BreakpointLocation);

type BreakpointLocation_Variable_Reference
(Element : not null access BreakpointLocation) is null record
with Implicit_Dereference => Element;

not overriding function Get_BreakpointLocation_Variable_Reference
(Self : aliased in out BreakpointLocation_Vector;
Index : Positive)
return BreakpointLocation_Variable_Reference
with Inline;

type BreakpointLocation_Constant_Reference
(Element : not null access constant BreakpointLocation) is null record
with Implicit_Dereference => Element;

not overriding function Get_BreakpointLocation_Constant_Reference
(Self : aliased BreakpointLocation_Vector;
Index : Positive)
return BreakpointLocation_Constant_Reference
with Inline;

function Length (Self : InstructionBreakpoint_Vector) return Natural;

procedure Clear (Self : in out InstructionBreakpoint_Vector);

procedure Append
(Self : in out InstructionBreakpoint_Vector;
Value : InstructionBreakpoint);

type InstructionBreakpoint_Variable_Reference
(Element : not null access InstructionBreakpoint) is null record
with Implicit_Dereference => Element;

not overriding function Get_InstructionBreakpoint_Variable_Reference
(Self : aliased in out InstructionBreakpoint_Vector;
Index : Positive)
return InstructionBreakpoint_Variable_Reference
with Inline;

type InstructionBreakpoint_Constant_Reference
(Element : not null access constant InstructionBreakpoint) is null record
with Implicit_Dereference => Element;

not overriding function Get_InstructionBreakpoint_Constant_Reference
(Self : aliased InstructionBreakpoint_Vector;
Index : Positive)
return InstructionBreakpoint_Constant_Reference
with Inline;

function Length (Self : StackFrame_Vector) return Natural;

procedure Clear (Self : in out StackFrame_Vector);

procedure Append
(Self : in out StackFrame_Vector;
Value : StackFrame);

type StackFrame_Variable_Reference
(Element : not null access StackFrame) is null record
with Implicit_Dereference => Element;

not overriding function Get_StackFrame_Variable_Reference
(Self : aliased in out StackFrame_Vector;
Index : Positive)
return StackFrame_Variable_Reference
with Inline;

type StackFrame_Constant_Reference
(Element : not null access constant StackFrame) is null record
with Implicit_Dereference => Element;

not overriding function Get_StackFrame_Constant_Reference
(Self : aliased StackFrame_Vector;
Index : Positive)
return StackFrame_Constant_Reference
with Inline;

function Length (Self : Scope_Vector) return Natural;

procedure Clear (Self : in out Scope_Vector);

procedure Append
(Self : in out Scope_Vector;
Value : Scope);

type Scope_Variable_Reference
(Element : not null access Scope) is null record
with Implicit_Dereference => Element;

not overriding function Get_Scope_Variable_Reference
(Self : aliased in out Scope_Vector;
Index : Positive)
return Scope_Variable_Reference
with Inline;

type Scope_Constant_Reference
(Element : not null access constant Scope) is null record
with Implicit_Dereference => Element;

not overriding function Get_Scope_Constant_Reference
(Self : aliased Scope_Vector;
Index : Positive)
return Scope_Constant_Reference
with Inline;

function Length (Self : Variable_Vector) return Natural;

procedure Clear (Self : in out Variable_Vector);

procedure Append
(Self : in out Variable_Vector;
Value : Variable);

type Variable_Variable_Reference
(Element : not null access Variable) is null record
with Implicit_Dereference => Element;

not overriding function Get_Variable_Variable_Reference
(Self : aliased in out Variable_Vector;
Index : Positive)
return Variable_Variable_Reference
with Inline;

type Variable_Constant_Reference
(Element : not null access constant Variable) is null record
with Implicit_Dereference => Element;

not overriding function Get_Variable_Constant_Reference
(Self : aliased Variable_Vector;
Index : Positive)
return Variable_Constant_Reference
with Inline;

function Length (Self : Source_Vector) return Natural;

procedure Clear (Self : in out Source_Vector);

procedure Append
(Self : in out Source_Vector;
Value : Source);

type Source_Variable_Reference
(Element : not null access Source) is null record
with Implicit_Dereference => Element;

not overriding function Get_Source_Variable_Reference
(Self : aliased in out Source_Vector;
Index : Positive)
return Source_Variable_Reference
with Inline;

type Source_Constant_Reference
(Element : not null access constant Source) is null record
with Implicit_Dereference => Element;

not overriding function Get_Source_Constant_Reference
(Self : aliased Source_Vector;
Index : Positive)
return Source_Constant_Reference
with Inline;

function Length (Self : VariablePresentationHint_attributes_Vector) return Natural;

procedure Clear (Self : in out VariablePresentationHint_attributes_Vector);

procedure Append
(Self : in out VariablePresentationHint_attributes_Vector;
Value : Enum.VariablePresentationHint_attributes);

type VariablePresentationHint_attributes_Variable_Reference
(Element : not null access Enum.VariablePresentationHint_attributes) is null record
with Implicit_Dereference => Element;

not overriding function Get_VariablePresentationHint_attributes_Variable_Reference
(Self : aliased in out VariablePresentationHint_attributes_Vector;
Index : Positive)
return VariablePresentationHint_attributes_Variable_Reference
with Inline;

type VariablePresentationHint_attributes_Constant_Reference
(Element : not null access constant Enum.VariablePresentationHint_attributes) is null record
with Implicit_Dereference => Element;

not overriding function Get_VariablePresentationHint_attributes_Constant_Reference
(Self : aliased VariablePresentationHint_attributes_Vector;
Index : Positive)
return VariablePresentationHint_attributes_Constant_Reference
with Inline;

function Length (Self : SourceBreakpoint_Vector) return Natural;

procedure Clear (Self : in out SourceBreakpoint_Vector);

procedure Append
(Self : in out SourceBreakpoint_Vector;
Value : SourceBreakpoint);

type SourceBreakpoint_Variable_Reference
(Element : not null access SourceBreakpoint) is null record
with Implicit_Dereference => Element;

not overriding function Get_SourceBreakpoint_Variable_Reference
(Self : aliased in out SourceBreakpoint_Vector;
Index : Positive)
return SourceBreakpoint_Variable_Reference
with Inline;

type SourceBreakpoint_Constant_Reference
(Element : not null access constant SourceBreakpoint) is null record
with Implicit_Dereference => Element;

not overriding function Get_SourceBreakpoint_Constant_Reference
(Self : aliased SourceBreakpoint_Vector;
Index : Positive)
return SourceBreakpoint_Constant_Reference
with Inline;

function Length (Self : ChecksumAlgorithm_Vector) return Natural;

procedure Clear (Self : in out ChecksumAlgorithm_Vector);

procedure Append
(Self : in out ChecksumAlgorithm_Vector;
Value : Enum.ChecksumAlgorithm);

type ChecksumAlgorithm_Variable_Reference
(Element : not null access Enum.ChecksumAlgorithm) is null record
with Implicit_Dereference => Element;

not overriding function Get_ChecksumAlgorithm_Variable_Reference
(Self : aliased in out ChecksumAlgorithm_Vector;
Index : Positive)
return ChecksumAlgorithm_Variable_Reference
with Inline;

type ChecksumAlgorithm_Constant_Reference
(Element : not null access constant Enum.ChecksumAlgorithm) is null record
with Implicit_Dereference => Element;

not overriding function Get_ChecksumAlgorithm_Constant_Reference
(Self : aliased ChecksumAlgorithm_Vector;
Index : Positive)
return ChecksumAlgorithm_Constant_Reference
with Inline;

function Length (Self : ExceptionBreakpointsFilter_Vector) return Natural;

procedure Clear (Self : in out ExceptionBreakpointsFilter_Vector);

procedure Append
(Self : in out ExceptionBreakpointsFilter_Vector;
Value : ExceptionBreakpointsFilter);

type ExceptionBreakpointsFilter_Variable_Reference
(Element : not null access ExceptionBreakpointsFilter) is null record
with Implicit_Dereference => Element;

not overriding function Get_ExceptionBreakpointsFilter_Variable_Reference
(Self : aliased in out ExceptionBreakpointsFilter_Vector;
Index : Positive)
return ExceptionBreakpointsFilter_Variable_Reference
with Inline;

type ExceptionBreakpointsFilter_Constant_Reference
(Element : not null access constant ExceptionBreakpointsFilter) is null record
with Implicit_Dereference => Element;

not overriding function Get_ExceptionBreakpointsFilter_Constant_Reference
(Self : aliased ExceptionBreakpointsFilter_Vector;
Index : Positive)
return ExceptionBreakpointsFilter_Constant_Reference
with Inline;

function Length (Self : CompletionItem_Vector) return Natural;

procedure Clear (Self : in out CompletionItem_Vector);

procedure Append
(Self : in out CompletionItem_Vector;
Value : CompletionItem);

type CompletionItem_Variable_Reference
(Element : not null access CompletionItem) is null record
with Implicit_Dereference => Element;

not overriding function Get_CompletionItem_Variable_Reference
(Self : aliased in out CompletionItem_Vector;
Index : Positive)
return CompletionItem_Variable_Reference
with Inline;

type CompletionItem_Constant_Reference
(Element : not null access constant CompletionItem) is null record
with Implicit_Dereference => Element;

not overriding function Get_CompletionItem_Constant_Reference
(Self : aliased CompletionItem_Vector;
Index : Positive)
return CompletionItem_Constant_Reference
with Inline;

function Length (Self : ExceptionPathSegment_Vector) return Natural;

procedure Clear (Self : in out ExceptionPathSegment_Vector);

procedure Append
(Self : in out ExceptionPathSegment_Vector;
Value : ExceptionPathSegment);

type ExceptionPathSegment_Variable_Reference
(Element : not null access ExceptionPathSegment) is null record
with Implicit_Dereference => Element;

not overriding function Get_ExceptionPathSegment_Variable_Reference
(Self : aliased in out ExceptionPathSegment_Vector;
Index : Positive)
return ExceptionPathSegment_Variable_Reference
with Inline;

type ExceptionPathSegment_Constant_Reference
(Element : not null access constant ExceptionPathSegment) is null record
with Implicit_Dereference => Element;

not overriding function Get_ExceptionPathSegment_Constant_Reference
(Self : aliased ExceptionPathSegment_Vector;
Index : Positive)
return ExceptionPathSegment_Constant_Reference
with Inline;

function Length (Self : DataBreakpointAccessType_Vector) return Natural;

procedure Clear (Self : in out DataBreakpointAccessType_Vector);

procedure Append
(Self : in out DataBreakpointAccessType_Vector;
Value : Enum.DataBreakpointAccessType);

type DataBreakpointAccessType_Variable_Reference
(Element : not null access Enum.DataBreakpointAccessType) is null record
with Implicit_Dereference => Element;

not overriding function Get_DataBreakpointAccessType_Variable_Reference
(Self : aliased in out DataBreakpointAccessType_Vector;
Index : Positive)
return DataBreakpointAccessType_Variable_Reference
with Inline;

type DataBreakpointAccessType_Constant_Reference
(Element : not null access constant Enum.DataBreakpointAccessType) is null record
with Implicit_Dereference => Element;

not overriding function Get_DataBreakpointAccessType_Constant_Reference
(Self : aliased DataBreakpointAccessType_Vector;
Index : Positive)
return DataBreakpointAccessType_Constant_Reference
with Inline;

function Length (Self : DisassembledInstruction_Vector) return Natural;

procedure Clear (Self : in out DisassembledInstruction_Vector);

procedure Append
(Self : in out DisassembledInstruction_Vector;
Value : DisassembledInstruction);

type DisassembledInstruction_Variable_Reference
(Element : not null access DisassembledInstruction) is null record
with Implicit_Dereference => Element;

not overriding function Get_DisassembledInstruction_Variable_Reference
(Self : aliased in out DisassembledInstruction_Vector;
Index : Positive)
return DisassembledInstruction_Variable_Reference
with Inline;

type DisassembledInstruction_Constant_Reference
(Element : not null access constant DisassembledInstruction) is null record
with Implicit_Dereference => Element;

not overriding function Get_DisassembledInstruction_Constant_Reference
(Self : aliased DisassembledInstruction_Vector;
Index : Positive)
return DisassembledInstruction_Constant_Reference
with Inline;

function Length (Self : Module_Vector) return Natural;

procedure Clear (Self : in out Module_Vector);

procedure Append
(Self : in out Module_Vector;
Value : Module);

type Module_Variable_Reference
(Element : not null access Module) is null record
with Implicit_Dereference => Element;

not overriding function Get_Module_Variable_Reference
(Self : aliased in out Module_Vector;
Index : Positive)
return Module_Variable_Reference
with Inline;

type Module_Constant_Reference
(Element : not null access constant Module) is null record
with Implicit_Dereference => Element;

not overriding function Get_Module_Constant_Reference
(Self : aliased Module_Vector;
Index : Positive)
return Module_Constant_Reference
with Inline;

function Length (Self : ExceptionFilterOptions_Vector) return Natural;

procedure Clear (Self : in out ExceptionFilterOptions_Vector);

procedure Append
(Self : in out ExceptionFilterOptions_Vector;
Value : ExceptionFilterOptions);

type ExceptionFilterOptions_Variable_Reference
(Element : not null access ExceptionFilterOptions) is null record
with Implicit_Dereference => Element;

not overriding function Get_ExceptionFilterOptions_Variable_Reference
(Self : aliased in out ExceptionFilterOptions_Vector;
Index : Positive)
return ExceptionFilterOptions_Variable_Reference
with Inline;

type ExceptionFilterOptions_Constant_Reference
(Element : not null access constant ExceptionFilterOptions) is null record
with Implicit_Dereference => Element;

not overriding function Get_ExceptionFilterOptions_Constant_Reference
(Self : aliased ExceptionFilterOptions_Vector;
Index : Positive)
return ExceptionFilterOptions_Constant_Reference
with Inline;

function Length (Self : ColumnDescriptor_Vector) return Natural;

procedure Clear (Self : in out ColumnDescriptor_Vector);

procedure Append
(Self : in out ColumnDescriptor_Vector;
Value : ColumnDescriptor);

type ColumnDescriptor_Variable_Reference
(Element : not null access ColumnDescriptor) is null record
with Implicit_Dereference => Element;

not overriding function Get_ColumnDescriptor_Variable_Reference
(Self : aliased in out ColumnDescriptor_Vector;
Index : Positive)
return ColumnDescriptor_Variable_Reference
with Inline;

type ColumnDescriptor_Constant_Reference
(Element : not null access constant ColumnDescriptor) is null record
with Implicit_Dereference => Element;

not overriding function Get_ColumnDescriptor_Constant_Reference
(Self : aliased ColumnDescriptor_Vector;
Index : Positive)
return ColumnDescriptor_Constant_Reference
with Inline;

function Length (Self : ExceptionDetails_Vector) return Natural;

procedure Clear (Self : in out ExceptionDetails_Vector);

procedure Append
(Self : in out ExceptionDetails_Vector;
Value : ExceptionDetails);

type ExceptionDetails_Variable_Reference
(Element : not null access ExceptionDetails) is null record
with Implicit_Dereference => Element;

not overriding function Get_ExceptionDetails_Variable_Reference
(Self : aliased in out ExceptionDetails_Vector;
Index : Positive)
return ExceptionDetails_Variable_Reference
with Inline;

type ExceptionDetails_Constant_Reference
(Element : not null access constant ExceptionDetails) is null record
with Implicit_Dereference => Element;

not overriding function Get_ExceptionDetails_Constant_Reference
(Self : aliased ExceptionDetails_Vector;
Index : Positive)
return ExceptionDetails_Constant_Reference
with Inline;

private
type Thread_Array is array (Positive range <>) of aliased Thread;
type Thread_Array_Access is access Thread_Array;
type Thread_Vector is new Ada.Finalization.Controlled with record
Data   : Thread_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out Thread_Vector);

overriding procedure Finalize (Self : in out Thread_Vector);

type Checksum_Array is array (Positive range <>) of aliased Checksum;
type Checksum_Array_Access is access Checksum_Array;
type Checksum_Vector is new Ada.Finalization.Controlled with record
Data   : Checksum_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out Checksum_Vector);

overriding procedure Finalize (Self : in out Checksum_Vector);

type Breakpoint_Array is array (Positive range <>) of aliased Breakpoint;
type Breakpoint_Array_Access is access Breakpoint_Array;
type Breakpoint_Vector is new Ada.Finalization.Controlled with record
Data   : Breakpoint_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out Breakpoint_Vector);

overriding procedure Finalize (Self : in out Breakpoint_Vector);

type StepInTarget_Array is array (Positive range <>) of aliased StepInTarget;
type StepInTarget_Array_Access is access StepInTarget_Array;
type StepInTarget_Vector is new Ada.Finalization.Controlled with record
Data   : StepInTarget_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out StepInTarget_Vector);

overriding procedure Finalize (Self : in out StepInTarget_Vector);

type FunctionBreakpoint_Array is array (Positive range <>) of aliased FunctionBreakpoint;
type FunctionBreakpoint_Array_Access is access FunctionBreakpoint_Array;
type FunctionBreakpoint_Vector is new Ada.Finalization.Controlled with record
Data   : FunctionBreakpoint_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out FunctionBreakpoint_Vector);

overriding procedure Finalize (Self : in out FunctionBreakpoint_Vector);

type DataBreakpoint_Array is array (Positive range <>) of aliased DataBreakpoint;
type DataBreakpoint_Array_Access is access DataBreakpoint_Array;
type DataBreakpoint_Vector is new Ada.Finalization.Controlled with record
Data   : DataBreakpoint_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out DataBreakpoint_Vector);

overriding procedure Finalize (Self : in out DataBreakpoint_Vector);

type ExceptionOptions_Array is array (Positive range <>) of aliased ExceptionOptions;
type ExceptionOptions_Array_Access is access ExceptionOptions_Array;
type ExceptionOptions_Vector is new Ada.Finalization.Controlled with record
Data   : ExceptionOptions_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out ExceptionOptions_Vector);

overriding procedure Finalize (Self : in out ExceptionOptions_Vector);

type Integer_Array is array (Positive range <>) of aliased Integer;
type Integer_Array_Access is access Integer_Array;
type Integer_Vector is new Ada.Finalization.Controlled with record
Data   : Integer_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out Integer_Vector);

overriding procedure Finalize (Self : in out Integer_Vector);

type GotoTarget_Array is array (Positive range <>) of aliased GotoTarget;
type GotoTarget_Array_Access is access GotoTarget_Array;
type GotoTarget_Vector is new Ada.Finalization.Controlled with record
Data   : GotoTarget_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out GotoTarget_Vector);

overriding procedure Finalize (Self : in out GotoTarget_Vector);

type InvalidatedAreas_Array is array (Positive range <>) of aliased Enum.InvalidatedAreas;
type InvalidatedAreas_Array_Access is access InvalidatedAreas_Array;
type InvalidatedAreas_Vector is new Ada.Finalization.Controlled with record
Data   : InvalidatedAreas_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out InvalidatedAreas_Vector);

overriding procedure Finalize (Self : in out InvalidatedAreas_Vector);

type BreakpointLocation_Array is array (Positive range <>) of aliased BreakpointLocation;
type BreakpointLocation_Array_Access is access BreakpointLocation_Array;
type BreakpointLocation_Vector is new Ada.Finalization.Controlled with record
Data   : BreakpointLocation_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out BreakpointLocation_Vector);

overriding procedure Finalize (Self : in out BreakpointLocation_Vector);

type InstructionBreakpoint_Array is array (Positive range <>) of aliased InstructionBreakpoint;
type InstructionBreakpoint_Array_Access is access InstructionBreakpoint_Array;
type InstructionBreakpoint_Vector is new Ada.Finalization.Controlled with record
Data   : InstructionBreakpoint_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out InstructionBreakpoint_Vector);

overriding procedure Finalize (Self : in out InstructionBreakpoint_Vector);

type StackFrame_Array is array (Positive range <>) of aliased StackFrame;
type StackFrame_Array_Access is access StackFrame_Array;
type StackFrame_Vector is new Ada.Finalization.Controlled with record
Data   : StackFrame_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out StackFrame_Vector);

overriding procedure Finalize (Self : in out StackFrame_Vector);

type Scope_Array is array (Positive range <>) of aliased Scope;
type Scope_Array_Access is access Scope_Array;
type Scope_Vector is new Ada.Finalization.Controlled with record
Data   : Scope_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out Scope_Vector);

overriding procedure Finalize (Self : in out Scope_Vector);

type Variable_Array is array (Positive range <>) of aliased Variable;
type Variable_Array_Access is access Variable_Array;
type Variable_Vector is new Ada.Finalization.Controlled with record
Data   : Variable_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out Variable_Vector);

overriding procedure Finalize (Self : in out Variable_Vector);

type Source_Array is array (Positive range <>) of aliased Source;
type Source_Array_Access is access Source_Array;
type Source_Vector is new Ada.Finalization.Controlled with record
Data   : Source_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out Source_Vector);

overriding procedure Finalize (Self : in out Source_Vector);

type VariablePresentationHint_attributes_Array is array (Positive range <>) of aliased Enum.VariablePresentationHint_attributes;
type VariablePresentationHint_attributes_Array_Access is access VariablePresentationHint_attributes_Array;
type VariablePresentationHint_attributes_Vector is new Ada.Finalization.Controlled with record
Data   : VariablePresentationHint_attributes_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out VariablePresentationHint_attributes_Vector);

overriding procedure Finalize (Self : in out VariablePresentationHint_attributes_Vector);

type SourceBreakpoint_Array is array (Positive range <>) of aliased SourceBreakpoint;
type SourceBreakpoint_Array_Access is access SourceBreakpoint_Array;
type SourceBreakpoint_Vector is new Ada.Finalization.Controlled with record
Data   : SourceBreakpoint_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out SourceBreakpoint_Vector);

overriding procedure Finalize (Self : in out SourceBreakpoint_Vector);

type ChecksumAlgorithm_Array is array (Positive range <>) of aliased Enum.ChecksumAlgorithm;
type ChecksumAlgorithm_Array_Access is access ChecksumAlgorithm_Array;
type ChecksumAlgorithm_Vector is new Ada.Finalization.Controlled with record
Data   : ChecksumAlgorithm_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out ChecksumAlgorithm_Vector);

overriding procedure Finalize (Self : in out ChecksumAlgorithm_Vector);

type ExceptionBreakpointsFilter_Array is array (Positive range <>) of aliased ExceptionBreakpointsFilter;
type ExceptionBreakpointsFilter_Array_Access is access ExceptionBreakpointsFilter_Array;
type ExceptionBreakpointsFilter_Vector is new Ada.Finalization.Controlled with record
Data   : ExceptionBreakpointsFilter_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out ExceptionBreakpointsFilter_Vector);

overriding procedure Finalize (Self : in out ExceptionBreakpointsFilter_Vector);

type CompletionItem_Array is array (Positive range <>) of aliased CompletionItem;
type CompletionItem_Array_Access is access CompletionItem_Array;
type CompletionItem_Vector is new Ada.Finalization.Controlled with record
Data   : CompletionItem_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out CompletionItem_Vector);

overriding procedure Finalize (Self : in out CompletionItem_Vector);

type ExceptionPathSegment_Array is array (Positive range <>) of aliased ExceptionPathSegment;
type ExceptionPathSegment_Array_Access is access ExceptionPathSegment_Array;
type ExceptionPathSegment_Vector is new Ada.Finalization.Controlled with record
Data   : ExceptionPathSegment_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out ExceptionPathSegment_Vector);

overriding procedure Finalize (Self : in out ExceptionPathSegment_Vector);

type DataBreakpointAccessType_Array is array (Positive range <>) of aliased Enum.DataBreakpointAccessType;
type DataBreakpointAccessType_Array_Access is access DataBreakpointAccessType_Array;
type DataBreakpointAccessType_Vector is new Ada.Finalization.Controlled with record
Data   : DataBreakpointAccessType_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out DataBreakpointAccessType_Vector);

overriding procedure Finalize (Self : in out DataBreakpointAccessType_Vector);

type DisassembledInstruction_Array is array (Positive range <>) of aliased DisassembledInstruction;
type DisassembledInstruction_Array_Access is access DisassembledInstruction_Array;
type DisassembledInstruction_Vector is new Ada.Finalization.Controlled with record
Data   : DisassembledInstruction_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out DisassembledInstruction_Vector);

overriding procedure Finalize (Self : in out DisassembledInstruction_Vector);

type Module_Array is array (Positive range <>) of aliased Module;
type Module_Array_Access is access Module_Array;
type Module_Vector is new Ada.Finalization.Controlled with record
Data   : Module_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out Module_Vector);

overriding procedure Finalize (Self : in out Module_Vector);

type ExceptionFilterOptions_Array is array (Positive range <>) of aliased ExceptionFilterOptions;
type ExceptionFilterOptions_Array_Access is access ExceptionFilterOptions_Array;
type ExceptionFilterOptions_Vector is new Ada.Finalization.Controlled with record
Data   : ExceptionFilterOptions_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out ExceptionFilterOptions_Vector);

overriding procedure Finalize (Self : in out ExceptionFilterOptions_Vector);

type ColumnDescriptor_Array is array (Positive range <>) of aliased ColumnDescriptor;
type ColumnDescriptor_Array_Access is access ColumnDescriptor_Array;
type ColumnDescriptor_Vector is new Ada.Finalization.Controlled with record
Data   : ColumnDescriptor_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out ColumnDescriptor_Vector);

overriding procedure Finalize (Self : in out ColumnDescriptor_Vector);

type ExceptionDetails_Array is array (Positive range <>) of aliased ExceptionDetails;
type ExceptionDetails_Array_Access is access ExceptionDetails_Array;
type ExceptionDetails_Vector is new Ada.Finalization.Controlled with record
Data   : ExceptionDetails_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out ExceptionDetails_Vector);

overriding procedure Finalize (Self : in out ExceptionDetails_Vector);

end DAP.Tools;
--  Copyright <YEAR> <COPYRIGHT HOLDER>
--
--  Permission is hereby granted, free of charge, to any person obtaining a
--  copy of this software and associated documentation files (the "Software"),
--  to deal in the Software without restriction, including without limitation
--  the rights to use, copy, modify, merge, publish, distribute, sublicense,
--  and/or sell copies of the Software, and to permit persons to whom the
--  Software is furnished to do so, subject to the following conditions:
--
--  The above copyright notice and this permission notice shall be included in
--  all copies or substantial portions of the Software.
--
--  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
--  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
--  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
--  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
--  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
--  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
--  DEALINGS IN THE SOFTWARE.
--
--  DON'T EDIT THIS FILE! It was generated from JSON Schema.

pragma Style_Checks ("M99");  --  suppress style warning unitl gnatpp is fixed
with Ada.Unchecked_Deallocation;

package body DAP.Tools is
procedure Free is new Ada.Unchecked_Deallocation
(Thread_Array, Thread_Array_Access);

overriding procedure Adjust (Self : in out Thread_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new Thread_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out Thread_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : Thread_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out Thread_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out Thread_Vector;
Value : Thread) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / Thread'Size);
Self_Data_Saved : Thread_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new Thread_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new Thread_Array'(Self.Data.all
 & Thread_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_Thread_Variable_Reference
(Self : aliased in out Thread_Vector;
Index : Positive)
return Thread_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_Thread_Constant_Reference
(Self : aliased Thread_Vector;
Index : Positive)
return Thread_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(Checksum_Array, Checksum_Array_Access);

overriding procedure Adjust (Self : in out Checksum_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new Checksum_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out Checksum_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : Checksum_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out Checksum_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out Checksum_Vector;
Value : Checksum) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / Checksum'Size);
Self_Data_Saved : Checksum_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new Checksum_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new Checksum_Array'(Self.Data.all
 & Checksum_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_Checksum_Variable_Reference
(Self : aliased in out Checksum_Vector;
Index : Positive)
return Checksum_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_Checksum_Constant_Reference
(Self : aliased Checksum_Vector;
Index : Positive)
return Checksum_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(Breakpoint_Array, Breakpoint_Array_Access);

overriding procedure Adjust (Self : in out Breakpoint_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new Breakpoint_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out Breakpoint_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : Breakpoint_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out Breakpoint_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out Breakpoint_Vector;
Value : Breakpoint) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / Breakpoint'Size);
Self_Data_Saved : Breakpoint_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new Breakpoint_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new Breakpoint_Array'(Self.Data.all
 & Breakpoint_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_Breakpoint_Variable_Reference
(Self : aliased in out Breakpoint_Vector;
Index : Positive)
return Breakpoint_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_Breakpoint_Constant_Reference
(Self : aliased Breakpoint_Vector;
Index : Positive)
return Breakpoint_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(StepInTarget_Array, StepInTarget_Array_Access);

overriding procedure Adjust (Self : in out StepInTarget_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new StepInTarget_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out StepInTarget_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : StepInTarget_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out StepInTarget_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out StepInTarget_Vector;
Value : StepInTarget) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / StepInTarget'Size);
Self_Data_Saved : StepInTarget_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new StepInTarget_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new StepInTarget_Array'(Self.Data.all
 & StepInTarget_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_StepInTarget_Variable_Reference
(Self : aliased in out StepInTarget_Vector;
Index : Positive)
return StepInTarget_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_StepInTarget_Constant_Reference
(Self : aliased StepInTarget_Vector;
Index : Positive)
return StepInTarget_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(FunctionBreakpoint_Array, FunctionBreakpoint_Array_Access);

overriding procedure Adjust (Self : in out FunctionBreakpoint_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new FunctionBreakpoint_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out FunctionBreakpoint_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : FunctionBreakpoint_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out FunctionBreakpoint_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out FunctionBreakpoint_Vector;
Value : FunctionBreakpoint) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / FunctionBreakpoint'Size);
Self_Data_Saved : FunctionBreakpoint_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new FunctionBreakpoint_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new FunctionBreakpoint_Array'(Self.Data.all
 & FunctionBreakpoint_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_FunctionBreakpoint_Variable_Reference
(Self : aliased in out FunctionBreakpoint_Vector;
Index : Positive)
return FunctionBreakpoint_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_FunctionBreakpoint_Constant_Reference
(Self : aliased FunctionBreakpoint_Vector;
Index : Positive)
return FunctionBreakpoint_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(DataBreakpoint_Array, DataBreakpoint_Array_Access);

overriding procedure Adjust (Self : in out DataBreakpoint_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new DataBreakpoint_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out DataBreakpoint_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : DataBreakpoint_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out DataBreakpoint_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out DataBreakpoint_Vector;
Value : DataBreakpoint) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / DataBreakpoint'Size);
Self_Data_Saved : DataBreakpoint_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new DataBreakpoint_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new DataBreakpoint_Array'(Self.Data.all
 & DataBreakpoint_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_DataBreakpoint_Variable_Reference
(Self : aliased in out DataBreakpoint_Vector;
Index : Positive)
return DataBreakpoint_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_DataBreakpoint_Constant_Reference
(Self : aliased DataBreakpoint_Vector;
Index : Positive)
return DataBreakpoint_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(ExceptionOptions_Array, ExceptionOptions_Array_Access);

overriding procedure Adjust (Self : in out ExceptionOptions_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new ExceptionOptions_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out ExceptionOptions_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : ExceptionOptions_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out ExceptionOptions_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out ExceptionOptions_Vector;
Value : ExceptionOptions) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / ExceptionOptions'Size);
Self_Data_Saved : ExceptionOptions_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new ExceptionOptions_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new ExceptionOptions_Array'(Self.Data.all
 & ExceptionOptions_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_ExceptionOptions_Variable_Reference
(Self : aliased in out ExceptionOptions_Vector;
Index : Positive)
return ExceptionOptions_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_ExceptionOptions_Constant_Reference
(Self : aliased ExceptionOptions_Vector;
Index : Positive)
return ExceptionOptions_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(Integer_Array, Integer_Array_Access);

overriding procedure Adjust (Self : in out Integer_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new Integer_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out Integer_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : Integer_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out Integer_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out Integer_Vector;
Value : Integer) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / Integer'Size);
Self_Data_Saved : Integer_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new Integer_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new Integer_Array'(Self.Data.all
 & Integer_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_Integer_Variable_Reference
(Self : aliased in out Integer_Vector;
Index : Positive)
return Integer_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_Integer_Constant_Reference
(Self : aliased Integer_Vector;
Index : Positive)
return Integer_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(GotoTarget_Array, GotoTarget_Array_Access);

overriding procedure Adjust (Self : in out GotoTarget_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new GotoTarget_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out GotoTarget_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : GotoTarget_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out GotoTarget_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out GotoTarget_Vector;
Value : GotoTarget) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / GotoTarget'Size);
Self_Data_Saved : GotoTarget_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new GotoTarget_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new GotoTarget_Array'(Self.Data.all
 & GotoTarget_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_GotoTarget_Variable_Reference
(Self : aliased in out GotoTarget_Vector;
Index : Positive)
return GotoTarget_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_GotoTarget_Constant_Reference
(Self : aliased GotoTarget_Vector;
Index : Positive)
return GotoTarget_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(InvalidatedAreas_Array, InvalidatedAreas_Array_Access);

overriding procedure Adjust (Self : in out InvalidatedAreas_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new InvalidatedAreas_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out InvalidatedAreas_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : InvalidatedAreas_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out InvalidatedAreas_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out InvalidatedAreas_Vector;
Value : Enum.InvalidatedAreas) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / Enum.InvalidatedAreas'Size);
Self_Data_Saved : InvalidatedAreas_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new InvalidatedAreas_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new InvalidatedAreas_Array'(Self.Data.all
 & InvalidatedAreas_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_InvalidatedAreas_Variable_Reference
(Self : aliased in out InvalidatedAreas_Vector;
Index : Positive)
return InvalidatedAreas_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_InvalidatedAreas_Constant_Reference
(Self : aliased InvalidatedAreas_Vector;
Index : Positive)
return InvalidatedAreas_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(BreakpointLocation_Array, BreakpointLocation_Array_Access);

overriding procedure Adjust (Self : in out BreakpointLocation_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new BreakpointLocation_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out BreakpointLocation_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : BreakpointLocation_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out BreakpointLocation_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out BreakpointLocation_Vector;
Value : BreakpointLocation) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / BreakpointLocation'Size);
Self_Data_Saved : BreakpointLocation_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new BreakpointLocation_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new BreakpointLocation_Array'(Self.Data.all
 & BreakpointLocation_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_BreakpointLocation_Variable_Reference
(Self : aliased in out BreakpointLocation_Vector;
Index : Positive)
return BreakpointLocation_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_BreakpointLocation_Constant_Reference
(Self : aliased BreakpointLocation_Vector;
Index : Positive)
return BreakpointLocation_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(InstructionBreakpoint_Array, InstructionBreakpoint_Array_Access);

overriding procedure Adjust (Self : in out InstructionBreakpoint_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new InstructionBreakpoint_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out InstructionBreakpoint_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : InstructionBreakpoint_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out InstructionBreakpoint_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out InstructionBreakpoint_Vector;
Value : InstructionBreakpoint) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / InstructionBreakpoint'Size);
Self_Data_Saved : InstructionBreakpoint_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new InstructionBreakpoint_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new InstructionBreakpoint_Array'(Self.Data.all
 & InstructionBreakpoint_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_InstructionBreakpoint_Variable_Reference
(Self : aliased in out InstructionBreakpoint_Vector;
Index : Positive)
return InstructionBreakpoint_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_InstructionBreakpoint_Constant_Reference
(Self : aliased InstructionBreakpoint_Vector;
Index : Positive)
return InstructionBreakpoint_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(StackFrame_Array, StackFrame_Array_Access);

overriding procedure Adjust (Self : in out StackFrame_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new StackFrame_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out StackFrame_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : StackFrame_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out StackFrame_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out StackFrame_Vector;
Value : StackFrame) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / StackFrame'Size);
Self_Data_Saved : StackFrame_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new StackFrame_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new StackFrame_Array'(Self.Data.all
 & StackFrame_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_StackFrame_Variable_Reference
(Self : aliased in out StackFrame_Vector;
Index : Positive)
return StackFrame_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_StackFrame_Constant_Reference
(Self : aliased StackFrame_Vector;
Index : Positive)
return StackFrame_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(Scope_Array, Scope_Array_Access);

overriding procedure Adjust (Self : in out Scope_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new Scope_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out Scope_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : Scope_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out Scope_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out Scope_Vector;
Value : Scope) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / Scope'Size);
Self_Data_Saved : Scope_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new Scope_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new Scope_Array'(Self.Data.all
 & Scope_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_Scope_Variable_Reference
(Self : aliased in out Scope_Vector;
Index : Positive)
return Scope_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_Scope_Constant_Reference
(Self : aliased Scope_Vector;
Index : Positive)
return Scope_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(Variable_Array, Variable_Array_Access);

overriding procedure Adjust (Self : in out Variable_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new Variable_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out Variable_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : Variable_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out Variable_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out Variable_Vector;
Value : Variable) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / Variable'Size);
Self_Data_Saved : Variable_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new Variable_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new Variable_Array'(Self.Data.all
 & Variable_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_Variable_Variable_Reference
(Self : aliased in out Variable_Vector;
Index : Positive)
return Variable_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_Variable_Constant_Reference
(Self : aliased Variable_Vector;
Index : Positive)
return Variable_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(Source_Array, Source_Array_Access);

overriding procedure Adjust (Self : in out Source_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new Source_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out Source_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : Source_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out Source_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out Source_Vector;
Value : Source) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / Source'Size);
Self_Data_Saved : Source_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new Source_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new Source_Array'(Self.Data.all
 & Source_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_Source_Variable_Reference
(Self : aliased in out Source_Vector;
Index : Positive)
return Source_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_Source_Constant_Reference
(Self : aliased Source_Vector;
Index : Positive)
return Source_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(VariablePresentationHint_attributes_Array, VariablePresentationHint_attributes_Array_Access);

overriding procedure Adjust (Self : in out VariablePresentationHint_attributes_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new VariablePresentationHint_attributes_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out VariablePresentationHint_attributes_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : VariablePresentationHint_attributes_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out VariablePresentationHint_attributes_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out VariablePresentationHint_attributes_Vector;
Value : Enum.VariablePresentationHint_attributes) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / Enum.VariablePresentationHint_attributes'Size);
Self_Data_Saved : VariablePresentationHint_attributes_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new VariablePresentationHint_attributes_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new VariablePresentationHint_attributes_Array'(Self.Data.all
 & VariablePresentationHint_attributes_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_VariablePresentationHint_attributes_Variable_Reference
(Self : aliased in out VariablePresentationHint_attributes_Vector;
Index : Positive)
return VariablePresentationHint_attributes_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_VariablePresentationHint_attributes_Constant_Reference
(Self : aliased VariablePresentationHint_attributes_Vector;
Index : Positive)
return VariablePresentationHint_attributes_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(SourceBreakpoint_Array, SourceBreakpoint_Array_Access);

overriding procedure Adjust (Self : in out SourceBreakpoint_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new SourceBreakpoint_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out SourceBreakpoint_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : SourceBreakpoint_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out SourceBreakpoint_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out SourceBreakpoint_Vector;
Value : SourceBreakpoint) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / SourceBreakpoint'Size);
Self_Data_Saved : SourceBreakpoint_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new SourceBreakpoint_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new SourceBreakpoint_Array'(Self.Data.all
 & SourceBreakpoint_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_SourceBreakpoint_Variable_Reference
(Self : aliased in out SourceBreakpoint_Vector;
Index : Positive)
return SourceBreakpoint_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_SourceBreakpoint_Constant_Reference
(Self : aliased SourceBreakpoint_Vector;
Index : Positive)
return SourceBreakpoint_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(ChecksumAlgorithm_Array, ChecksumAlgorithm_Array_Access);

overriding procedure Adjust (Self : in out ChecksumAlgorithm_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new ChecksumAlgorithm_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out ChecksumAlgorithm_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : ChecksumAlgorithm_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out ChecksumAlgorithm_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out ChecksumAlgorithm_Vector;
Value : Enum.ChecksumAlgorithm) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / Enum.ChecksumAlgorithm'Size);
Self_Data_Saved : ChecksumAlgorithm_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new ChecksumAlgorithm_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new ChecksumAlgorithm_Array'(Self.Data.all
 & ChecksumAlgorithm_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_ChecksumAlgorithm_Variable_Reference
(Self : aliased in out ChecksumAlgorithm_Vector;
Index : Positive)
return ChecksumAlgorithm_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_ChecksumAlgorithm_Constant_Reference
(Self : aliased ChecksumAlgorithm_Vector;
Index : Positive)
return ChecksumAlgorithm_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(ExceptionBreakpointsFilter_Array, ExceptionBreakpointsFilter_Array_Access);

overriding procedure Adjust (Self : in out ExceptionBreakpointsFilter_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new ExceptionBreakpointsFilter_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out ExceptionBreakpointsFilter_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : ExceptionBreakpointsFilter_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out ExceptionBreakpointsFilter_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out ExceptionBreakpointsFilter_Vector;
Value : ExceptionBreakpointsFilter) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / ExceptionBreakpointsFilter'Size);
Self_Data_Saved : ExceptionBreakpointsFilter_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new ExceptionBreakpointsFilter_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new ExceptionBreakpointsFilter_Array'(Self.Data.all
 & ExceptionBreakpointsFilter_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_ExceptionBreakpointsFilter_Variable_Reference
(Self : aliased in out ExceptionBreakpointsFilter_Vector;
Index : Positive)
return ExceptionBreakpointsFilter_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_ExceptionBreakpointsFilter_Constant_Reference
(Self : aliased ExceptionBreakpointsFilter_Vector;
Index : Positive)
return ExceptionBreakpointsFilter_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(CompletionItem_Array, CompletionItem_Array_Access);

overriding procedure Adjust (Self : in out CompletionItem_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new CompletionItem_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out CompletionItem_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : CompletionItem_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out CompletionItem_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out CompletionItem_Vector;
Value : CompletionItem) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / CompletionItem'Size);
Self_Data_Saved : CompletionItem_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new CompletionItem_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new CompletionItem_Array'(Self.Data.all
 & CompletionItem_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_CompletionItem_Variable_Reference
(Self : aliased in out CompletionItem_Vector;
Index : Positive)
return CompletionItem_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_CompletionItem_Constant_Reference
(Self : aliased CompletionItem_Vector;
Index : Positive)
return CompletionItem_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(ExceptionPathSegment_Array, ExceptionPathSegment_Array_Access);

overriding procedure Adjust (Self : in out ExceptionPathSegment_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new ExceptionPathSegment_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out ExceptionPathSegment_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : ExceptionPathSegment_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out ExceptionPathSegment_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out ExceptionPathSegment_Vector;
Value : ExceptionPathSegment) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / ExceptionPathSegment'Size);
Self_Data_Saved : ExceptionPathSegment_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new ExceptionPathSegment_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new ExceptionPathSegment_Array'(Self.Data.all
 & ExceptionPathSegment_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_ExceptionPathSegment_Variable_Reference
(Self : aliased in out ExceptionPathSegment_Vector;
Index : Positive)
return ExceptionPathSegment_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_ExceptionPathSegment_Constant_Reference
(Self : aliased ExceptionPathSegment_Vector;
Index : Positive)
return ExceptionPathSegment_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(DataBreakpointAccessType_Array, DataBreakpointAccessType_Array_Access);

overriding procedure Adjust (Self : in out DataBreakpointAccessType_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new DataBreakpointAccessType_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out DataBreakpointAccessType_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : DataBreakpointAccessType_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out DataBreakpointAccessType_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out DataBreakpointAccessType_Vector;
Value : Enum.DataBreakpointAccessType) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / Enum.DataBreakpointAccessType'Size);
Self_Data_Saved : DataBreakpointAccessType_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new DataBreakpointAccessType_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new DataBreakpointAccessType_Array'(Self.Data.all
 & DataBreakpointAccessType_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_DataBreakpointAccessType_Variable_Reference
(Self : aliased in out DataBreakpointAccessType_Vector;
Index : Positive)
return DataBreakpointAccessType_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_DataBreakpointAccessType_Constant_Reference
(Self : aliased DataBreakpointAccessType_Vector;
Index : Positive)
return DataBreakpointAccessType_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(DisassembledInstruction_Array, DisassembledInstruction_Array_Access);

overriding procedure Adjust (Self : in out DisassembledInstruction_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new DisassembledInstruction_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out DisassembledInstruction_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : DisassembledInstruction_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out DisassembledInstruction_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out DisassembledInstruction_Vector;
Value : DisassembledInstruction) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / DisassembledInstruction'Size);
Self_Data_Saved : DisassembledInstruction_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new DisassembledInstruction_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new DisassembledInstruction_Array'(Self.Data.all
 & DisassembledInstruction_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_DisassembledInstruction_Variable_Reference
(Self : aliased in out DisassembledInstruction_Vector;
Index : Positive)
return DisassembledInstruction_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_DisassembledInstruction_Constant_Reference
(Self : aliased DisassembledInstruction_Vector;
Index : Positive)
return DisassembledInstruction_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(Module_Array, Module_Array_Access);

overriding procedure Adjust (Self : in out Module_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new Module_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out Module_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : Module_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out Module_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out Module_Vector;
Value : Module) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / Module'Size);
Self_Data_Saved : Module_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new Module_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new Module_Array'(Self.Data.all
 & Module_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_Module_Variable_Reference
(Self : aliased in out Module_Vector;
Index : Positive)
return Module_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_Module_Constant_Reference
(Self : aliased Module_Vector;
Index : Positive)
return Module_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(ExceptionFilterOptions_Array, ExceptionFilterOptions_Array_Access);

overriding procedure Adjust (Self : in out ExceptionFilterOptions_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new ExceptionFilterOptions_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out ExceptionFilterOptions_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : ExceptionFilterOptions_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out ExceptionFilterOptions_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out ExceptionFilterOptions_Vector;
Value : ExceptionFilterOptions) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / ExceptionFilterOptions'Size);
Self_Data_Saved : ExceptionFilterOptions_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new ExceptionFilterOptions_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new ExceptionFilterOptions_Array'(Self.Data.all
 & ExceptionFilterOptions_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_ExceptionFilterOptions_Variable_Reference
(Self : aliased in out ExceptionFilterOptions_Vector;
Index : Positive)
return ExceptionFilterOptions_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_ExceptionFilterOptions_Constant_Reference
(Self : aliased ExceptionFilterOptions_Vector;
Index : Positive)
return ExceptionFilterOptions_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(ColumnDescriptor_Array, ColumnDescriptor_Array_Access);

overriding procedure Adjust (Self : in out ColumnDescriptor_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new ColumnDescriptor_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out ColumnDescriptor_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : ColumnDescriptor_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out ColumnDescriptor_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out ColumnDescriptor_Vector;
Value : ColumnDescriptor) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / ColumnDescriptor'Size);
Self_Data_Saved : ColumnDescriptor_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new ColumnDescriptor_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new ColumnDescriptor_Array'(Self.Data.all
 & ColumnDescriptor_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_ColumnDescriptor_Variable_Reference
(Self : aliased in out ColumnDescriptor_Vector;
Index : Positive)
return ColumnDescriptor_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_ColumnDescriptor_Constant_Reference
(Self : aliased ColumnDescriptor_Vector;
Index : Positive)
return ColumnDescriptor_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(ExceptionDetails_Array, ExceptionDetails_Array_Access);

overriding procedure Adjust (Self : in out ExceptionDetails_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new ExceptionDetails_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out ExceptionDetails_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : ExceptionDetails_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out ExceptionDetails_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out ExceptionDetails_Vector;
Value : ExceptionDetails) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / ExceptionDetails'Size);
Self_Data_Saved : ExceptionDetails_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new ExceptionDetails_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new ExceptionDetails_Array'(Self.Data.all
 & ExceptionDetails_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_ExceptionDetails_Variable_Reference
(Self : aliased in out ExceptionDetails_Vector;
Index : Positive)
return ExceptionDetails_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_ExceptionDetails_Constant_Reference
(Self : aliased ExceptionDetails_Vector;
Index : Positive)
return ExceptionDetails_Constant_Reference
is (Element => Self.Data (Index)'Access);

end DAP.Tools;

--  Copyright <YEAR> <COPYRIGHT HOLDER>
--
--  Permission is hereby granted, free of charge, to any person obtaining a
--  copy of this software and associated documentation files (the "Software"),
--  to deal in the Software without restriction, including without limitation
--  the rights to use, copy, modify, merge, publish, distribute, sublicense,
--  and/or sell copies of the Software, and to permit persons to whom the
--  Software is furnished to do so, subject to the following conditions:
--
--  The above copyright notice and this permission notice shall be included in
--  all copies or substantial portions of the Software.
--
--  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
--  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
--  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
--  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
--  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
--  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
--  DEALINGS IN THE SOFTWARE.
--
--  DON'T EDIT THIS FILE! It was generated from JSON Schema.

with VSS.JSON.Content_Handlers;

package DAP.Tools.Outputs is

procedure Output_ModuleEvent_reason
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.ModuleEvent_reason);

procedure Output_ColumnDescriptor_type
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.ColumnDescriptor_type);

procedure Output_StackFrame_presentationHint
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.StackFrame_presentationHint);

procedure Output_ExceptionBreakMode
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.ExceptionBreakMode);

procedure Output_StoppedEvent_reason
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.StoppedEvent_reason);

procedure Output_StartDebuggingRequestArguments_request
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.StartDebuggingRequestArguments_request);

procedure Output_OutputEvent_category
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.OutputEvent_category);

procedure Output_OutputEvent_group
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.OutputEvent_group);

procedure Output_ChecksumAlgorithm
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.ChecksumAlgorithm);

procedure Output_ProcessEvent_startMethod
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.ProcessEvent_startMethod);

procedure Output_Scope_presentationHint
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.Scope_presentationHint);

procedure Output_Response_message
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.Response_message);

procedure Output_CompletionItemType
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.CompletionItemType);

procedure Output_InvalidatedAreas
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.InvalidatedAreas);

procedure Output_Source_presentationHint
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.Source_presentationHint);

procedure Output_LoadedSourceEvent_reason
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.LoadedSourceEvent_reason);

procedure Output_ProtocolMessage_type
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.ProtocolMessage_type);

procedure Output_RunInTerminalRequestArguments_kind
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.RunInTerminalRequestArguments_kind);

procedure Output_VariablesArguments_filter
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.VariablesArguments_filter);

procedure Output_VariablePresentationHint_kind
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.VariablePresentationHint_kind);

procedure Output_VariablePresentationHint_attributes
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.VariablePresentationHint_attributes);

procedure Output_VariablePresentationHint_visibility
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.VariablePresentationHint_visibility);

procedure Output_InitializeRequestArguments_pathFormat
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.InitializeRequestArguments_pathFormat);

procedure Output_ThreadEvent_reason
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.ThreadEvent_reason);

procedure Output_DataBreakpointAccessType
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.DataBreakpointAccessType);

procedure Output_BreakpointEvent_reason
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.BreakpointEvent_reason);

procedure Output_EvaluateArguments_context
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.EvaluateArguments_context);

procedure Output_SteppingGranularity
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.SteppingGranularity);

procedure Output_GotoResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : GotoResponse);

procedure Output_ExceptionDetails
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ExceptionDetails);

procedure Output_StepInTargetsRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StepInTargetsRequest);

procedure Output_ModulesResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ModulesResponse);

procedure Output_NextArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : NextArguments);

procedure Output_ExceptionInfoRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ExceptionInfoRequest);

procedure Output_TerminateThreadsArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : TerminateThreadsArguments);

procedure Output_DataBreakpointInfoRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : DataBreakpointInfoRequest);

procedure Output_TerminateThreadsRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : TerminateThreadsRequest);

procedure Output_SetBreakpointsArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetBreakpointsArguments);

procedure Output_ModuleEvent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ModuleEvent);

procedure Output_ContinuedEvent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ContinuedEvent);

procedure Output_RestartArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : RestartArguments);

procedure Output_SetVariableArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetVariableArguments);

procedure Output_Checksum
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Checksum);

procedure Output_BreakpointLocationsRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : BreakpointLocationsRequest);

procedure Output_ModulesViewDescriptor
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ModulesViewDescriptor);

procedure Output_ColumnDescriptor
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ColumnDescriptor);

procedure Output_Capabilities
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Capabilities);

procedure Output_StackTraceResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StackTraceResponse);

procedure Output_LoadedSourcesArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : LoadedSourcesArguments);

procedure Output_ConfigurationDoneRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ConfigurationDoneRequest);

procedure Output_StepInTargetsResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StepInTargetsResponse);

procedure Output_StackFrame
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StackFrame);

procedure Output_SetExpressionRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetExpressionRequest);

procedure Output_SourceArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SourceArguments);

procedure Output_ExceptionFilterOptions
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ExceptionFilterOptions);

procedure Output_ExceptionBreakpointsFilter
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ExceptionBreakpointsFilter);

procedure Output_SetVariableRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetVariableRequest);

procedure Output_AttachRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : AttachRequest);

procedure Output_MemoryEvent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : MemoryEvent);

procedure Output_ReadMemoryArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ReadMemoryArguments);

procedure Output_LoadedSourcesRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : LoadedSourcesRequest);

procedure Output_LaunchRequestArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : LaunchRequestArguments);

procedure Output_ExitedEvent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ExitedEvent);

procedure Output_SetBreakpointsRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetBreakpointsRequest);

procedure Output_TerminateResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : TerminateResponse);

procedure Output_Variable
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Variable);

procedure Output_StoppedEvent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StoppedEvent);

procedure Output_RestartFrameRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : RestartFrameRequest);

procedure Output_AttachRequestArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : AttachRequestArguments);

procedure Output_ScopesResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ScopesResponse);

procedure Output_StepOutArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StepOutArguments);

procedure Output_CompletionsRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : CompletionsRequest);

procedure Output_StartDebuggingRequestArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StartDebuggingRequestArguments);

procedure Output_ProgressUpdateEvent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ProgressUpdateEvent);

procedure Output_ExceptionInfoResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ExceptionInfoResponse);

procedure Output_InitializedEvent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : InitializedEvent);

procedure Output_SetExpressionResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetExpressionResponse);

procedure Output_StepInTarget
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StepInTarget);

procedure Output_ReverseContinueResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ReverseContinueResponse);

procedure Output_OutputEvent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : OutputEvent);

procedure Output_RestartRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : RestartRequest);

procedure Output_StackTraceArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StackTraceArguments);

procedure Output_Thread
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Thread);

procedure Output_SetDataBreakpointsRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetDataBreakpointsRequest);

procedure Output_SourceRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SourceRequest);

procedure Output_PauseResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : PauseResponse);

procedure Output_SetFunctionBreakpointsRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetFunctionBreakpointsRequest);

procedure Output_ProcessEvent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ProcessEvent);

procedure Output_NextResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : NextResponse);

procedure Output_AttachResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : AttachResponse);

procedure Output_RestartResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : RestartResponse);

procedure Output_CapabilitiesEvent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : CapabilitiesEvent);

procedure Output_Scope
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Scope);

procedure Output_DisassembleArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : DisassembleArguments);

procedure Output_SetInstructionBreakpointsRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetInstructionBreakpointsRequest);

procedure Output_Response
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Response);

procedure Output_DataBreakpointInfoResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : DataBreakpointInfoResponse);

procedure Output_SourceBreakpoint
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SourceBreakpoint);

procedure Output_PauseRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : PauseRequest);

procedure Output_FunctionBreakpoint
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : FunctionBreakpoint);

procedure Output_SetExpressionArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetExpressionArguments);

procedure Output_SetExceptionBreakpointsArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetExceptionBreakpointsArguments);

procedure Output_ValueFormat
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ValueFormat);

procedure Output_RunInTerminalRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : RunInTerminalRequest);

procedure Output_CompletionsArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : CompletionsArguments);

procedure Output_WriteMemoryResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : WriteMemoryResponse);

procedure Output_ReverseContinueArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ReverseContinueArguments);

procedure Output_RunInTerminalResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : RunInTerminalResponse);

procedure Output_DisconnectArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : DisconnectArguments);

procedure Output_Module
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Module);

procedure Output_GotoTargetsRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : GotoTargetsRequest);

procedure Output_ThreadsResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ThreadsResponse);

procedure Output_SetDataBreakpointsResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetDataBreakpointsResponse);

procedure Output_DataBreakpoint
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : DataBreakpoint);

procedure Output_SetDataBreakpointsArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetDataBreakpointsArguments);

procedure Output_ExceptionPathSegment
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ExceptionPathSegment);

procedure Output_Message
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Message);

procedure Output_SourceResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SourceResponse);

procedure Output_ContinueResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ContinueResponse);

procedure Output_RestartFrameResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : RestartFrameResponse);

procedure Output_StepInArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StepInArguments);

procedure Output_LaunchResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : LaunchResponse);

procedure Output_StepInResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StepInResponse);

procedure Output_TerminateArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : TerminateArguments);

procedure Output_LaunchRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : LaunchRequest);

procedure Output_StepOutResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StepOutResponse);

procedure Output_EvaluateRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : EvaluateRequest);

procedure Output_ContinueArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ContinueArguments);

procedure Output_StepBackArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StepBackArguments);

procedure Output_BreakpointLocationsArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : BreakpointLocationsArguments);

procedure Output_CancelArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : CancelArguments);

procedure Output_CompletionsResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : CompletionsResponse);

procedure Output_Breakpoint
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Breakpoint);

procedure Output_Source
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Source);

procedure Output_WriteMemoryArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : WriteMemoryArguments);

procedure Output_ConfigurationDoneArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ConfigurationDoneArguments);

procedure Output_StepOutRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StepOutRequest);

procedure Output_Request
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Request);

procedure Output_LoadedSourceEvent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : LoadedSourceEvent);

procedure Output_StackFrameFormat
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StackFrameFormat);

procedure Output_DisassembleRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : DisassembleRequest);

procedure Output_ReadMemoryResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ReadMemoryResponse);

procedure Output_StepBackRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StepBackRequest);

procedure Output_ProtocolMessage
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ProtocolMessage);

procedure Output_ThreadsRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ThreadsRequest);

procedure Output_VariablesResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : VariablesResponse);

procedure Output_RunInTerminalRequestArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : RunInTerminalRequestArguments);

procedure Output_TerminateRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : TerminateRequest);

procedure Output_VariablesArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : VariablesArguments);

procedure Output_InitializeRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : InitializeRequest);

procedure Output_BreakpointLocationsResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : BreakpointLocationsResponse);

procedure Output_VariablePresentationHint
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : VariablePresentationHint);

procedure Output_DisassembledInstruction
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : DisassembledInstruction);

procedure Output_PauseArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : PauseArguments);

procedure Output_CancelResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : CancelResponse);

procedure Output_InitializeRequestArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : InitializeRequestArguments);

procedure Output_SetInstructionBreakpointsResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetInstructionBreakpointsResponse);

procedure Output_CancelRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : CancelRequest);

procedure Output_ProgressEndEvent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ProgressEndEvent);

procedure Output_Event
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Event);

procedure Output_VariablesRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : VariablesRequest);

procedure Output_ExceptionOptions
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ExceptionOptions);

procedure Output_TerminatedEvent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : TerminatedEvent);

procedure Output_StartDebuggingRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StartDebuggingRequest);

procedure Output_ThreadEvent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ThreadEvent);

procedure Output_GotoTargetsResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : GotoTargetsResponse);

procedure Output_CompletionItem
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : CompletionItem);

procedure Output_ScopesArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ScopesArguments);

procedure Output_ErrorResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ErrorResponse);

procedure Output_SetInstructionBreakpointsArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetInstructionBreakpointsArguments);

procedure Output_GotoArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : GotoArguments);

procedure Output_BreakpointEvent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : BreakpointEvent);

procedure Output_GotoTarget
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : GotoTarget);

procedure Output_ReadMemoryRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ReadMemoryRequest);

procedure Output_ModulesArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ModulesArguments);

procedure Output_NextRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : NextRequest);

procedure Output_ProgressStartEvent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ProgressStartEvent);

procedure Output_SetVariableResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetVariableResponse);

procedure Output_BreakpointLocation
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : BreakpointLocation);

procedure Output_RestartFrameArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : RestartFrameArguments);

procedure Output_DisconnectResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : DisconnectResponse);

procedure Output_SetExceptionBreakpointsRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetExceptionBreakpointsRequest);

procedure Output_WriteMemoryRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : WriteMemoryRequest);

procedure Output_DataBreakpointInfoArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : DataBreakpointInfoArguments);

procedure Output_InitializeResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : InitializeResponse);

procedure Output_ConfigurationDoneResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ConfigurationDoneResponse);

procedure Output_StepInTargetsArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StepInTargetsArguments);

procedure Output_EvaluateArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : EvaluateArguments);

procedure Output_SetFunctionBreakpointsArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetFunctionBreakpointsArguments);

procedure Output_GotoRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : GotoRequest);

procedure Output_SetFunctionBreakpointsResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetFunctionBreakpointsResponse);

procedure Output_ExceptionInfoArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ExceptionInfoArguments);

procedure Output_StackTraceRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StackTraceRequest);

procedure Output_EvaluateResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : EvaluateResponse);

procedure Output_ReverseContinueRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ReverseContinueRequest);

procedure Output_ModulesRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ModulesRequest);

procedure Output_SetBreakpointsResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetBreakpointsResponse);

procedure Output_InstructionBreakpoint
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : InstructionBreakpoint);

procedure Output_DisconnectRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : DisconnectRequest);

procedure Output_TerminateThreadsResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : TerminateThreadsResponse);

procedure Output_ScopesRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ScopesRequest);

procedure Output_SetExceptionBreakpointsResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetExceptionBreakpointsResponse);

procedure Output_StepBackResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StepBackResponse);

procedure Output_DisassembleResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : DisassembleResponse);

procedure Output_InvalidatedEvent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : InvalidatedEvent);

procedure Output_GotoTargetsArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : GotoTargetsArguments);

procedure Output_StepInRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StepInRequest);

procedure Output_ContinueRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ContinueRequest);

procedure Output_LoadedSourcesResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : LoadedSourcesResponse);

procedure Output_StartDebuggingResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StartDebuggingResponse);

end DAP.Tools.Outputs;
--  Copyright <YEAR> <COPYRIGHT HOLDER>
--
--  Permission is hereby granted, free of charge, to any person obtaining a
--  copy of this software and associated documentation files (the "Software"),
--  to deal in the Software without restriction, including without limitation
--  the rights to use, copy, modify, merge, publish, distribute, sublicense,
--  and/or sell copies of the Software, and to permit persons to whom the
--  Software is furnished to do so, subject to the following conditions:
--
--  The above copyright notice and this permission notice shall be included in
--  all copies or substantial portions of the Software.
--
--  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
--  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
--  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
--  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
--  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
--  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
--  DEALINGS IN THE SOFTWARE.
--
--  DON'T EDIT THIS FILE! It was generated from JSON Schema.

with Interfaces;
package body DAP.Tools.Outputs is
pragma Style_Checks (Off);
procedure Output_Any_Value
  (Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
   Value   : Any_Value'Class) is
begin
   for Item of Value loop
      case Item.Kind is
         when VSS.JSON.Streams.Start_Array =>
            Handler.Start_Array;
         when VSS.JSON.Streams.End_Array =>
            Handler.End_Array;
         when VSS.JSON.Streams.Start_Object =>
            Handler.Start_Object;
         when VSS.JSON.Streams.End_Object =>
            Handler.End_Object;
         when VSS.JSON.Streams.Key_Name =>
            Handler.Key_Name (Item.Key_Name);
         when VSS.JSON.Streams.String_Value =>
            Handler.String_Value (Item.String_Value);
         when VSS.JSON.Streams.Number_Value =>
            Handler.Number_Value (Item.Number_Value);
         when VSS.JSON.Streams.Boolean_Value =>
            Handler.Boolean_Value (Item.Boolean_Value);
         when VSS.JSON.Streams.Null_Value =>
            Handler.Null_Value;
         when VSS.JSON.Streams.None =>
            null;
         when VSS.JSON.Streams.Invalid =>
            raise Program_Error;
         when VSS.JSON.Streams.Start_Document =>
            raise Program_Error;
         when VSS.JSON.Streams.End_Document =>
            raise Program_Error;
         when VSS.JSON.Streams.Comment =>
            raise Program_Error;
      end case;
   end loop;
end Output_Any_Value;

procedure Output_ModuleEvent_reason
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.ModuleEvent_reason) is
begin
case Value is
when Enum.a_new =>
Handler.String_Value ("new");
when Enum.changed =>
Handler.String_Value ("changed");
when Enum.removed =>
Handler.String_Value ("removed");
end case;
end Output_ModuleEvent_reason;

procedure Output_ColumnDescriptor_type
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.ColumnDescriptor_type) is
begin
case Value is
when Enum.string =>
Handler.String_Value ("string");
when Enum.number =>
Handler.String_Value ("number");
when Enum.a_boolean =>
Handler.String_Value ("boolean");
when Enum.unixTimestampUTC =>
Handler.String_Value ("unixTimestampUTC");
end case;
end Output_ColumnDescriptor_type;

procedure Output_StackFrame_presentationHint
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.StackFrame_presentationHint) is
begin
case Value is
when Enum.normal =>
Handler.String_Value ("normal");
when Enum.label =>
Handler.String_Value ("label");
when Enum.subtle =>
Handler.String_Value ("subtle");
end case;
end Output_StackFrame_presentationHint;

procedure Output_ExceptionBreakMode
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.ExceptionBreakMode) is
begin
case Value is
when Enum.never =>
Handler.String_Value ("never");
when Enum.always =>
Handler.String_Value ("always");
when Enum.unhandled =>
Handler.String_Value ("unhandled");
when Enum.userUnhandled =>
Handler.String_Value ("userUnhandled");
end case;
end Output_ExceptionBreakMode;

procedure Output_StoppedEvent_reason
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.StoppedEvent_reason) is
begin
case Value.Kind is
when Enum.Custom_Value =>
Handler.String_Value (Value.Custom_Value);

when Enum.step =>
Handler.String_Value ("step");
when Enum.breakpoint =>
Handler.String_Value ("breakpoint");
when Enum.a_exception =>
Handler.String_Value ("exception");
when Enum.pause =>
Handler.String_Value ("pause");
when Enum.a_entry =>
Handler.String_Value ("entry");
when Enum.a_goto =>
Handler.String_Value ("goto");
when Enum.function_breakpoint =>
Handler.String_Value ("function breakpoint");
when Enum.data_breakpoint =>
Handler.String_Value ("data breakpoint");
when Enum.instruction_breakpoint =>
Handler.String_Value ("instruction breakpoint");
end case;
end Output_StoppedEvent_reason;

procedure Output_StartDebuggingRequestArguments_request
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.StartDebuggingRequestArguments_request) is
begin
case Value is
when Enum.launch =>
Handler.String_Value ("launch");
when Enum.attach =>
Handler.String_Value ("attach");
end case;
end Output_StartDebuggingRequestArguments_request;

procedure Output_OutputEvent_category
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.OutputEvent_category) is
begin
case Value.Kind is
when Enum.Custom_Value =>
Handler.String_Value (Value.Custom_Value);

when Enum.console =>
Handler.String_Value ("console");
when Enum.important =>
Handler.String_Value ("important");
when Enum.stdout =>
Handler.String_Value ("stdout");
when Enum.stderr =>
Handler.String_Value ("stderr");
when Enum.telemetry =>
Handler.String_Value ("telemetry");
end case;
end Output_OutputEvent_category;

procedure Output_OutputEvent_group
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.OutputEvent_group) is
begin
case Value is
when Enum.start =>
Handler.String_Value ("start");
when Enum.startCollapsed =>
Handler.String_Value ("startCollapsed");
when Enum.a_end =>
Handler.String_Value ("end");
end case;
end Output_OutputEvent_group;

procedure Output_ChecksumAlgorithm
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.ChecksumAlgorithm) is
begin
case Value is
when Enum.MD5 =>
Handler.String_Value ("MD5");
when Enum.SHA1 =>
Handler.String_Value ("SHA1");
when Enum.SHA256 =>
Handler.String_Value ("SHA256");
when Enum.timestamp =>
Handler.String_Value ("timestamp");
end case;
end Output_ChecksumAlgorithm;

procedure Output_ProcessEvent_startMethod
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.ProcessEvent_startMethod) is
begin
case Value is
when Enum.launch =>
Handler.String_Value ("launch");
when Enum.attach =>
Handler.String_Value ("attach");
when Enum.attachForSuspendedLaunch =>
Handler.String_Value ("attachForSuspendedLaunch");
end case;
end Output_ProcessEvent_startMethod;

procedure Output_Scope_presentationHint
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.Scope_presentationHint) is
begin
case Value.Kind is
when Enum.Custom_Value =>
Handler.String_Value (Value.Custom_Value);

when Enum.arguments =>
Handler.String_Value ("arguments");
when Enum.locals =>
Handler.String_Value ("locals");
when Enum.registers =>
Handler.String_Value ("registers");
end case;
end Output_Scope_presentationHint;

procedure Output_Response_message
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.Response_message) is
begin
case Value.Kind is
when Enum.Custom_Value =>
Handler.String_Value (Value.Custom_Value);

when Enum.cancelled =>
Handler.String_Value ("cancelled");
when Enum.notStopped =>
Handler.String_Value ("notStopped");
end case;
end Output_Response_message;

procedure Output_CompletionItemType
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.CompletionItemType) is
begin
case Value is
when Enum.method =>
Handler.String_Value ("method");
when Enum.a_function =>
Handler.String_Value ("function");
when Enum.constructor =>
Handler.String_Value ("constructor");
when Enum.field =>
Handler.String_Value ("field");
when Enum.variable =>
Handler.String_Value ("variable");
when Enum.class =>
Handler.String_Value ("class");
when Enum.an_interface =>
Handler.String_Value ("interface");
when Enum.module =>
Handler.String_Value ("module");
when Enum.property =>
Handler.String_Value ("property");
when Enum.unit =>
Handler.String_Value ("unit");
when Enum.value =>
Handler.String_Value ("value");
when Enum.enum =>
Handler.String_Value ("enum");
when Enum.keyword =>
Handler.String_Value ("keyword");
when Enum.snippet =>
Handler.String_Value ("snippet");
when Enum.text =>
Handler.String_Value ("text");
when Enum.color =>
Handler.String_Value ("color");
when Enum.file =>
Handler.String_Value ("file");
when Enum.reference =>
Handler.String_Value ("reference");
when Enum.customcolor =>
Handler.String_Value ("customcolor");
end case;
end Output_CompletionItemType;

procedure Output_InvalidatedAreas
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.InvalidatedAreas) is
begin
case Value.Kind is
when Enum.Custom_Value =>
Handler.String_Value (Value.Custom_Value);

when Enum.an_all =>
Handler.String_Value ("all");
when Enum.stacks =>
Handler.String_Value ("stacks");
when Enum.threads =>
Handler.String_Value ("threads");
when Enum.variables =>
Handler.String_Value ("variables");
end case;
end Output_InvalidatedAreas;

procedure Output_Source_presentationHint
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.Source_presentationHint) is
begin
case Value is
when Enum.normal =>
Handler.String_Value ("normal");
when Enum.emphasize =>
Handler.String_Value ("emphasize");
when Enum.deemphasize =>
Handler.String_Value ("deemphasize");
end case;
end Output_Source_presentationHint;

procedure Output_LoadedSourceEvent_reason
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.LoadedSourceEvent_reason) is
begin
case Value is
when Enum.a_new =>
Handler.String_Value ("new");
when Enum.changed =>
Handler.String_Value ("changed");
when Enum.removed =>
Handler.String_Value ("removed");
end case;
end Output_LoadedSourceEvent_reason;

procedure Output_ProtocolMessage_type
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.ProtocolMessage_type) is
begin
case Value.Kind is
when Enum.Custom_Value =>
Handler.String_Value (Value.Custom_Value);

when Enum.request =>
Handler.String_Value ("request");
when Enum.response =>
Handler.String_Value ("response");
when Enum.event =>
Handler.String_Value ("event");
end case;
end Output_ProtocolMessage_type;

procedure Output_RunInTerminalRequestArguments_kind
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.RunInTerminalRequestArguments_kind) is
begin
case Value is
when Enum.integrated =>
Handler.String_Value ("integrated");
when Enum.external =>
Handler.String_Value ("external");
end case;
end Output_RunInTerminalRequestArguments_kind;

procedure Output_VariablesArguments_filter
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.VariablesArguments_filter) is
begin
case Value is
when Enum.indexed =>
Handler.String_Value ("indexed");
when Enum.named =>
Handler.String_Value ("named");
end case;
end Output_VariablesArguments_filter;

procedure Output_VariablePresentationHint_kind
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.VariablePresentationHint_kind) is
begin
case Value.Kind is
when Enum.Custom_Value =>
Handler.String_Value (Value.Custom_Value);

when Enum.property =>
Handler.String_Value ("property");
when Enum.method =>
Handler.String_Value ("method");
when Enum.class =>
Handler.String_Value ("class");
when Enum.data =>
Handler.String_Value ("data");
when Enum.event =>
Handler.String_Value ("event");
when Enum.baseClass =>
Handler.String_Value ("baseClass");
when Enum.innerClass =>
Handler.String_Value ("innerClass");
when Enum.an_interface =>
Handler.String_Value ("interface");
when Enum.mostDerivedClass =>
Handler.String_Value ("mostDerivedClass");
when Enum.virtual =>
Handler.String_Value ("virtual");
when Enum.dataBreakpoint =>
Handler.String_Value ("dataBreakpoint");
end case;
end Output_VariablePresentationHint_kind;

procedure Output_VariablePresentationHint_attributes
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.VariablePresentationHint_attributes) is
begin
case Value.Kind is
when Enum.Custom_Value =>
Handler.String_Value (Value.Custom_Value);

when Enum.static =>
Handler.String_Value ("static");
when Enum.a_constant =>
Handler.String_Value ("constant");
when Enum.readOnly =>
Handler.String_Value ("readOnly");
when Enum.rawString =>
Handler.String_Value ("rawString");
when Enum.hasObjectId =>
Handler.String_Value ("hasObjectId");
when Enum.canHaveObjectId =>
Handler.String_Value ("canHaveObjectId");
when Enum.hasSideEffects =>
Handler.String_Value ("hasSideEffects");
when Enum.hasDataBreakpoint =>
Handler.String_Value ("hasDataBreakpoint");
end case;
end Output_VariablePresentationHint_attributes;

procedure Output_VariablePresentationHint_visibility
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.VariablePresentationHint_visibility) is
begin
case Value.Kind is
when Enum.Custom_Value =>
Handler.String_Value (Value.Custom_Value);

when Enum.public =>
Handler.String_Value ("public");
when Enum.a_private =>
Handler.String_Value ("private");
when Enum.a_protected =>
Handler.String_Value ("protected");
when Enum.internal =>
Handler.String_Value ("internal");
when Enum.final =>
Handler.String_Value ("final");
end case;
end Output_VariablePresentationHint_visibility;

procedure Output_InitializeRequestArguments_pathFormat
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.InitializeRequestArguments_pathFormat) is
begin
case Value.Kind is
when Enum.Custom_Value =>
Handler.String_Value (Value.Custom_Value);

when Enum.path =>
Handler.String_Value ("path");
when Enum.uri =>
Handler.String_Value ("uri");
end case;
end Output_InitializeRequestArguments_pathFormat;

procedure Output_ThreadEvent_reason
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.ThreadEvent_reason) is
begin
case Value.Kind is
when Enum.Custom_Value =>
Handler.String_Value (Value.Custom_Value);

when Enum.started =>
Handler.String_Value ("started");
when Enum.exited =>
Handler.String_Value ("exited");
end case;
end Output_ThreadEvent_reason;

procedure Output_DataBreakpointAccessType
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.DataBreakpointAccessType) is
begin
case Value is
when Enum.read =>
Handler.String_Value ("read");
when Enum.write =>
Handler.String_Value ("write");
when Enum.readWrite =>
Handler.String_Value ("readWrite");
end case;
end Output_DataBreakpointAccessType;

procedure Output_BreakpointEvent_reason
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.BreakpointEvent_reason) is
begin
case Value.Kind is
when Enum.Custom_Value =>
Handler.String_Value (Value.Custom_Value);

when Enum.changed =>
Handler.String_Value ("changed");
when Enum.a_new =>
Handler.String_Value ("new");
when Enum.removed =>
Handler.String_Value ("removed");
end case;
end Output_BreakpointEvent_reason;

procedure Output_EvaluateArguments_context
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.EvaluateArguments_context) is
begin
case Value.Kind is
when Enum.Custom_Value =>
Handler.String_Value (Value.Custom_Value);

when Enum.watch =>
Handler.String_Value ("watch");
when Enum.repl =>
Handler.String_Value ("repl");
when Enum.hover =>
Handler.String_Value ("hover");
when Enum.clipboard =>
Handler.String_Value ("clipboard");
when Enum.variables =>
Handler.String_Value ("variables");
end case;
end Output_EvaluateArguments_context;

procedure Output_SteppingGranularity
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.SteppingGranularity) is
begin
case Value is
when Enum.statement =>
Handler.String_Value ("statement");
when Enum.line =>
Handler.String_Value ("line");
when Enum.instruction =>
Handler.String_Value ("instruction");
end case;
end Output_SteppingGranularity;

procedure Output_GotoResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : GotoResponse) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
if not Value.a_body.Is_Empty then
Handler.Key_Name ("body");
Output_Any_Value (Handler, Value.a_body);
end if;
Handler.End_Object;
end Output_GotoResponse;

procedure Output_ExceptionDetails
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ExceptionDetails) is
begin
Handler.Start_Object;
if not Value.message.Is_Null then
Handler.Key_Name ("message");
Handler.String_Value (Value.message);
end if;
if not Value.typeName.Is_Null then
Handler.Key_Name ("typeName");
Handler.String_Value (Value.typeName);
end if;
if not Value.fullTypeName.Is_Null then
Handler.Key_Name ("fullTypeName");
Handler.String_Value (Value.fullTypeName);
end if;
if not Value.evaluateName.Is_Null then
Handler.Key_Name ("evaluateName");
Handler.String_Value (Value.evaluateName);
end if;
if not Value.stackTrace.Is_Null then
Handler.Key_Name ("stackTrace");
Handler.String_Value (Value.stackTrace);
end if;
if Value.innerException.Length > 0 then
Handler.Key_Name ("innerException");
Handler.Start_Array;
for J in 1 .. Value.innerException.Length loop
Output_ExceptionDetails (Handler, Value.innerException (J));
end loop;
Handler.End_Array;
end if;
Handler.End_Object;
end Output_ExceptionDetails;

procedure Output_StepInTargetsRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StepInTargetsRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("stepInTargets");
Handler.Key_Name ("arguments");
Output_StepInTargetsArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_StepInTargetsRequest;

procedure Output_ModulesResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ModulesResponse) is
procedure Output_ModulesResponse_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ModulesResponse_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("modules");
Handler.Start_Array;
for J in 1 .. Value.modules.Length loop
Output_Module (Handler, Value.modules (J));
end loop;
Handler.End_Array;
if Value.totalModules.Is_Set then
Handler.Key_Name ("totalModules");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.totalModules.Value)));
end if;
Handler.End_Object;
end Output_ModulesResponse_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
Handler.Key_Name ("body");
Output_ModulesResponse_body (Handler, Value.a_body);
Handler.End_Object;
end Output_ModulesResponse;

procedure Output_NextArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : NextArguments) is
begin
Handler.Start_Object;
Handler.Key_Name ("threadId");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.threadId)));
if Value.singleThread then
Handler.Key_Name ("singleThread");
Handler.Boolean_Value (Value.singleThread);
end if;
if Value.granularity.Is_Set then
Handler.Key_Name ("granularity");
Output_SteppingGranularity (Handler, Value.granularity.Value);
end if;
Handler.End_Object;
end Output_NextArguments;

procedure Output_ExceptionInfoRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ExceptionInfoRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("exceptionInfo");
Handler.Key_Name ("arguments");
Output_ExceptionInfoArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_ExceptionInfoRequest;

procedure Output_TerminateThreadsArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : TerminateThreadsArguments) is
begin
Handler.Start_Object;
if Value.threadIds.Length > 0 then
Handler.Key_Name ("threadIds");
Handler.Start_Array;
for J in 1 .. Value.threadIds.Length loop
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.threadIds (J))));
end loop;
Handler.End_Array;
end if;
Handler.End_Object;
end Output_TerminateThreadsArguments;

procedure Output_DataBreakpointInfoRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : DataBreakpointInfoRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("dataBreakpointInfo");
Handler.Key_Name ("arguments");
Output_DataBreakpointInfoArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_DataBreakpointInfoRequest;

procedure Output_TerminateThreadsRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : TerminateThreadsRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("terminateThreads");
Handler.Key_Name ("arguments");
Output_TerminateThreadsArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_TerminateThreadsRequest;

procedure Output_SetBreakpointsArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetBreakpointsArguments) is
begin
Handler.Start_Object;
Handler.Key_Name ("source");
Output_Source (Handler, Value.source);
if Value.breakpoints.Length > 0 then
Handler.Key_Name ("breakpoints");
Handler.Start_Array;
for J in 1 .. Value.breakpoints.Length loop
Output_SourceBreakpoint (Handler, Value.breakpoints (J));
end loop;
Handler.End_Array;
end if;
if Value.lines.Length > 0 then
Handler.Key_Name ("lines");
Handler.Start_Array;
for J in 1 .. Value.lines.Length loop
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.lines (J))));
end loop;
Handler.End_Array;
end if;
if Value.sourceModified then
Handler.Key_Name ("sourceModified");
Handler.Boolean_Value (Value.sourceModified);
end if;
Handler.End_Object;
end Output_SetBreakpointsArguments;

procedure Output_ModuleEvent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ModuleEvent) is
procedure Output_ModuleEvent_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ModuleEvent_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("reason");
Output_ModuleEvent_reason (Handler, Value.reason);
Handler.Key_Name ("module");
Output_Module (Handler, Value.module);
Handler.End_Object;
end Output_ModuleEvent_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("event");
Handler.Key_Name ("event");Handler.String_Value ("module");
Handler.Key_Name ("body");
Output_ModuleEvent_body (Handler, Value.a_body);
Handler.End_Object;
end Output_ModuleEvent;

procedure Output_ContinuedEvent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ContinuedEvent) is
procedure Output_ContinuedEvent_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ContinuedEvent_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("threadId");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.threadId)));
if Value.allThreadsContinued then
Handler.Key_Name ("allThreadsContinued");
Handler.Boolean_Value (Value.allThreadsContinued);
end if;
Handler.End_Object;
end Output_ContinuedEvent_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("event");
Handler.Key_Name ("event");Handler.String_Value ("continued");
Handler.Key_Name ("body");
Output_ContinuedEvent_body (Handler, Value.a_body);
Handler.End_Object;
end Output_ContinuedEvent;

procedure Output_RestartArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : RestartArguments) is
begin
Handler.Start_Object;
if Value.arguments.Is_Set then
Handler.Key_Name ("arguments");
Output_AttachRequestArguments (Handler, Value.arguments.Value);
end if;
Handler.End_Object;
end Output_RestartArguments;

procedure Output_SetVariableArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetVariableArguments) is
begin
Handler.Start_Object;
Handler.Key_Name ("variablesReference");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.variablesReference)));
Handler.Key_Name ("name");
Handler.String_Value (Value.name);
Handler.Key_Name ("value");
Handler.String_Value (Value.value);
if Value.format.Is_Set then
Handler.Key_Name ("format");
Output_ValueFormat (Handler, Value.format.Value);
end if;
Handler.End_Object;
end Output_SetVariableArguments;

procedure Output_Checksum
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Checksum) is
begin
Handler.Start_Object;
Handler.Key_Name ("algorithm");
Output_ChecksumAlgorithm (Handler, Value.algorithm);
Handler.Key_Name ("checksum");
Handler.String_Value (Value.checksum);
Handler.End_Object;
end Output_Checksum;

procedure Output_BreakpointLocationsRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : BreakpointLocationsRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("breakpointLocations");
if Value.arguments.Is_Set then
Handler.Key_Name ("arguments");
Output_BreakpointLocationsArguments (Handler, Value.arguments.Value);
end if;
Handler.End_Object;
end Output_BreakpointLocationsRequest;

procedure Output_ModulesViewDescriptor
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ModulesViewDescriptor) is
begin
Handler.Start_Object;
Handler.Key_Name ("columns");
Handler.Start_Array;
for J in 1 .. Value.columns.Length loop
Output_ColumnDescriptor (Handler, Value.columns (J));
end loop;
Handler.End_Array;
Handler.End_Object;
end Output_ModulesViewDescriptor;

procedure Output_ColumnDescriptor
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ColumnDescriptor) is
begin
Handler.Start_Object;
Handler.Key_Name ("attributeName");
Handler.String_Value (Value.attributeName);
Handler.Key_Name ("label");
Handler.String_Value (Value.label);
if not Value.format.Is_Null then
Handler.Key_Name ("format");
Handler.String_Value (Value.format);
end if;
if Value.a_type.Is_Set then
Handler.Key_Name ("type");
Output_ColumnDescriptor_type (Handler, Value.a_type.Value);
end if;
if Value.width.Is_Set then
Handler.Key_Name ("width");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.width.Value)));
end if;
Handler.End_Object;
end Output_ColumnDescriptor;

procedure Output_Capabilities
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Capabilities) is
begin
Handler.Start_Object;
if Value.supportsConfigurationDoneRequest then
Handler.Key_Name ("supportsConfigurationDoneRequest");
Handler.Boolean_Value (Value.supportsConfigurationDoneRequest);
end if;
if Value.supportsFunctionBreakpoints then
Handler.Key_Name ("supportsFunctionBreakpoints");
Handler.Boolean_Value (Value.supportsFunctionBreakpoints);
end if;
if Value.supportsConditionalBreakpoints then
Handler.Key_Name ("supportsConditionalBreakpoints");
Handler.Boolean_Value (Value.supportsConditionalBreakpoints);
end if;
if Value.supportsHitConditionalBreakpoints then
Handler.Key_Name ("supportsHitConditionalBreakpoints");
Handler.Boolean_Value (Value.supportsHitConditionalBreakpoints);
end if;
if Value.supportsEvaluateForHovers then
Handler.Key_Name ("supportsEvaluateForHovers");
Handler.Boolean_Value (Value.supportsEvaluateForHovers);
end if;
if Value.exceptionBreakpointFilters.Length > 0 then
Handler.Key_Name ("exceptionBreakpointFilters");
Handler.Start_Array;
for J in 1 .. Value.exceptionBreakpointFilters.Length loop
Output_ExceptionBreakpointsFilter (Handler, Value.exceptionBreakpointFilters (J));
end loop;
Handler.End_Array;
end if;
if Value.supportsStepBack then
Handler.Key_Name ("supportsStepBack");
Handler.Boolean_Value (Value.supportsStepBack);
end if;
if Value.supportsSetVariable then
Handler.Key_Name ("supportsSetVariable");
Handler.Boolean_Value (Value.supportsSetVariable);
end if;
if Value.supportsRestartFrame then
Handler.Key_Name ("supportsRestartFrame");
Handler.Boolean_Value (Value.supportsRestartFrame);
end if;
if Value.supportsGotoTargetsRequest then
Handler.Key_Name ("supportsGotoTargetsRequest");
Handler.Boolean_Value (Value.supportsGotoTargetsRequest);
end if;
if Value.supportsStepInTargetsRequest then
Handler.Key_Name ("supportsStepInTargetsRequest");
Handler.Boolean_Value (Value.supportsStepInTargetsRequest);
end if;
if Value.supportsCompletionsRequest then
Handler.Key_Name ("supportsCompletionsRequest");
Handler.Boolean_Value (Value.supportsCompletionsRequest);
end if;
if not Value.completionTriggerCharacters.Is_Empty then
Handler.Key_Name ("completionTriggerCharacters");
Handler.Start_Array;
for J in 1 .. Value.completionTriggerCharacters.Length loop
Handler.String_Value (Value.completionTriggerCharacters (J));
end loop;
Handler.End_Array;
end if;
if Value.supportsModulesRequest then
Handler.Key_Name ("supportsModulesRequest");
Handler.Boolean_Value (Value.supportsModulesRequest);
end if;
if Value.additionalModuleColumns.Length > 0 then
Handler.Key_Name ("additionalModuleColumns");
Handler.Start_Array;
for J in 1 .. Value.additionalModuleColumns.Length loop
Output_ColumnDescriptor (Handler, Value.additionalModuleColumns (J));
end loop;
Handler.End_Array;
end if;
if Value.supportedChecksumAlgorithms.Length > 0 then
Handler.Key_Name ("supportedChecksumAlgorithms");
Handler.Start_Array;
for J in 1 .. Value.supportedChecksumAlgorithms.Length loop
Output_ChecksumAlgorithm (Handler, Value.supportedChecksumAlgorithms (J));
end loop;
Handler.End_Array;
end if;
if Value.supportsRestartRequest then
Handler.Key_Name ("supportsRestartRequest");
Handler.Boolean_Value (Value.supportsRestartRequest);
end if;
if Value.supportsExceptionOptions then
Handler.Key_Name ("supportsExceptionOptions");
Handler.Boolean_Value (Value.supportsExceptionOptions);
end if;
if Value.supportsValueFormattingOptions then
Handler.Key_Name ("supportsValueFormattingOptions");
Handler.Boolean_Value (Value.supportsValueFormattingOptions);
end if;
if Value.supportsExceptionInfoRequest then
Handler.Key_Name ("supportsExceptionInfoRequest");
Handler.Boolean_Value (Value.supportsExceptionInfoRequest);
end if;
if Value.supportTerminateDebuggee then
Handler.Key_Name ("supportTerminateDebuggee");
Handler.Boolean_Value (Value.supportTerminateDebuggee);
end if;
if Value.supportSuspendDebuggee then
Handler.Key_Name ("supportSuspendDebuggee");
Handler.Boolean_Value (Value.supportSuspendDebuggee);
end if;
if Value.supportsDelayedStackTraceLoading then
Handler.Key_Name ("supportsDelayedStackTraceLoading");
Handler.Boolean_Value (Value.supportsDelayedStackTraceLoading);
end if;
if Value.supportsLoadedSourcesRequest then
Handler.Key_Name ("supportsLoadedSourcesRequest");
Handler.Boolean_Value (Value.supportsLoadedSourcesRequest);
end if;
if Value.supportsLogPoints then
Handler.Key_Name ("supportsLogPoints");
Handler.Boolean_Value (Value.supportsLogPoints);
end if;
if Value.supportsTerminateThreadsRequest then
Handler.Key_Name ("supportsTerminateThreadsRequest");
Handler.Boolean_Value (Value.supportsTerminateThreadsRequest);
end if;
if Value.supportsSetExpression then
Handler.Key_Name ("supportsSetExpression");
Handler.Boolean_Value (Value.supportsSetExpression);
end if;
if Value.supportsTerminateRequest then
Handler.Key_Name ("supportsTerminateRequest");
Handler.Boolean_Value (Value.supportsTerminateRequest);
end if;
if Value.supportsDataBreakpoints then
Handler.Key_Name ("supportsDataBreakpoints");
Handler.Boolean_Value (Value.supportsDataBreakpoints);
end if;
if Value.supportsReadMemoryRequest then
Handler.Key_Name ("supportsReadMemoryRequest");
Handler.Boolean_Value (Value.supportsReadMemoryRequest);
end if;
if Value.supportsWriteMemoryRequest then
Handler.Key_Name ("supportsWriteMemoryRequest");
Handler.Boolean_Value (Value.supportsWriteMemoryRequest);
end if;
if Value.supportsDisassembleRequest then
Handler.Key_Name ("supportsDisassembleRequest");
Handler.Boolean_Value (Value.supportsDisassembleRequest);
end if;
if Value.supportsCancelRequest then
Handler.Key_Name ("supportsCancelRequest");
Handler.Boolean_Value (Value.supportsCancelRequest);
end if;
if Value.supportsBreakpointLocationsRequest then
Handler.Key_Name ("supportsBreakpointLocationsRequest");
Handler.Boolean_Value (Value.supportsBreakpointLocationsRequest);
end if;
if Value.supportsClipboardContext then
Handler.Key_Name ("supportsClipboardContext");
Handler.Boolean_Value (Value.supportsClipboardContext);
end if;
if Value.supportsSteppingGranularity then
Handler.Key_Name ("supportsSteppingGranularity");
Handler.Boolean_Value (Value.supportsSteppingGranularity);
end if;
if Value.supportsInstructionBreakpoints then
Handler.Key_Name ("supportsInstructionBreakpoints");
Handler.Boolean_Value (Value.supportsInstructionBreakpoints);
end if;
if Value.supportsExceptionFilterOptions then
Handler.Key_Name ("supportsExceptionFilterOptions");
Handler.Boolean_Value (Value.supportsExceptionFilterOptions);
end if;
if Value.supportsSingleThreadExecutionRequests then
Handler.Key_Name ("supportsSingleThreadExecutionRequests");
Handler.Boolean_Value (Value.supportsSingleThreadExecutionRequests);
end if;
Handler.End_Object;
end Output_Capabilities;

procedure Output_StackTraceResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StackTraceResponse) is
procedure Output_StackTraceResponse_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StackTraceResponse_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("stackFrames");
Handler.Start_Array;
for J in 1 .. Value.stackFrames.Length loop
Output_StackFrame (Handler, Value.stackFrames (J));
end loop;
Handler.End_Array;
if Value.totalFrames.Is_Set then
Handler.Key_Name ("totalFrames");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.totalFrames.Value)));
end if;
Handler.End_Object;
end Output_StackTraceResponse_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
Handler.Key_Name ("body");
Output_StackTraceResponse_body (Handler, Value.a_body);
Handler.End_Object;
end Output_StackTraceResponse;

procedure Output_LoadedSourcesArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : LoadedSourcesArguments) is
begin
Output_Any_Value (Handler, Value);
end Output_LoadedSourcesArguments;

procedure Output_ConfigurationDoneRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ConfigurationDoneRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("configurationDone");
if Value.arguments.Is_Set then
Handler.Key_Name ("arguments");
Output_ConfigurationDoneArguments (Handler, Value.arguments.Value);
end if;
Handler.End_Object;
end Output_ConfigurationDoneRequest;

procedure Output_StepInTargetsResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StepInTargetsResponse) is
procedure Output_StepInTargetsResponse_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StepInTargetsResponse_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("targets");
Handler.Start_Array;
for J in 1 .. Value.targets.Length loop
Output_StepInTarget (Handler, Value.targets (J));
end loop;
Handler.End_Array;
Handler.End_Object;
end Output_StepInTargetsResponse_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
Handler.Key_Name ("body");
Output_StepInTargetsResponse_body (Handler, Value.a_body);
Handler.End_Object;
end Output_StepInTargetsResponse;

procedure Output_StackFrame
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StackFrame) is
begin
Handler.Start_Object;
Handler.Key_Name ("id");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.id)));
Handler.Key_Name ("name");
Handler.String_Value (Value.name);
if Value.source.Is_Set then
Handler.Key_Name ("source");
Output_Source (Handler, Value.source.Value);
end if;
Handler.Key_Name ("line");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.line)));
Handler.Key_Name ("column");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.column)));
if Value.endLine.Is_Set then
Handler.Key_Name ("endLine");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.endLine.Value)));
end if;
if Value.endColumn.Is_Set then
Handler.Key_Name ("endColumn");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.endColumn.Value)));
end if;
if Value.canRestart then
Handler.Key_Name ("canRestart");
Handler.Boolean_Value (Value.canRestart);
end if;
if not Value.instructionPointerReference.Is_Null then
Handler.Key_Name ("instructionPointerReference");
Handler.String_Value (Value.instructionPointerReference);
end if;
if Value.moduleId.Is_Set then
Handler.Key_Name ("moduleId");
if Value.moduleId.Value.Is_String then
Handler.String_Value (Value.moduleId.Value.String);
else
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.moduleId.Value.Integer)));
end if;
end if;
if Value.presentationHint.Is_Set then
Handler.Key_Name ("presentationHint");
Output_StackFrame_presentationHint (Handler, Value.presentationHint.Value);
end if;
Handler.End_Object;
end Output_StackFrame;

procedure Output_SetExpressionRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetExpressionRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("setExpression");
Handler.Key_Name ("arguments");
Output_SetExpressionArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_SetExpressionRequest;

procedure Output_SourceArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SourceArguments) is
begin
Handler.Start_Object;
if Value.source.Is_Set then
Handler.Key_Name ("source");
Output_Source (Handler, Value.source.Value);
end if;
Handler.Key_Name ("sourceReference");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.sourceReference)));
Handler.End_Object;
end Output_SourceArguments;

procedure Output_ExceptionFilterOptions
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ExceptionFilterOptions) is
begin
Handler.Start_Object;
Handler.Key_Name ("filterId");
Handler.String_Value (Value.filterId);
if not Value.condition.Is_Null then
Handler.Key_Name ("condition");
Handler.String_Value (Value.condition);
end if;
Handler.End_Object;
end Output_ExceptionFilterOptions;

procedure Output_ExceptionBreakpointsFilter
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ExceptionBreakpointsFilter) is
begin
Handler.Start_Object;
Handler.Key_Name ("filter");
Handler.String_Value (Value.filter);
Handler.Key_Name ("label");
Handler.String_Value (Value.label);
if not Value.description.Is_Null then
Handler.Key_Name ("description");
Handler.String_Value (Value.description);
end if;
if Value.default then
Handler.Key_Name ("default");
Handler.Boolean_Value (Value.default);
end if;
if Value.supportsCondition then
Handler.Key_Name ("supportsCondition");
Handler.Boolean_Value (Value.supportsCondition);
end if;
if not Value.conditionDescription.Is_Null then
Handler.Key_Name ("conditionDescription");
Handler.String_Value (Value.conditionDescription);
end if;
Handler.End_Object;
end Output_ExceptionBreakpointsFilter;

procedure Output_SetVariableRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetVariableRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("setVariable");
Handler.Key_Name ("arguments");
Output_SetVariableArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_SetVariableRequest;

procedure Output_AttachRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : AttachRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("attach");
Handler.Key_Name ("arguments");
Output_AttachRequestArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_AttachRequest;

procedure Output_MemoryEvent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : MemoryEvent) is
procedure Output_MemoryEvent_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : MemoryEvent_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("memoryReference");
Handler.String_Value (Value.memoryReference);
Handler.Key_Name ("offset");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.offset)));
Handler.Key_Name ("count");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.count)));
Handler.End_Object;
end Output_MemoryEvent_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("event");
Handler.Key_Name ("event");Handler.String_Value ("memory");
Handler.Key_Name ("body");
Output_MemoryEvent_body (Handler, Value.a_body);
Handler.End_Object;
end Output_MemoryEvent;

procedure Output_ReadMemoryArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ReadMemoryArguments) is
begin
Handler.Start_Object;
Handler.Key_Name ("memoryReference");
Handler.String_Value (Value.memoryReference);
if Value.offset.Is_Set then
Handler.Key_Name ("offset");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.offset.Value)));
end if;
Handler.Key_Name ("count");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.count)));
Handler.End_Object;
end Output_ReadMemoryArguments;

procedure Output_LoadedSourcesRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : LoadedSourcesRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("loadedSources");
if Value.arguments.Is_Set then
Handler.Key_Name ("arguments");
Output_LoadedSourcesArguments (Handler, Value.arguments.Value);
end if;
Handler.End_Object;
end Output_LoadedSourcesRequest;

procedure Output_LaunchRequestArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : LaunchRequestArguments) is
begin
Handler.Start_Object;
if Value.noDebug then
Handler.Key_Name ("noDebug");
Handler.Boolean_Value (Value.noDebug);
end if;
if not Value.restart.Is_Empty then
Handler.Key_Name ("__restart");
Output_Any_Value (Handler, Value.restart);
end if;
if not Value.program.Is_Null then
Handler.Key_Name ("program");
Handler.String_Value (Value.program);
end if;
if not Value.args.Is_Empty then
Handler.Key_Name ("args");
Handler.Start_Array;
for J in 1 .. Value.args.Length loop
Handler.String_Value (Value.args (J));
end loop;
Handler.End_Array;
end if;
if not Value.cwd.Is_Null then
Handler.Key_Name ("cwd");
Handler.String_Value (Value.cwd);
end if;
if Value.stopAtBeginningOfMainSubprogram then
Handler.Key_Name ("stopAtBeginningOfMainSubprogram");
Handler.Boolean_Value (Value.stopAtBeginningOfMainSubprogram);
end if;
Handler.End_Object;
end Output_LaunchRequestArguments;

procedure Output_ExitedEvent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ExitedEvent) is
procedure Output_ExitedEvent_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ExitedEvent_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("exitCode");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.exitCode)));
Handler.End_Object;
end Output_ExitedEvent_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("event");
Handler.Key_Name ("event");Handler.String_Value ("exited");
Handler.Key_Name ("body");
Output_ExitedEvent_body (Handler, Value.a_body);
Handler.End_Object;
end Output_ExitedEvent;

procedure Output_SetBreakpointsRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetBreakpointsRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("setBreakpoints");
Handler.Key_Name ("arguments");
Output_SetBreakpointsArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_SetBreakpointsRequest;

procedure Output_TerminateResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : TerminateResponse) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
if not Value.a_body.Is_Empty then
Handler.Key_Name ("body");
Output_Any_Value (Handler, Value.a_body);
end if;
Handler.End_Object;
end Output_TerminateResponse;

procedure Output_Variable
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Variable) is
begin
Handler.Start_Object;
Handler.Key_Name ("name");
Handler.String_Value (Value.name);
Handler.Key_Name ("value");
Handler.String_Value (Value.value);
if not Value.a_type.Is_Null then
Handler.Key_Name ("type");
Handler.String_Value (Value.a_type);
end if;
if Value.presentationHint.Is_Set then
Handler.Key_Name ("presentationHint");
Output_VariablePresentationHint (Handler, Value.presentationHint.Value);
end if;
if not Value.evaluateName.Is_Null then
Handler.Key_Name ("evaluateName");
Handler.String_Value (Value.evaluateName);
end if;
Handler.Key_Name ("variablesReference");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.variablesReference)));
if Value.namedVariables.Is_Set then
Handler.Key_Name ("namedVariables");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.namedVariables.Value)));
end if;
if Value.indexedVariables.Is_Set then
Handler.Key_Name ("indexedVariables");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.indexedVariables.Value)));
end if;
if not Value.memoryReference.Is_Null then
Handler.Key_Name ("memoryReference");
Handler.String_Value (Value.memoryReference);
end if;
Handler.End_Object;
end Output_Variable;

procedure Output_StoppedEvent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StoppedEvent) is
procedure Output_StoppedEvent_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StoppedEvent_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("reason");
Output_StoppedEvent_reason (Handler, Value.reason);
if not Value.description.Is_Null then
Handler.Key_Name ("description");
Handler.String_Value (Value.description);
end if;
if Value.threadId.Is_Set then
Handler.Key_Name ("threadId");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.threadId.Value)));
end if;
if Value.preserveFocusHint then
Handler.Key_Name ("preserveFocusHint");
Handler.Boolean_Value (Value.preserveFocusHint);
end if;
if not Value.text.Is_Null then
Handler.Key_Name ("text");
Handler.String_Value (Value.text);
end if;
if Value.allThreadsStopped then
Handler.Key_Name ("allThreadsStopped");
Handler.Boolean_Value (Value.allThreadsStopped);
end if;
if Value.hitBreakpointIds.Length > 0 then
Handler.Key_Name ("hitBreakpointIds");
Handler.Start_Array;
for J in 1 .. Value.hitBreakpointIds.Length loop
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.hitBreakpointIds (J))));
end loop;
Handler.End_Array;
end if;
Handler.End_Object;
end Output_StoppedEvent_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("event");
Handler.Key_Name ("event");Handler.String_Value ("stopped");
Handler.Key_Name ("body");
Output_StoppedEvent_body (Handler, Value.a_body);
Handler.End_Object;
end Output_StoppedEvent;

procedure Output_RestartFrameRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : RestartFrameRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("restartFrame");
Handler.Key_Name ("arguments");
Output_RestartFrameArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_RestartFrameRequest;

procedure Output_AttachRequestArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : AttachRequestArguments) is
begin
Handler.Start_Object;
if not Value.restart.Is_Empty then
Handler.Key_Name ("__restart");
Output_Any_Value (Handler, Value.restart);
end if;
if Value.pid.Is_Set then
Handler.Key_Name ("pid");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.pid.Value)));
end if;
if not Value.target.Is_Null then
Handler.Key_Name ("target");
Handler.String_Value (Value.target);
end if;
Handler.End_Object;
end Output_AttachRequestArguments;

procedure Output_ScopesResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ScopesResponse) is
procedure Output_ScopesResponse_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ScopesResponse_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("scopes");
Handler.Start_Array;
for J in 1 .. Value.scopes.Length loop
Output_Scope (Handler, Value.scopes (J));
end loop;
Handler.End_Array;
Handler.End_Object;
end Output_ScopesResponse_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
Handler.Key_Name ("body");
Output_ScopesResponse_body (Handler, Value.a_body);
Handler.End_Object;
end Output_ScopesResponse;

procedure Output_StepOutArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StepOutArguments) is
begin
Handler.Start_Object;
Handler.Key_Name ("threadId");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.threadId)));
if Value.singleThread then
Handler.Key_Name ("singleThread");
Handler.Boolean_Value (Value.singleThread);
end if;
if Value.granularity.Is_Set then
Handler.Key_Name ("granularity");
Output_SteppingGranularity (Handler, Value.granularity.Value);
end if;
Handler.End_Object;
end Output_StepOutArguments;

procedure Output_CompletionsRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : CompletionsRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("completions");
Handler.Key_Name ("arguments");
Output_CompletionsArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_CompletionsRequest;

procedure Output_StartDebuggingRequestArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StartDebuggingRequestArguments) is
begin
Handler.Start_Object;
Handler.Key_Name ("configuration");
Output_Any_Value (Handler, Value.configuration);
Handler.Key_Name ("request");
Output_StartDebuggingRequestArguments_request (Handler, Value.request);
Handler.End_Object;
end Output_StartDebuggingRequestArguments;

procedure Output_ProgressUpdateEvent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ProgressUpdateEvent) is
procedure Output_ProgressUpdateEvent_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ProgressUpdateEvent_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("progressId");
Handler.String_Value (Value.progressId);
if not Value.message.Is_Null then
Handler.Key_Name ("message");
Handler.String_Value (Value.message);
end if;
if Value.percentage.Is_Set then
Handler.Key_Name ("percentage");
Handler.Float_Value(Interfaces.IEEE_Float_64 (Value.percentage.Value));
end if;
Handler.End_Object;
end Output_ProgressUpdateEvent_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("event");
Handler.Key_Name ("event");Handler.String_Value ("progressUpdate");
Handler.Key_Name ("body");
Output_ProgressUpdateEvent_body (Handler, Value.a_body);
Handler.End_Object;
end Output_ProgressUpdateEvent;

procedure Output_ExceptionInfoResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ExceptionInfoResponse) is
procedure Output_ExceptionInfoResponse_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ExceptionInfoResponse_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("exceptionId");
Handler.String_Value (Value.exceptionId);
if not Value.description.Is_Null then
Handler.Key_Name ("description");
Handler.String_Value (Value.description);
end if;
Handler.Key_Name ("breakMode");
Output_ExceptionBreakMode (Handler, Value.breakMode);
if Value.details.Is_Set then
Handler.Key_Name ("details");
Output_ExceptionDetails (Handler, Value.details.Value);
end if;
Handler.End_Object;
end Output_ExceptionInfoResponse_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
Handler.Key_Name ("body");
Output_ExceptionInfoResponse_body (Handler, Value.a_body);
Handler.End_Object;
end Output_ExceptionInfoResponse;

procedure Output_InitializedEvent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : InitializedEvent) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("event");
Handler.Key_Name ("event");Handler.String_Value ("initialized");
if not Value.a_body.Is_Empty then
Handler.Key_Name ("body");
Output_Any_Value (Handler, Value.a_body);
end if;
Handler.End_Object;
end Output_InitializedEvent;

procedure Output_SetExpressionResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetExpressionResponse) is
procedure Output_SetExpressionResponse_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetExpressionResponse_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("value");
Handler.String_Value (Value.value);
if not Value.a_type.Is_Null then
Handler.Key_Name ("type");
Handler.String_Value (Value.a_type);
end if;
if Value.presentationHint.Is_Set then
Handler.Key_Name ("presentationHint");
Output_VariablePresentationHint (Handler, Value.presentationHint.Value);
end if;
if Value.variablesReference.Is_Set then
Handler.Key_Name ("variablesReference");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.variablesReference.Value)));
end if;
if Value.namedVariables.Is_Set then
Handler.Key_Name ("namedVariables");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.namedVariables.Value)));
end if;
if Value.indexedVariables.Is_Set then
Handler.Key_Name ("indexedVariables");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.indexedVariables.Value)));
end if;
Handler.End_Object;
end Output_SetExpressionResponse_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
Handler.Key_Name ("body");
Output_SetExpressionResponse_body (Handler, Value.a_body);
Handler.End_Object;
end Output_SetExpressionResponse;

procedure Output_StepInTarget
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StepInTarget) is
begin
Handler.Start_Object;
Handler.Key_Name ("id");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.id)));
Handler.Key_Name ("label");
Handler.String_Value (Value.label);
if Value.line.Is_Set then
Handler.Key_Name ("line");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.line.Value)));
end if;
if Value.column.Is_Set then
Handler.Key_Name ("column");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.column.Value)));
end if;
if Value.endLine.Is_Set then
Handler.Key_Name ("endLine");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.endLine.Value)));
end if;
if Value.endColumn.Is_Set then
Handler.Key_Name ("endColumn");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.endColumn.Value)));
end if;
Handler.End_Object;
end Output_StepInTarget;

procedure Output_ReverseContinueResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ReverseContinueResponse) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
if not Value.a_body.Is_Empty then
Handler.Key_Name ("body");
Output_Any_Value (Handler, Value.a_body);
end if;
Handler.End_Object;
end Output_ReverseContinueResponse;

procedure Output_OutputEvent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : OutputEvent) is
procedure Output_OutputEvent_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : OutputEvent_body) is
begin
Handler.Start_Object;
if Value.category.Is_Set then
Handler.Key_Name ("category");
Output_OutputEvent_category (Handler, Value.category.Value);
end if;
Handler.Key_Name ("output");
Handler.String_Value (Value.output);
if Value.group.Is_Set then
Handler.Key_Name ("group");
Output_OutputEvent_group (Handler, Value.group.Value);
end if;
if Value.variablesReference.Is_Set then
Handler.Key_Name ("variablesReference");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.variablesReference.Value)));
end if;
if Value.source.Is_Set then
Handler.Key_Name ("source");
Output_Source (Handler, Value.source.Value);
end if;
if Value.line.Is_Set then
Handler.Key_Name ("line");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.line.Value)));
end if;
if Value.column.Is_Set then
Handler.Key_Name ("column");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.column.Value)));
end if;
if not Value.data.Is_Empty then
Handler.Key_Name ("data");
Output_Any_Value (Handler, Value.data);
end if;
Handler.End_Object;
end Output_OutputEvent_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("event");
Handler.Key_Name ("event");Handler.String_Value ("output");
Handler.Key_Name ("body");
Output_OutputEvent_body (Handler, Value.a_body);
Handler.End_Object;
end Output_OutputEvent;

procedure Output_RestartRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : RestartRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("restart");
if Value.arguments.Is_Set then
Handler.Key_Name ("arguments");
Output_RestartArguments (Handler, Value.arguments.Value);
end if;
Handler.End_Object;
end Output_RestartRequest;

procedure Output_StackTraceArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StackTraceArguments) is
begin
Handler.Start_Object;
Handler.Key_Name ("threadId");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.threadId)));
if Value.startFrame.Is_Set then
Handler.Key_Name ("startFrame");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.startFrame.Value)));
end if;
if Value.levels.Is_Set then
Handler.Key_Name ("levels");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.levels.Value)));
end if;
if Value.format.Is_Set then
Handler.Key_Name ("format");
Output_StackFrameFormat (Handler, Value.format.Value);
end if;
Handler.End_Object;
end Output_StackTraceArguments;

procedure Output_Thread
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Thread) is
begin
Handler.Start_Object;
Handler.Key_Name ("id");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.id)));
Handler.Key_Name ("name");
Handler.String_Value (Value.name);
Handler.End_Object;
end Output_Thread;

procedure Output_SetDataBreakpointsRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetDataBreakpointsRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("setDataBreakpoints");
Handler.Key_Name ("arguments");
Output_SetDataBreakpointsArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_SetDataBreakpointsRequest;

procedure Output_SourceRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SourceRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("source");
Handler.Key_Name ("arguments");
Output_SourceArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_SourceRequest;

procedure Output_PauseResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : PauseResponse) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
if not Value.a_body.Is_Empty then
Handler.Key_Name ("body");
Output_Any_Value (Handler, Value.a_body);
end if;
Handler.End_Object;
end Output_PauseResponse;

procedure Output_SetFunctionBreakpointsRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetFunctionBreakpointsRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("setFunctionBreakpoints");
Handler.Key_Name ("arguments");
Output_SetFunctionBreakpointsArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_SetFunctionBreakpointsRequest;

procedure Output_ProcessEvent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ProcessEvent) is
procedure Output_ProcessEvent_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ProcessEvent_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("name");
Handler.String_Value (Value.name);
if Value.systemProcessId.Is_Set then
Handler.Key_Name ("systemProcessId");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.systemProcessId.Value)));
end if;
if Value.isLocalProcess then
Handler.Key_Name ("isLocalProcess");
Handler.Boolean_Value (Value.isLocalProcess);
end if;
if Value.startMethod.Is_Set then
Handler.Key_Name ("startMethod");
Output_ProcessEvent_startMethod (Handler, Value.startMethod.Value);
end if;
if Value.pointerSize.Is_Set then
Handler.Key_Name ("pointerSize");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.pointerSize.Value)));
end if;
Handler.End_Object;
end Output_ProcessEvent_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("event");
Handler.Key_Name ("event");Handler.String_Value ("process");
Handler.Key_Name ("body");
Output_ProcessEvent_body (Handler, Value.a_body);
Handler.End_Object;
end Output_ProcessEvent;

procedure Output_NextResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : NextResponse) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
if not Value.a_body.Is_Empty then
Handler.Key_Name ("body");
Output_Any_Value (Handler, Value.a_body);
end if;
Handler.End_Object;
end Output_NextResponse;

procedure Output_AttachResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : AttachResponse) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
if not Value.a_body.Is_Empty then
Handler.Key_Name ("body");
Output_Any_Value (Handler, Value.a_body);
end if;
Handler.End_Object;
end Output_AttachResponse;

procedure Output_RestartResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : RestartResponse) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
if not Value.a_body.Is_Empty then
Handler.Key_Name ("body");
Output_Any_Value (Handler, Value.a_body);
end if;
Handler.End_Object;
end Output_RestartResponse;

procedure Output_CapabilitiesEvent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : CapabilitiesEvent) is
procedure Output_CapabilitiesEvent_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : CapabilitiesEvent_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("capabilities");
Output_Capabilities (Handler, Value.capabilities);
Handler.End_Object;
end Output_CapabilitiesEvent_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("event");
Handler.Key_Name ("event");Handler.String_Value ("capabilities");
Handler.Key_Name ("body");
Output_CapabilitiesEvent_body (Handler, Value.a_body);
Handler.End_Object;
end Output_CapabilitiesEvent;

procedure Output_Scope
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Scope) is
begin
Handler.Start_Object;
Handler.Key_Name ("name");
Handler.String_Value (Value.name);
if Value.presentationHint.Is_Set then
Handler.Key_Name ("presentationHint");
Output_Scope_presentationHint (Handler, Value.presentationHint.Value);
end if;
Handler.Key_Name ("variablesReference");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.variablesReference)));
if Value.namedVariables.Is_Set then
Handler.Key_Name ("namedVariables");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.namedVariables.Value)));
end if;
if Value.indexedVariables.Is_Set then
Handler.Key_Name ("indexedVariables");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.indexedVariables.Value)));
end if;
Handler.Key_Name ("expensive");
Handler.Boolean_Value (Value.expensive);
if Value.source.Is_Set then
Handler.Key_Name ("source");
Output_Source (Handler, Value.source.Value);
end if;
if Value.line.Is_Set then
Handler.Key_Name ("line");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.line.Value)));
end if;
if Value.column.Is_Set then
Handler.Key_Name ("column");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.column.Value)));
end if;
if Value.endLine.Is_Set then
Handler.Key_Name ("endLine");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.endLine.Value)));
end if;
if Value.endColumn.Is_Set then
Handler.Key_Name ("endColumn");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.endColumn.Value)));
end if;
Handler.End_Object;
end Output_Scope;

procedure Output_DisassembleArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : DisassembleArguments) is
begin
Handler.Start_Object;
Handler.Key_Name ("memoryReference");
Handler.String_Value (Value.memoryReference);
if Value.offset.Is_Set then
Handler.Key_Name ("offset");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.offset.Value)));
end if;
if Value.instructionOffset.Is_Set then
Handler.Key_Name ("instructionOffset");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.instructionOffset.Value)));
end if;
Handler.Key_Name ("instructionCount");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.instructionCount)));
if Value.resolveSymbols then
Handler.Key_Name ("resolveSymbols");
Handler.Boolean_Value (Value.resolveSymbols);
end if;
Handler.End_Object;
end Output_DisassembleArguments;

procedure Output_SetInstructionBreakpointsRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetInstructionBreakpointsRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("setInstructionBreakpoints");
Handler.Key_Name ("arguments");
Output_SetInstructionBreakpointsArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_SetInstructionBreakpointsRequest;

procedure Output_Response
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Response) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
if not Value.a_body.Is_Empty then
Handler.Key_Name ("body");
Output_Any_Value (Handler, Value.a_body);
end if;
Handler.End_Object;
end Output_Response;

procedure Output_DataBreakpointInfoResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : DataBreakpointInfoResponse) is
procedure Output_DataBreakpointInfoResponse_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : DataBreakpointInfoResponse_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("dataId");
Handler.String_Value (Value.dataId);
Handler.Key_Name ("description");
Handler.String_Value (Value.description);
if Value.accessTypes.Length > 0 then
Handler.Key_Name ("accessTypes");
Handler.Start_Array;
for J in 1 .. Value.accessTypes.Length loop
Output_DataBreakpointAccessType (Handler, Value.accessTypes (J));
end loop;
Handler.End_Array;
end if;
if Value.canPersist then
Handler.Key_Name ("canPersist");
Handler.Boolean_Value (Value.canPersist);
end if;
Handler.End_Object;
end Output_DataBreakpointInfoResponse_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
Handler.Key_Name ("body");
Output_DataBreakpointInfoResponse_body (Handler, Value.a_body);
Handler.End_Object;
end Output_DataBreakpointInfoResponse;

procedure Output_SourceBreakpoint
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SourceBreakpoint) is
begin
Handler.Start_Object;
Handler.Key_Name ("line");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.line)));
if Value.column.Is_Set then
Handler.Key_Name ("column");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.column.Value)));
end if;
if not Value.condition.Is_Null then
Handler.Key_Name ("condition");
Handler.String_Value (Value.condition);
end if;
if not Value.hitCondition.Is_Null then
Handler.Key_Name ("hitCondition");
Handler.String_Value (Value.hitCondition);
end if;
if not Value.logMessage.Is_Null then
Handler.Key_Name ("logMessage");
Handler.String_Value (Value.logMessage);
end if;
Handler.End_Object;
end Output_SourceBreakpoint;

procedure Output_PauseRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : PauseRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("pause");
Handler.Key_Name ("arguments");
Output_PauseArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_PauseRequest;

procedure Output_FunctionBreakpoint
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : FunctionBreakpoint) is
begin
Handler.Start_Object;
Handler.Key_Name ("name");
Handler.String_Value (Value.name);
if not Value.condition.Is_Null then
Handler.Key_Name ("condition");
Handler.String_Value (Value.condition);
end if;
if not Value.hitCondition.Is_Null then
Handler.Key_Name ("hitCondition");
Handler.String_Value (Value.hitCondition);
end if;
Handler.End_Object;
end Output_FunctionBreakpoint;

procedure Output_SetExpressionArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetExpressionArguments) is
begin
Handler.Start_Object;
Handler.Key_Name ("expression");
Handler.String_Value (Value.expression);
Handler.Key_Name ("value");
Handler.String_Value (Value.value);
if Value.frameId.Is_Set then
Handler.Key_Name ("frameId");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.frameId.Value)));
end if;
if Value.format.Is_Set then
Handler.Key_Name ("format");
Output_ValueFormat (Handler, Value.format.Value);
end if;
Handler.End_Object;
end Output_SetExpressionArguments;

procedure Output_SetExceptionBreakpointsArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetExceptionBreakpointsArguments) is
begin
Handler.Start_Object;
Handler.Key_Name ("filters");
Handler.Start_Array;
for J in 1 .. Value.filters.Length loop
Handler.String_Value (Value.filters (J));
end loop;
Handler.End_Array;
if Value.filterOptions.Length > 0 then
Handler.Key_Name ("filterOptions");
Handler.Start_Array;
for J in 1 .. Value.filterOptions.Length loop
Output_ExceptionFilterOptions (Handler, Value.filterOptions (J));
end loop;
Handler.End_Array;
end if;
if Value.exceptionOptions.Length > 0 then
Handler.Key_Name ("exceptionOptions");
Handler.Start_Array;
for J in 1 .. Value.exceptionOptions.Length loop
Output_ExceptionOptions (Handler, Value.exceptionOptions (J));
end loop;
Handler.End_Array;
end if;
Handler.End_Object;
end Output_SetExceptionBreakpointsArguments;

procedure Output_ValueFormat
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ValueFormat) is
begin
Handler.Start_Object;
if Value.hex then
Handler.Key_Name ("hex");
Handler.Boolean_Value (Value.hex);
end if;
Handler.End_Object;
end Output_ValueFormat;

procedure Output_RunInTerminalRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : RunInTerminalRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("runInTerminal");
Handler.Key_Name ("arguments");
Output_RunInTerminalRequestArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_RunInTerminalRequest;

procedure Output_CompletionsArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : CompletionsArguments) is
begin
Handler.Start_Object;
if Value.frameId.Is_Set then
Handler.Key_Name ("frameId");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.frameId.Value)));
end if;
Handler.Key_Name ("text");
Handler.String_Value (Value.text);
Handler.Key_Name ("column");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.column)));
if Value.line.Is_Set then
Handler.Key_Name ("line");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.line.Value)));
end if;
Handler.End_Object;
end Output_CompletionsArguments;

procedure Output_WriteMemoryResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : WriteMemoryResponse) is
procedure Output_WriteMemoryResponse_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : WriteMemoryResponse_body) is
begin
Handler.Start_Object;
if Value.offset.Is_Set then
Handler.Key_Name ("offset");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.offset.Value)));
end if;
if Value.bytesWritten.Is_Set then
Handler.Key_Name ("bytesWritten");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.bytesWritten.Value)));
end if;
Handler.End_Object;
end Output_WriteMemoryResponse_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
if Value.a_body.Is_Set then
Handler.Key_Name ("body");
Output_WriteMemoryResponse_body (Handler, Value.a_body.Value);
end if;
Handler.End_Object;
end Output_WriteMemoryResponse;

procedure Output_ReverseContinueArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ReverseContinueArguments) is
begin
Handler.Start_Object;
Handler.Key_Name ("threadId");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.threadId)));
if Value.singleThread then
Handler.Key_Name ("singleThread");
Handler.Boolean_Value (Value.singleThread);
end if;
Handler.End_Object;
end Output_ReverseContinueArguments;

procedure Output_RunInTerminalResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : RunInTerminalResponse) is
procedure Output_RunInTerminalResponse_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : RunInTerminalResponse_body) is
begin
Handler.Start_Object;
if Value.processId.Is_Set then
Handler.Key_Name ("processId");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.processId.Value)));
end if;
if Value.shellProcessId.Is_Set then
Handler.Key_Name ("shellProcessId");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.shellProcessId.Value)));
end if;
Handler.End_Object;
end Output_RunInTerminalResponse_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
Handler.Key_Name ("body");
Output_RunInTerminalResponse_body (Handler, Value.a_body);
Handler.End_Object;
end Output_RunInTerminalResponse;

procedure Output_DisconnectArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : DisconnectArguments) is
begin
Handler.Start_Object;
if Value.restart then
Handler.Key_Name ("restart");
Handler.Boolean_Value (Value.restart);
end if;
if Value.terminateDebuggee then
Handler.Key_Name ("terminateDebuggee");
Handler.Boolean_Value (Value.terminateDebuggee);
end if;
if Value.suspendDebuggee then
Handler.Key_Name ("suspendDebuggee");
Handler.Boolean_Value (Value.suspendDebuggee);
end if;
Handler.End_Object;
end Output_DisconnectArguments;

procedure Output_Module
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Module) is
begin
Handler.Start_Object;
Handler.Key_Name ("id");
if Value.id.Is_String then
Handler.String_Value (Value.id.String);
else
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.id.Integer)));
end if;
Handler.Key_Name ("name");
Handler.String_Value (Value.name);
if not Value.path.Is_Null then
Handler.Key_Name ("path");
Handler.String_Value (Value.path);
end if;
if Value.isOptimized then
Handler.Key_Name ("isOptimized");
Handler.Boolean_Value (Value.isOptimized);
end if;
if Value.isUserCode then
Handler.Key_Name ("isUserCode");
Handler.Boolean_Value (Value.isUserCode);
end if;
if not Value.version.Is_Null then
Handler.Key_Name ("version");
Handler.String_Value (Value.version);
end if;
if not Value.symbolStatus.Is_Null then
Handler.Key_Name ("symbolStatus");
Handler.String_Value (Value.symbolStatus);
end if;
if not Value.symbolFilePath.Is_Null then
Handler.Key_Name ("symbolFilePath");
Handler.String_Value (Value.symbolFilePath);
end if;
if not Value.dateTimeStamp.Is_Null then
Handler.Key_Name ("dateTimeStamp");
Handler.String_Value (Value.dateTimeStamp);
end if;
if not Value.addressRange.Is_Null then
Handler.Key_Name ("addressRange");
Handler.String_Value (Value.addressRange);
end if;
Handler.End_Object;
end Output_Module;

procedure Output_GotoTargetsRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : GotoTargetsRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("gotoTargets");
Handler.Key_Name ("arguments");
Output_GotoTargetsArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_GotoTargetsRequest;

procedure Output_ThreadsResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ThreadsResponse) is
procedure Output_ThreadsResponse_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ThreadsResponse_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("threads");
Handler.Start_Array;
for J in 1 .. Value.threads.Length loop
Output_Thread (Handler, Value.threads (J));
end loop;
Handler.End_Array;
Handler.End_Object;
end Output_ThreadsResponse_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
Handler.Key_Name ("body");
Output_ThreadsResponse_body (Handler, Value.a_body);
Handler.End_Object;
end Output_ThreadsResponse;

procedure Output_SetDataBreakpointsResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetDataBreakpointsResponse) is
procedure Output_SetDataBreakpointsResponse_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetDataBreakpointsResponse_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("breakpoints");
Handler.Start_Array;
for J in 1 .. Value.breakpoints.Length loop
Output_Breakpoint (Handler, Value.breakpoints (J));
end loop;
Handler.End_Array;
Handler.End_Object;
end Output_SetDataBreakpointsResponse_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
Handler.Key_Name ("body");
Output_SetDataBreakpointsResponse_body (Handler, Value.a_body);
Handler.End_Object;
end Output_SetDataBreakpointsResponse;

procedure Output_DataBreakpoint
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : DataBreakpoint) is
begin
Handler.Start_Object;
Handler.Key_Name ("dataId");
Handler.String_Value (Value.dataId);
if Value.accessType.Is_Set then
Handler.Key_Name ("accessType");
Output_DataBreakpointAccessType (Handler, Value.accessType.Value);
end if;
if not Value.condition.Is_Null then
Handler.Key_Name ("condition");
Handler.String_Value (Value.condition);
end if;
if not Value.hitCondition.Is_Null then
Handler.Key_Name ("hitCondition");
Handler.String_Value (Value.hitCondition);
end if;
Handler.End_Object;
end Output_DataBreakpoint;

procedure Output_SetDataBreakpointsArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetDataBreakpointsArguments) is
begin
Handler.Start_Object;
Handler.Key_Name ("breakpoints");
Handler.Start_Array;
for J in 1 .. Value.breakpoints.Length loop
Output_DataBreakpoint (Handler, Value.breakpoints (J));
end loop;
Handler.End_Array;
Handler.End_Object;
end Output_SetDataBreakpointsArguments;

procedure Output_ExceptionPathSegment
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ExceptionPathSegment) is
begin
Handler.Start_Object;
if Value.negate then
Handler.Key_Name ("negate");
Handler.Boolean_Value (Value.negate);
end if;
Handler.Key_Name ("names");
Handler.Start_Array;
for J in 1 .. Value.names.Length loop
Handler.String_Value (Value.names (J));
end loop;
Handler.End_Array;
Handler.End_Object;
end Output_ExceptionPathSegment;

procedure Output_Message
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Message) is
begin
Handler.Start_Object;
Handler.Key_Name ("id");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.id)));
Handler.Key_Name ("format");
Handler.String_Value (Value.format);
if not Value.variables.Is_Empty then
Handler.Key_Name ("variables");
Output_Any_Value (Handler, Value.variables);
end if;
if Value.sendTelemetry then
Handler.Key_Name ("sendTelemetry");
Handler.Boolean_Value (Value.sendTelemetry);
end if;
if Value.showUser then
Handler.Key_Name ("showUser");
Handler.Boolean_Value (Value.showUser);
end if;
if not Value.url.Is_Null then
Handler.Key_Name ("url");
Handler.String_Value (Value.url);
end if;
if not Value.urlLabel.Is_Null then
Handler.Key_Name ("urlLabel");
Handler.String_Value (Value.urlLabel);
end if;
Handler.End_Object;
end Output_Message;

procedure Output_SourceResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SourceResponse) is
procedure Output_SourceResponse_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SourceResponse_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("content");
Handler.String_Value (Value.content);
if not Value.mimeType.Is_Null then
Handler.Key_Name ("mimeType");
Handler.String_Value (Value.mimeType);
end if;
Handler.End_Object;
end Output_SourceResponse_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
Handler.Key_Name ("body");
Output_SourceResponse_body (Handler, Value.a_body);
Handler.End_Object;
end Output_SourceResponse;

procedure Output_ContinueResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ContinueResponse) is
procedure Output_ContinueResponse_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ContinueResponse_body) is
begin
Handler.Start_Object;
if Value.allThreadsContinued then
Handler.Key_Name ("allThreadsContinued");
Handler.Boolean_Value (Value.allThreadsContinued);
end if;
Handler.End_Object;
end Output_ContinueResponse_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
Handler.Key_Name ("body");
Output_ContinueResponse_body (Handler, Value.a_body);
Handler.End_Object;
end Output_ContinueResponse;

procedure Output_RestartFrameResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : RestartFrameResponse) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
if not Value.a_body.Is_Empty then
Handler.Key_Name ("body");
Output_Any_Value (Handler, Value.a_body);
end if;
Handler.End_Object;
end Output_RestartFrameResponse;

procedure Output_StepInArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StepInArguments) is
begin
Handler.Start_Object;
Handler.Key_Name ("threadId");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.threadId)));
if Value.singleThread then
Handler.Key_Name ("singleThread");
Handler.Boolean_Value (Value.singleThread);
end if;
if Value.targetId.Is_Set then
Handler.Key_Name ("targetId");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.targetId.Value)));
end if;
if Value.granularity.Is_Set then
Handler.Key_Name ("granularity");
Output_SteppingGranularity (Handler, Value.granularity.Value);
end if;
Handler.End_Object;
end Output_StepInArguments;

procedure Output_LaunchResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : LaunchResponse) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
if not Value.a_body.Is_Empty then
Handler.Key_Name ("body");
Output_Any_Value (Handler, Value.a_body);
end if;
Handler.End_Object;
end Output_LaunchResponse;

procedure Output_StepInResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StepInResponse) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
if not Value.a_body.Is_Empty then
Handler.Key_Name ("body");
Output_Any_Value (Handler, Value.a_body);
end if;
Handler.End_Object;
end Output_StepInResponse;

procedure Output_TerminateArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : TerminateArguments) is
begin
Handler.Start_Object;
if Value.restart then
Handler.Key_Name ("restart");
Handler.Boolean_Value (Value.restart);
end if;
Handler.End_Object;
end Output_TerminateArguments;

procedure Output_LaunchRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : LaunchRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("launch");
Handler.Key_Name ("arguments");
Output_LaunchRequestArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_LaunchRequest;

procedure Output_StepOutResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StepOutResponse) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
if not Value.a_body.Is_Empty then
Handler.Key_Name ("body");
Output_Any_Value (Handler, Value.a_body);
end if;
Handler.End_Object;
end Output_StepOutResponse;

procedure Output_EvaluateRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : EvaluateRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("evaluate");
Handler.Key_Name ("arguments");
Output_EvaluateArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_EvaluateRequest;

procedure Output_ContinueArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ContinueArguments) is
begin
Handler.Start_Object;
Handler.Key_Name ("threadId");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.threadId)));
if Value.singleThread then
Handler.Key_Name ("singleThread");
Handler.Boolean_Value (Value.singleThread);
end if;
Handler.End_Object;
end Output_ContinueArguments;

procedure Output_StepBackArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StepBackArguments) is
begin
Handler.Start_Object;
Handler.Key_Name ("threadId");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.threadId)));
if Value.singleThread then
Handler.Key_Name ("singleThread");
Handler.Boolean_Value (Value.singleThread);
end if;
if Value.granularity.Is_Set then
Handler.Key_Name ("granularity");
Output_SteppingGranularity (Handler, Value.granularity.Value);
end if;
Handler.End_Object;
end Output_StepBackArguments;

procedure Output_BreakpointLocationsArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : BreakpointLocationsArguments) is
begin
Handler.Start_Object;
Handler.Key_Name ("source");
Output_Source (Handler, Value.source);
Handler.Key_Name ("line");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.line)));
if Value.column.Is_Set then
Handler.Key_Name ("column");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.column.Value)));
end if;
if Value.endLine.Is_Set then
Handler.Key_Name ("endLine");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.endLine.Value)));
end if;
if Value.endColumn.Is_Set then
Handler.Key_Name ("endColumn");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.endColumn.Value)));
end if;
Handler.End_Object;
end Output_BreakpointLocationsArguments;

procedure Output_CancelArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : CancelArguments) is
begin
Handler.Start_Object;
if Value.requestId.Is_Set then
Handler.Key_Name ("requestId");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.requestId.Value)));
end if;
if not Value.progressId.Is_Null then
Handler.Key_Name ("progressId");
Handler.String_Value (Value.progressId);
end if;
Handler.End_Object;
end Output_CancelArguments;

procedure Output_CompletionsResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : CompletionsResponse) is
procedure Output_CompletionsResponse_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : CompletionsResponse_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("targets");
Handler.Start_Array;
for J in 1 .. Value.targets.Length loop
Output_CompletionItem (Handler, Value.targets (J));
end loop;
Handler.End_Array;
Handler.End_Object;
end Output_CompletionsResponse_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
Handler.Key_Name ("body");
Output_CompletionsResponse_body (Handler, Value.a_body);
Handler.End_Object;
end Output_CompletionsResponse;

procedure Output_Breakpoint
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Breakpoint) is
begin
Handler.Start_Object;
if Value.id.Is_Set then
Handler.Key_Name ("id");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.id.Value)));
end if;
Handler.Key_Name ("verified");
Handler.Boolean_Value (Value.verified);
if not Value.message.Is_Null then
Handler.Key_Name ("message");
Handler.String_Value (Value.message);
end if;
if Value.source.Is_Set then
Handler.Key_Name ("source");
Output_Source (Handler, Value.source.Value);
end if;
if Value.line.Is_Set then
Handler.Key_Name ("line");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.line.Value)));
end if;
if Value.column.Is_Set then
Handler.Key_Name ("column");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.column.Value)));
end if;
if Value.endLine.Is_Set then
Handler.Key_Name ("endLine");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.endLine.Value)));
end if;
if Value.endColumn.Is_Set then
Handler.Key_Name ("endColumn");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.endColumn.Value)));
end if;
if not Value.instructionReference.Is_Null then
Handler.Key_Name ("instructionReference");
Handler.String_Value (Value.instructionReference);
end if;
if Value.offset.Is_Set then
Handler.Key_Name ("offset");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.offset.Value)));
end if;
Handler.End_Object;
end Output_Breakpoint;

procedure Output_Source
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Source) is
begin
Handler.Start_Object;
if not Value.name.Is_Null then
Handler.Key_Name ("name");
Handler.String_Value (Value.name);
end if;
if not Value.path.Is_Null then
Handler.Key_Name ("path");
Handler.String_Value (Value.path);
end if;
if Value.sourceReference.Is_Set then
Handler.Key_Name ("sourceReference");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.sourceReference.Value)));
end if;
if Value.presentationHint.Is_Set then
Handler.Key_Name ("presentationHint");
Output_Source_presentationHint (Handler, Value.presentationHint.Value);
end if;
if not Value.origin.Is_Null then
Handler.Key_Name ("origin");
Handler.String_Value (Value.origin);
end if;
if Value.sources.Length > 0 then
Handler.Key_Name ("sources");
Handler.Start_Array;
for J in 1 .. Value.sources.Length loop
Output_Source (Handler, Value.sources (J));
end loop;
Handler.End_Array;
end if;
if not Value.adapterData.Is_Empty then
Handler.Key_Name ("adapterData");
Output_Any_Value (Handler, Value.adapterData);
end if;
if Value.checksums.Length > 0 then
Handler.Key_Name ("checksums");
Handler.Start_Array;
for J in 1 .. Value.checksums.Length loop
Output_Checksum (Handler, Value.checksums (J));
end loop;
Handler.End_Array;
end if;
Handler.End_Object;
end Output_Source;

procedure Output_WriteMemoryArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : WriteMemoryArguments) is
begin
Handler.Start_Object;
Handler.Key_Name ("memoryReference");
Handler.String_Value (Value.memoryReference);
if Value.offset.Is_Set then
Handler.Key_Name ("offset");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.offset.Value)));
end if;
if Value.allowPartial then
Handler.Key_Name ("allowPartial");
Handler.Boolean_Value (Value.allowPartial);
end if;
Handler.Key_Name ("data");
Handler.String_Value (Value.data);
Handler.End_Object;
end Output_WriteMemoryArguments;

procedure Output_ConfigurationDoneArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ConfigurationDoneArguments) is
begin
Output_Any_Value (Handler, Value);
end Output_ConfigurationDoneArguments;

procedure Output_StepOutRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StepOutRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("stepOut");
Handler.Key_Name ("arguments");
Output_StepOutArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_StepOutRequest;

procedure Output_Request
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Request) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if not Value.arguments.Is_Empty then
Handler.Key_Name ("arguments");
Output_Any_Value (Handler, Value.arguments);
end if;
Handler.End_Object;
end Output_Request;

procedure Output_LoadedSourceEvent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : LoadedSourceEvent) is
procedure Output_LoadedSourceEvent_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : LoadedSourceEvent_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("reason");
Output_LoadedSourceEvent_reason (Handler, Value.reason);
Handler.Key_Name ("source");
Output_Source (Handler, Value.source);
Handler.End_Object;
end Output_LoadedSourceEvent_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("event");
Handler.Key_Name ("event");Handler.String_Value ("loadedSource");
Handler.Key_Name ("body");
Output_LoadedSourceEvent_body (Handler, Value.a_body);
Handler.End_Object;
end Output_LoadedSourceEvent;

procedure Output_StackFrameFormat
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StackFrameFormat) is
begin
Handler.Start_Object;
if Value.hex then
Handler.Key_Name ("hex");
Handler.Boolean_Value (Value.hex);
end if;
if Value.parameters then
Handler.Key_Name ("parameters");
Handler.Boolean_Value (Value.parameters);
end if;
if Value.parameterTypes then
Handler.Key_Name ("parameterTypes");
Handler.Boolean_Value (Value.parameterTypes);
end if;
if Value.parameterNames then
Handler.Key_Name ("parameterNames");
Handler.Boolean_Value (Value.parameterNames);
end if;
if Value.parameterValues then
Handler.Key_Name ("parameterValues");
Handler.Boolean_Value (Value.parameterValues);
end if;
if Value.line then
Handler.Key_Name ("line");
Handler.Boolean_Value (Value.line);
end if;
if Value.module then
Handler.Key_Name ("module");
Handler.Boolean_Value (Value.module);
end if;
if Value.includeAll then
Handler.Key_Name ("includeAll");
Handler.Boolean_Value (Value.includeAll);
end if;
Handler.End_Object;
end Output_StackFrameFormat;

procedure Output_DisassembleRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : DisassembleRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("disassemble");
Handler.Key_Name ("arguments");
Output_DisassembleArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_DisassembleRequest;

procedure Output_ReadMemoryResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ReadMemoryResponse) is
procedure Output_ReadMemoryResponse_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ReadMemoryResponse_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("address");
Handler.String_Value (Value.address);
if Value.unreadableBytes.Is_Set then
Handler.Key_Name ("unreadableBytes");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.unreadableBytes.Value)));
end if;
if not Value.data.Is_Null then
Handler.Key_Name ("data");
Handler.String_Value (Value.data);
end if;
Handler.End_Object;
end Output_ReadMemoryResponse_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
if Value.a_body.Is_Set then
Handler.Key_Name ("body");
Output_ReadMemoryResponse_body (Handler, Value.a_body.Value);
end if;
Handler.End_Object;
end Output_ReadMemoryResponse;

procedure Output_StepBackRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StepBackRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("stepBack");
Handler.Key_Name ("arguments");
Output_StepBackArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_StepBackRequest;

procedure Output_ProtocolMessage
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ProtocolMessage) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");
Output_ProtocolMessage_type (Handler, Value.a_type);
Handler.End_Object;
end Output_ProtocolMessage;

procedure Output_ThreadsRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ThreadsRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("threads");
if not Value.arguments.Is_Empty then
Handler.Key_Name ("arguments");
Output_Any_Value (Handler, Value.arguments);
end if;
Handler.End_Object;
end Output_ThreadsRequest;

procedure Output_VariablesResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : VariablesResponse) is
procedure Output_VariablesResponse_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : VariablesResponse_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("variables");
Handler.Start_Array;
for J in 1 .. Value.variables.Length loop
Output_Variable (Handler, Value.variables (J));
end loop;
Handler.End_Array;
Handler.End_Object;
end Output_VariablesResponse_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
Handler.Key_Name ("body");
Output_VariablesResponse_body (Handler, Value.a_body);
Handler.End_Object;
end Output_VariablesResponse;

procedure Output_RunInTerminalRequestArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : RunInTerminalRequestArguments) is
begin
Handler.Start_Object;
if Value.kind.Is_Set then
Handler.Key_Name ("kind");
Output_RunInTerminalRequestArguments_kind (Handler, Value.kind.Value);
end if;
if not Value.title.Is_Null then
Handler.Key_Name ("title");
Handler.String_Value (Value.title);
end if;
Handler.Key_Name ("cwd");
Handler.String_Value (Value.cwd);
Handler.Key_Name ("args");
Handler.Start_Array;
for J in 1 .. Value.args.Length loop
Handler.String_Value (Value.args (J));
end loop;
Handler.End_Array;
if not Value.env.Is_Empty then
Handler.Key_Name ("env");
Output_Any_Value (Handler, Value.env);
end if;
if Value.argsCanBeInterpretedByShell then
Handler.Key_Name ("argsCanBeInterpretedByShell");
Handler.Boolean_Value (Value.argsCanBeInterpretedByShell);
end if;
Handler.End_Object;
end Output_RunInTerminalRequestArguments;

procedure Output_TerminateRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : TerminateRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("terminate");
if Value.arguments.Is_Set then
Handler.Key_Name ("arguments");
Output_TerminateArguments (Handler, Value.arguments.Value);
end if;
Handler.End_Object;
end Output_TerminateRequest;

procedure Output_VariablesArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : VariablesArguments) is
begin
Handler.Start_Object;
Handler.Key_Name ("variablesReference");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.variablesReference)));
if Value.filter.Is_Set then
Handler.Key_Name ("filter");
Output_VariablesArguments_filter (Handler, Value.filter.Value);
end if;
if Value.start.Is_Set then
Handler.Key_Name ("start");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.start.Value)));
end if;
if Value.count.Is_Set then
Handler.Key_Name ("count");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.count.Value)));
end if;
if Value.format.Is_Set then
Handler.Key_Name ("format");
Output_ValueFormat (Handler, Value.format.Value);
end if;
Handler.End_Object;
end Output_VariablesArguments;

procedure Output_InitializeRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : InitializeRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("initialize");
Handler.Key_Name ("arguments");
Output_InitializeRequestArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_InitializeRequest;

procedure Output_BreakpointLocationsResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : BreakpointLocationsResponse) is
procedure Output_BreakpointLocationsResponse_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : BreakpointLocationsResponse_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("breakpoints");
Handler.Start_Array;
for J in 1 .. Value.breakpoints.Length loop
Output_BreakpointLocation (Handler, Value.breakpoints (J));
end loop;
Handler.End_Array;
Handler.End_Object;
end Output_BreakpointLocationsResponse_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
Handler.Key_Name ("body");
Output_BreakpointLocationsResponse_body (Handler, Value.a_body);
Handler.End_Object;
end Output_BreakpointLocationsResponse;

procedure Output_VariablePresentationHint
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : VariablePresentationHint) is
begin
Handler.Start_Object;
if Value.kind.Is_Set then
Handler.Key_Name ("kind");
Output_VariablePresentationHint_kind (Handler, Value.kind.Value);
end if;
if Value.attributes.Length > 0 then
Handler.Key_Name ("attributes");
Handler.Start_Array;
for J in 1 .. Value.attributes.Length loop
Output_VariablePresentationHint_attributes (Handler, Value.attributes (J));
end loop;
Handler.End_Array;
end if;
if Value.visibility.Is_Set then
Handler.Key_Name ("visibility");
Output_VariablePresentationHint_visibility (Handler, Value.visibility.Value);
end if;
if Value.lazy then
Handler.Key_Name ("lazy");
Handler.Boolean_Value (Value.lazy);
end if;
Handler.End_Object;
end Output_VariablePresentationHint;

procedure Output_DisassembledInstruction
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : DisassembledInstruction) is
begin
Handler.Start_Object;
Handler.Key_Name ("address");
Handler.String_Value (Value.address);
if not Value.instructionBytes.Is_Null then
Handler.Key_Name ("instructionBytes");
Handler.String_Value (Value.instructionBytes);
end if;
Handler.Key_Name ("instruction");
Handler.String_Value (Value.instruction);
if not Value.symbol.Is_Null then
Handler.Key_Name ("symbol");
Handler.String_Value (Value.symbol);
end if;
if Value.location.Is_Set then
Handler.Key_Name ("location");
Output_Source (Handler, Value.location.Value);
end if;
if Value.line.Is_Set then
Handler.Key_Name ("line");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.line.Value)));
end if;
if Value.column.Is_Set then
Handler.Key_Name ("column");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.column.Value)));
end if;
if Value.endLine.Is_Set then
Handler.Key_Name ("endLine");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.endLine.Value)));
end if;
if Value.endColumn.Is_Set then
Handler.Key_Name ("endColumn");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.endColumn.Value)));
end if;
Handler.End_Object;
end Output_DisassembledInstruction;

procedure Output_PauseArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : PauseArguments) is
begin
Handler.Start_Object;
Handler.Key_Name ("threadId");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.threadId)));
Handler.End_Object;
end Output_PauseArguments;

procedure Output_CancelResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : CancelResponse) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
if not Value.a_body.Is_Empty then
Handler.Key_Name ("body");
Output_Any_Value (Handler, Value.a_body);
end if;
Handler.End_Object;
end Output_CancelResponse;

procedure Output_InitializeRequestArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : InitializeRequestArguments) is
begin
Handler.Start_Object;
if not Value.clientID.Is_Null then
Handler.Key_Name ("clientID");
Handler.String_Value (Value.clientID);
end if;
if not Value.clientName.Is_Null then
Handler.Key_Name ("clientName");
Handler.String_Value (Value.clientName);
end if;
Handler.Key_Name ("adapterID");
Handler.String_Value (Value.adapterID);
if not Value.locale.Is_Null then
Handler.Key_Name ("locale");
Handler.String_Value (Value.locale);
end if;
if Value.linesStartAt1 then
Handler.Key_Name ("linesStartAt1");
Handler.Boolean_Value (Value.linesStartAt1);
end if;
if Value.columnsStartAt1 then
Handler.Key_Name ("columnsStartAt1");
Handler.Boolean_Value (Value.columnsStartAt1);
end if;
if Value.pathFormat.Is_Set then
Handler.Key_Name ("pathFormat");
Output_InitializeRequestArguments_pathFormat (Handler, Value.pathFormat.Value);
end if;
if Value.supportsVariableType then
Handler.Key_Name ("supportsVariableType");
Handler.Boolean_Value (Value.supportsVariableType);
end if;
if Value.supportsVariablePaging then
Handler.Key_Name ("supportsVariablePaging");
Handler.Boolean_Value (Value.supportsVariablePaging);
end if;
if Value.supportsRunInTerminalRequest then
Handler.Key_Name ("supportsRunInTerminalRequest");
Handler.Boolean_Value (Value.supportsRunInTerminalRequest);
end if;
if Value.supportsMemoryReferences then
Handler.Key_Name ("supportsMemoryReferences");
Handler.Boolean_Value (Value.supportsMemoryReferences);
end if;
if Value.supportsProgressReporting then
Handler.Key_Name ("supportsProgressReporting");
Handler.Boolean_Value (Value.supportsProgressReporting);
end if;
if Value.supportsInvalidatedEvent then
Handler.Key_Name ("supportsInvalidatedEvent");
Handler.Boolean_Value (Value.supportsInvalidatedEvent);
end if;
if Value.supportsMemoryEvent then
Handler.Key_Name ("supportsMemoryEvent");
Handler.Boolean_Value (Value.supportsMemoryEvent);
end if;
if Value.supportsArgsCanBeInterpretedByShell then
Handler.Key_Name ("supportsArgsCanBeInterpretedByShell");
Handler.Boolean_Value (Value.supportsArgsCanBeInterpretedByShell);
end if;
if Value.supportsStartDebuggingRequest then
Handler.Key_Name ("supportsStartDebuggingRequest");
Handler.Boolean_Value (Value.supportsStartDebuggingRequest);
end if;
Handler.End_Object;
end Output_InitializeRequestArguments;

procedure Output_SetInstructionBreakpointsResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetInstructionBreakpointsResponse) is
procedure Output_SetInstructionBreakpointsResponse_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetInstructionBreakpointsResponse_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("breakpoints");
Handler.Start_Array;
for J in 1 .. Value.breakpoints.Length loop
Output_Breakpoint (Handler, Value.breakpoints (J));
end loop;
Handler.End_Array;
Handler.End_Object;
end Output_SetInstructionBreakpointsResponse_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
Handler.Key_Name ("body");
Output_SetInstructionBreakpointsResponse_body (Handler, Value.a_body);
Handler.End_Object;
end Output_SetInstructionBreakpointsResponse;

procedure Output_CancelRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : CancelRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("cancel");
if Value.arguments.Is_Set then
Handler.Key_Name ("arguments");
Output_CancelArguments (Handler, Value.arguments.Value);
end if;
Handler.End_Object;
end Output_CancelRequest;

procedure Output_ProgressEndEvent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ProgressEndEvent) is
procedure Output_ProgressEndEvent_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ProgressEndEvent_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("progressId");
Handler.String_Value (Value.progressId);
if not Value.message.Is_Null then
Handler.Key_Name ("message");
Handler.String_Value (Value.message);
end if;
Handler.End_Object;
end Output_ProgressEndEvent_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("event");
Handler.Key_Name ("event");Handler.String_Value ("progressEnd");
Handler.Key_Name ("body");
Output_ProgressEndEvent_body (Handler, Value.a_body);
Handler.End_Object;
end Output_ProgressEndEvent;

procedure Output_Event
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Event) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("event");
Handler.Key_Name ("event");
Handler.String_Value (Value.event);
if not Value.a_body.Is_Empty then
Handler.Key_Name ("body");
Output_Any_Value (Handler, Value.a_body);
end if;
Handler.End_Object;
end Output_Event;

procedure Output_VariablesRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : VariablesRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("variables");
Handler.Key_Name ("arguments");
Output_VariablesArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_VariablesRequest;

procedure Output_ExceptionOptions
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ExceptionOptions) is
begin
Handler.Start_Object;
if Value.path.Length > 0 then
Handler.Key_Name ("path");
Handler.Start_Array;
for J in 1 .. Value.path.Length loop
Output_ExceptionPathSegment (Handler, Value.path (J));
end loop;
Handler.End_Array;
end if;
Handler.Key_Name ("breakMode");
Output_ExceptionBreakMode (Handler, Value.breakMode);
Handler.End_Object;
end Output_ExceptionOptions;

procedure Output_TerminatedEvent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : TerminatedEvent) is
procedure Output_TerminatedEvent_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : TerminatedEvent_body) is
begin
Handler.Start_Object;
if not Value.restart.Is_Empty then
Handler.Key_Name ("restart");
Output_Any_Value (Handler, Value.restart);
end if;
Handler.End_Object;
end Output_TerminatedEvent_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("event");
Handler.Key_Name ("event");Handler.String_Value ("terminated");
if Value.a_body.Is_Set then
Handler.Key_Name ("body");
Output_TerminatedEvent_body (Handler, Value.a_body.Value);
end if;
Handler.End_Object;
end Output_TerminatedEvent;

procedure Output_StartDebuggingRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StartDebuggingRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("startDebugging");
Handler.Key_Name ("arguments");
Output_StartDebuggingRequestArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_StartDebuggingRequest;

procedure Output_ThreadEvent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ThreadEvent) is
procedure Output_ThreadEvent_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ThreadEvent_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("reason");
Output_ThreadEvent_reason (Handler, Value.reason);
Handler.Key_Name ("threadId");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.threadId)));
Handler.End_Object;
end Output_ThreadEvent_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("event");
Handler.Key_Name ("event");Handler.String_Value ("thread");
Handler.Key_Name ("body");
Output_ThreadEvent_body (Handler, Value.a_body);
Handler.End_Object;
end Output_ThreadEvent;

procedure Output_GotoTargetsResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : GotoTargetsResponse) is
procedure Output_GotoTargetsResponse_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : GotoTargetsResponse_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("targets");
Handler.Start_Array;
for J in 1 .. Value.targets.Length loop
Output_GotoTarget (Handler, Value.targets (J));
end loop;
Handler.End_Array;
Handler.End_Object;
end Output_GotoTargetsResponse_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
Handler.Key_Name ("body");
Output_GotoTargetsResponse_body (Handler, Value.a_body);
Handler.End_Object;
end Output_GotoTargetsResponse;

procedure Output_CompletionItem
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : CompletionItem) is
begin
Handler.Start_Object;
Handler.Key_Name ("label");
Handler.String_Value (Value.label);
if not Value.text.Is_Null then
Handler.Key_Name ("text");
Handler.String_Value (Value.text);
end if;
if not Value.sortText.Is_Null then
Handler.Key_Name ("sortText");
Handler.String_Value (Value.sortText);
end if;
if not Value.detail.Is_Null then
Handler.Key_Name ("detail");
Handler.String_Value (Value.detail);
end if;
if Value.a_type.Is_Set then
Handler.Key_Name ("type");
Output_CompletionItemType (Handler, Value.a_type.Value);
end if;
if Value.start.Is_Set then
Handler.Key_Name ("start");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.start.Value)));
end if;
if Value.length.Is_Set then
Handler.Key_Name ("length");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.length.Value)));
end if;
if Value.selectionStart.Is_Set then
Handler.Key_Name ("selectionStart");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.selectionStart.Value)));
end if;
if Value.selectionLength.Is_Set then
Handler.Key_Name ("selectionLength");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.selectionLength.Value)));
end if;
Handler.End_Object;
end Output_CompletionItem;

procedure Output_ScopesArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ScopesArguments) is
begin
Handler.Start_Object;
Handler.Key_Name ("frameId");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.frameId)));
Handler.End_Object;
end Output_ScopesArguments;

procedure Output_ErrorResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ErrorResponse) is
procedure Output_ErrorResponse_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ErrorResponse_body) is
begin
Handler.Start_Object;
if Value.error.Is_Set then
Handler.Key_Name ("error");
Output_Message (Handler, Value.error.Value);
end if;
Handler.End_Object;
end Output_ErrorResponse_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
Handler.Key_Name ("body");
Output_ErrorResponse_body (Handler, Value.a_body);
Handler.End_Object;
end Output_ErrorResponse;

procedure Output_SetInstructionBreakpointsArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetInstructionBreakpointsArguments) is
begin
Handler.Start_Object;
Handler.Key_Name ("breakpoints");
Handler.Start_Array;
for J in 1 .. Value.breakpoints.Length loop
Output_InstructionBreakpoint (Handler, Value.breakpoints (J));
end loop;
Handler.End_Array;
Handler.End_Object;
end Output_SetInstructionBreakpointsArguments;

procedure Output_GotoArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : GotoArguments) is
begin
Handler.Start_Object;
Handler.Key_Name ("threadId");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.threadId)));
Handler.Key_Name ("targetId");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.targetId)));
Handler.End_Object;
end Output_GotoArguments;

procedure Output_BreakpointEvent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : BreakpointEvent) is
procedure Output_BreakpointEvent_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : BreakpointEvent_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("reason");
Output_BreakpointEvent_reason (Handler, Value.reason);
Handler.Key_Name ("breakpoint");
Output_Breakpoint (Handler, Value.breakpoint);
Handler.End_Object;
end Output_BreakpointEvent_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("event");
Handler.Key_Name ("event");Handler.String_Value ("breakpoint");
Handler.Key_Name ("body");
Output_BreakpointEvent_body (Handler, Value.a_body);
Handler.End_Object;
end Output_BreakpointEvent;

procedure Output_GotoTarget
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : GotoTarget) is
begin
Handler.Start_Object;
Handler.Key_Name ("id");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.id)));
Handler.Key_Name ("label");
Handler.String_Value (Value.label);
Handler.Key_Name ("line");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.line)));
if Value.column.Is_Set then
Handler.Key_Name ("column");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.column.Value)));
end if;
if Value.endLine.Is_Set then
Handler.Key_Name ("endLine");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.endLine.Value)));
end if;
if Value.endColumn.Is_Set then
Handler.Key_Name ("endColumn");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.endColumn.Value)));
end if;
if not Value.instructionPointerReference.Is_Null then
Handler.Key_Name ("instructionPointerReference");
Handler.String_Value (Value.instructionPointerReference);
end if;
Handler.End_Object;
end Output_GotoTarget;

procedure Output_ReadMemoryRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ReadMemoryRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("readMemory");
Handler.Key_Name ("arguments");
Output_ReadMemoryArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_ReadMemoryRequest;

procedure Output_ModulesArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ModulesArguments) is
begin
Handler.Start_Object;
if Value.startModule.Is_Set then
Handler.Key_Name ("startModule");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.startModule.Value)));
end if;
if Value.moduleCount.Is_Set then
Handler.Key_Name ("moduleCount");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.moduleCount.Value)));
end if;
Handler.End_Object;
end Output_ModulesArguments;

procedure Output_NextRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : NextRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("next");
Handler.Key_Name ("arguments");
Output_NextArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_NextRequest;

procedure Output_ProgressStartEvent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ProgressStartEvent) is
procedure Output_ProgressStartEvent_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ProgressStartEvent_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("progressId");
Handler.String_Value (Value.progressId);
Handler.Key_Name ("title");
Handler.String_Value (Value.title);
if Value.requestId.Is_Set then
Handler.Key_Name ("requestId");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.requestId.Value)));
end if;
if Value.cancellable then
Handler.Key_Name ("cancellable");
Handler.Boolean_Value (Value.cancellable);
end if;
if not Value.message.Is_Null then
Handler.Key_Name ("message");
Handler.String_Value (Value.message);
end if;
if Value.percentage.Is_Set then
Handler.Key_Name ("percentage");
Handler.Float_Value(Interfaces.IEEE_Float_64 (Value.percentage.Value));
end if;
Handler.End_Object;
end Output_ProgressStartEvent_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("event");
Handler.Key_Name ("event");Handler.String_Value ("progressStart");
Handler.Key_Name ("body");
Output_ProgressStartEvent_body (Handler, Value.a_body);
Handler.End_Object;
end Output_ProgressStartEvent;

procedure Output_SetVariableResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetVariableResponse) is
procedure Output_SetVariableResponse_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetVariableResponse_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("value");
Handler.String_Value (Value.value);
if not Value.a_type.Is_Null then
Handler.Key_Name ("type");
Handler.String_Value (Value.a_type);
end if;
if Value.variablesReference.Is_Set then
Handler.Key_Name ("variablesReference");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.variablesReference.Value)));
end if;
if Value.namedVariables.Is_Set then
Handler.Key_Name ("namedVariables");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.namedVariables.Value)));
end if;
if Value.indexedVariables.Is_Set then
Handler.Key_Name ("indexedVariables");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.indexedVariables.Value)));
end if;
Handler.End_Object;
end Output_SetVariableResponse_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
Handler.Key_Name ("body");
Output_SetVariableResponse_body (Handler, Value.a_body);
Handler.End_Object;
end Output_SetVariableResponse;

procedure Output_BreakpointLocation
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : BreakpointLocation) is
begin
Handler.Start_Object;
Handler.Key_Name ("line");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.line)));
if Value.column.Is_Set then
Handler.Key_Name ("column");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.column.Value)));
end if;
if Value.endLine.Is_Set then
Handler.Key_Name ("endLine");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.endLine.Value)));
end if;
if Value.endColumn.Is_Set then
Handler.Key_Name ("endColumn");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.endColumn.Value)));
end if;
Handler.End_Object;
end Output_BreakpointLocation;

procedure Output_RestartFrameArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : RestartFrameArguments) is
begin
Handler.Start_Object;
Handler.Key_Name ("frameId");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.frameId)));
Handler.End_Object;
end Output_RestartFrameArguments;

procedure Output_DisconnectResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : DisconnectResponse) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
if not Value.a_body.Is_Empty then
Handler.Key_Name ("body");
Output_Any_Value (Handler, Value.a_body);
end if;
Handler.End_Object;
end Output_DisconnectResponse;

procedure Output_SetExceptionBreakpointsRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetExceptionBreakpointsRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("setExceptionBreakpoints");
Handler.Key_Name ("arguments");
Output_SetExceptionBreakpointsArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_SetExceptionBreakpointsRequest;

procedure Output_WriteMemoryRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : WriteMemoryRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("writeMemory");
Handler.Key_Name ("arguments");
Output_WriteMemoryArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_WriteMemoryRequest;

procedure Output_DataBreakpointInfoArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : DataBreakpointInfoArguments) is
begin
Handler.Start_Object;
if Value.variablesReference.Is_Set then
Handler.Key_Name ("variablesReference");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.variablesReference.Value)));
end if;
Handler.Key_Name ("name");
Handler.String_Value (Value.name);
if Value.frameId.Is_Set then
Handler.Key_Name ("frameId");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.frameId.Value)));
end if;
Handler.End_Object;
end Output_DataBreakpointInfoArguments;

procedure Output_InitializeResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : InitializeResponse) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
if Value.a_body.Is_Set then
Handler.Key_Name ("body");
Output_Capabilities (Handler, Value.a_body.Value);
end if;
Handler.End_Object;
end Output_InitializeResponse;

procedure Output_ConfigurationDoneResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ConfigurationDoneResponse) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
if not Value.a_body.Is_Empty then
Handler.Key_Name ("body");
Output_Any_Value (Handler, Value.a_body);
end if;
Handler.End_Object;
end Output_ConfigurationDoneResponse;

procedure Output_StepInTargetsArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StepInTargetsArguments) is
begin
Handler.Start_Object;
Handler.Key_Name ("frameId");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.frameId)));
Handler.End_Object;
end Output_StepInTargetsArguments;

procedure Output_EvaluateArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : EvaluateArguments) is
begin
Handler.Start_Object;
Handler.Key_Name ("expression");
Handler.String_Value (Value.expression);
if Value.frameId.Is_Set then
Handler.Key_Name ("frameId");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.frameId.Value)));
end if;
if Value.context.Is_Set then
Handler.Key_Name ("context");
Output_EvaluateArguments_context (Handler, Value.context.Value);
end if;
if Value.format.Is_Set then
Handler.Key_Name ("format");
Output_ValueFormat (Handler, Value.format.Value);
end if;
Handler.End_Object;
end Output_EvaluateArguments;

procedure Output_SetFunctionBreakpointsArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetFunctionBreakpointsArguments) is
begin
Handler.Start_Object;
Handler.Key_Name ("breakpoints");
Handler.Start_Array;
for J in 1 .. Value.breakpoints.Length loop
Output_FunctionBreakpoint (Handler, Value.breakpoints (J));
end loop;
Handler.End_Array;
Handler.End_Object;
end Output_SetFunctionBreakpointsArguments;

procedure Output_GotoRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : GotoRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("goto");
Handler.Key_Name ("arguments");
Output_GotoArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_GotoRequest;

procedure Output_SetFunctionBreakpointsResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetFunctionBreakpointsResponse) is
procedure Output_SetFunctionBreakpointsResponse_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetFunctionBreakpointsResponse_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("breakpoints");
Handler.Start_Array;
for J in 1 .. Value.breakpoints.Length loop
Output_Breakpoint (Handler, Value.breakpoints (J));
end loop;
Handler.End_Array;
Handler.End_Object;
end Output_SetFunctionBreakpointsResponse_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
Handler.Key_Name ("body");
Output_SetFunctionBreakpointsResponse_body (Handler, Value.a_body);
Handler.End_Object;
end Output_SetFunctionBreakpointsResponse;

procedure Output_ExceptionInfoArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ExceptionInfoArguments) is
begin
Handler.Start_Object;
Handler.Key_Name ("threadId");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.threadId)));
Handler.End_Object;
end Output_ExceptionInfoArguments;

procedure Output_StackTraceRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StackTraceRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("stackTrace");
Handler.Key_Name ("arguments");
Output_StackTraceArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_StackTraceRequest;

procedure Output_EvaluateResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : EvaluateResponse) is
procedure Output_EvaluateResponse_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : EvaluateResponse_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("result");
Handler.String_Value (Value.result);
if not Value.a_type.Is_Null then
Handler.Key_Name ("type");
Handler.String_Value (Value.a_type);
end if;
if Value.presentationHint.Is_Set then
Handler.Key_Name ("presentationHint");
Output_VariablePresentationHint (Handler, Value.presentationHint.Value);
end if;
Handler.Key_Name ("variablesReference");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.variablesReference)));
if Value.namedVariables.Is_Set then
Handler.Key_Name ("namedVariables");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.namedVariables.Value)));
end if;
if Value.indexedVariables.Is_Set then
Handler.Key_Name ("indexedVariables");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.indexedVariables.Value)));
end if;
if not Value.memoryReference.Is_Null then
Handler.Key_Name ("memoryReference");
Handler.String_Value (Value.memoryReference);
end if;
Handler.End_Object;
end Output_EvaluateResponse_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
Handler.Key_Name ("body");
Output_EvaluateResponse_body (Handler, Value.a_body);
Handler.End_Object;
end Output_EvaluateResponse;

procedure Output_ReverseContinueRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ReverseContinueRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("reverseContinue");
Handler.Key_Name ("arguments");
Output_ReverseContinueArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_ReverseContinueRequest;

procedure Output_ModulesRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ModulesRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("modules");
Handler.Key_Name ("arguments");
Output_ModulesArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_ModulesRequest;

procedure Output_SetBreakpointsResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetBreakpointsResponse) is
procedure Output_SetBreakpointsResponse_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetBreakpointsResponse_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("breakpoints");
Handler.Start_Array;
for J in 1 .. Value.breakpoints.Length loop
Output_Breakpoint (Handler, Value.breakpoints (J));
end loop;
Handler.End_Array;
Handler.End_Object;
end Output_SetBreakpointsResponse_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
Handler.Key_Name ("body");
Output_SetBreakpointsResponse_body (Handler, Value.a_body);
Handler.End_Object;
end Output_SetBreakpointsResponse;

procedure Output_InstructionBreakpoint
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : InstructionBreakpoint) is
begin
Handler.Start_Object;
Handler.Key_Name ("instructionReference");
Handler.String_Value (Value.instructionReference);
if Value.offset.Is_Set then
Handler.Key_Name ("offset");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.offset.Value)));
end if;
if not Value.condition.Is_Null then
Handler.Key_Name ("condition");
Handler.String_Value (Value.condition);
end if;
if not Value.hitCondition.Is_Null then
Handler.Key_Name ("hitCondition");
Handler.String_Value (Value.hitCondition);
end if;
Handler.End_Object;
end Output_InstructionBreakpoint;

procedure Output_DisconnectRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : DisconnectRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("disconnect");
if Value.arguments.Is_Set then
Handler.Key_Name ("arguments");
Output_DisconnectArguments (Handler, Value.arguments.Value);
end if;
Handler.End_Object;
end Output_DisconnectRequest;

procedure Output_TerminateThreadsResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : TerminateThreadsResponse) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
if not Value.a_body.Is_Empty then
Handler.Key_Name ("body");
Output_Any_Value (Handler, Value.a_body);
end if;
Handler.End_Object;
end Output_TerminateThreadsResponse;

procedure Output_ScopesRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ScopesRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("scopes");
Handler.Key_Name ("arguments");
Output_ScopesArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_ScopesRequest;

procedure Output_SetExceptionBreakpointsResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetExceptionBreakpointsResponse) is
procedure Output_SetExceptionBreakpointsResponse_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : SetExceptionBreakpointsResponse_body) is
begin
Handler.Start_Object;
if Value.breakpoints.Length > 0 then
Handler.Key_Name ("breakpoints");
Handler.Start_Array;
for J in 1 .. Value.breakpoints.Length loop
Output_Breakpoint (Handler, Value.breakpoints (J));
end loop;
Handler.End_Array;
end if;
Handler.End_Object;
end Output_SetExceptionBreakpointsResponse_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
if Value.a_body.Is_Set then
Handler.Key_Name ("body");
Output_SetExceptionBreakpointsResponse_body (Handler, Value.a_body.Value);
end if;
Handler.End_Object;
end Output_SetExceptionBreakpointsResponse;

procedure Output_StepBackResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StepBackResponse) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
if not Value.a_body.Is_Empty then
Handler.Key_Name ("body");
Output_Any_Value (Handler, Value.a_body);
end if;
Handler.End_Object;
end Output_StepBackResponse;

procedure Output_DisassembleResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : DisassembleResponse) is
procedure Output_DisassembleResponse_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : DisassembleResponse_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("instructions");
Handler.Start_Array;
for J in 1 .. Value.instructions.Length loop
Output_DisassembledInstruction (Handler, Value.instructions (J));
end loop;
Handler.End_Array;
Handler.End_Object;
end Output_DisassembleResponse_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
if Value.a_body.Is_Set then
Handler.Key_Name ("body");
Output_DisassembleResponse_body (Handler, Value.a_body.Value);
end if;
Handler.End_Object;
end Output_DisassembleResponse;

procedure Output_InvalidatedEvent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : InvalidatedEvent) is
procedure Output_InvalidatedEvent_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : InvalidatedEvent_body) is
begin
Handler.Start_Object;
if Value.areas.Length > 0 then
Handler.Key_Name ("areas");
Handler.Start_Array;
for J in 1 .. Value.areas.Length loop
Output_InvalidatedAreas (Handler, Value.areas (J));
end loop;
Handler.End_Array;
end if;
if Value.threadId.Is_Set then
Handler.Key_Name ("threadId");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.threadId.Value)));
end if;
if Value.stackFrameId.Is_Set then
Handler.Key_Name ("stackFrameId");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.stackFrameId.Value)));
end if;
Handler.End_Object;
end Output_InvalidatedEvent_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("event");
Handler.Key_Name ("event");Handler.String_Value ("invalidated");
Handler.Key_Name ("body");
Output_InvalidatedEvent_body (Handler, Value.a_body);
Handler.End_Object;
end Output_InvalidatedEvent;

procedure Output_GotoTargetsArguments
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : GotoTargetsArguments) is
begin
Handler.Start_Object;
Handler.Key_Name ("source");
Output_Source (Handler, Value.source);
Handler.Key_Name ("line");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.line)));
if Value.column.Is_Set then
Handler.Key_Name ("column");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.column.Value)));
end if;
Handler.End_Object;
end Output_GotoTargetsArguments;

procedure Output_StepInRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StepInRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("stepIn");
Handler.Key_Name ("arguments");
Output_StepInArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_StepInRequest;

procedure Output_ContinueRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : ContinueRequest) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("request");
Handler.Key_Name ("command");Handler.String_Value ("continue");
Handler.Key_Name ("arguments");
Output_ContinueArguments (Handler, Value.arguments);
Handler.End_Object;
end Output_ContinueRequest;

procedure Output_LoadedSourcesResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : LoadedSourcesResponse) is
procedure Output_LoadedSourcesResponse_body
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : LoadedSourcesResponse_body) is
begin
Handler.Start_Object;
Handler.Key_Name ("sources");
Handler.Start_Array;
for J in 1 .. Value.sources.Length loop
Output_Source (Handler, Value.sources (J));
end loop;
Handler.End_Array;
Handler.End_Object;
end Output_LoadedSourcesResponse_body;

begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
Handler.Key_Name ("body");
Output_LoadedSourcesResponse_body (Handler, Value.a_body);
Handler.End_Object;
end Output_LoadedSourcesResponse;

procedure Output_StartDebuggingResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : StartDebuggingResponse) is
begin
Handler.Start_Object;
Handler.Key_Name ("seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.seq)));
Handler.Key_Name ("type");Handler.String_Value ("response");
Handler.Key_Name ("request_seq");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.request_seq)));
Handler.Key_Name ("success");
Handler.Boolean_Value (Value.success);
Handler.Key_Name ("command");
Handler.String_Value (Value.command);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_Response_message (Handler, Value.message.Value);
end if;
if not Value.a_body.Is_Empty then
Handler.Key_Name ("body");
Output_Any_Value (Handler, Value.a_body);
end if;
Handler.End_Object;
end Output_StartDebuggingResponse;

end DAP.Tools.Outputs;
--  Copyright <YEAR> <COPYRIGHT HOLDER>
--
--  Permission is hereby granted, free of charge, to any person obtaining a
--  copy of this software and associated documentation files (the "Software"),
--  to deal in the Software without restriction, including without limitation
--  the rights to use, copy, modify, merge, publish, distribute, sublicense,
--  and/or sell copies of the Software, and to permit persons to whom the
--  Software is furnished to do so, subject to the following conditions:
--
--  The above copyright notice and this permission notice shall be included in
--  all copies or substantial portions of the Software.
--
--  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
--  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
--  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
--  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
--  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
--  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
--  DEALINGS IN THE SOFTWARE.
--
--  DON'T EDIT THIS FILE! It was generated from JSON Schema.

with VSS.JSON.Pull_Readers;

package DAP.Tools.Inputs is

procedure Input_ModuleEvent_reason
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.ModuleEvent_reason;
Success : in out Boolean);

procedure Input_ColumnDescriptor_type
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.ColumnDescriptor_type;
Success : in out Boolean);

procedure Input_StackFrame_presentationHint
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.StackFrame_presentationHint;
Success : in out Boolean);

procedure Input_ExceptionBreakMode
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.ExceptionBreakMode;
Success : in out Boolean);

procedure Input_StoppedEvent_reason
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.StoppedEvent_reason;
Success : in out Boolean);

procedure Input_StartDebuggingRequestArguments_request
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.StartDebuggingRequestArguments_request;
Success : in out Boolean);

procedure Input_OutputEvent_category
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.OutputEvent_category;
Success : in out Boolean);

procedure Input_OutputEvent_group
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.OutputEvent_group;
Success : in out Boolean);

procedure Input_ChecksumAlgorithm
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.ChecksumAlgorithm;
Success : in out Boolean);

procedure Input_ProcessEvent_startMethod
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.ProcessEvent_startMethod;
Success : in out Boolean);

procedure Input_Scope_presentationHint
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.Scope_presentationHint;
Success : in out Boolean);

procedure Input_Response_message
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.Response_message;
Success : in out Boolean);

procedure Input_CompletionItemType
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.CompletionItemType;
Success : in out Boolean);

procedure Input_InvalidatedAreas
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.InvalidatedAreas;
Success : in out Boolean);

procedure Input_Source_presentationHint
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.Source_presentationHint;
Success : in out Boolean);

procedure Input_LoadedSourceEvent_reason
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.LoadedSourceEvent_reason;
Success : in out Boolean);

procedure Input_ProtocolMessage_type
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.ProtocolMessage_type;
Success : in out Boolean);

procedure Input_RunInTerminalRequestArguments_kind
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.RunInTerminalRequestArguments_kind;
Success : in out Boolean);

procedure Input_VariablesArguments_filter
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.VariablesArguments_filter;
Success : in out Boolean);

procedure Input_VariablePresentationHint_kind
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.VariablePresentationHint_kind;
Success : in out Boolean);

procedure Input_VariablePresentationHint_attributes
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.VariablePresentationHint_attributes;
Success : in out Boolean);

procedure Input_VariablePresentationHint_visibility
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.VariablePresentationHint_visibility;
Success : in out Boolean);

procedure Input_InitializeRequestArguments_pathFormat
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.InitializeRequestArguments_pathFormat;
Success : in out Boolean);

procedure Input_ThreadEvent_reason
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.ThreadEvent_reason;
Success : in out Boolean);

procedure Input_DataBreakpointAccessType
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.DataBreakpointAccessType;
Success : in out Boolean);

procedure Input_BreakpointEvent_reason
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.BreakpointEvent_reason;
Success : in out Boolean);

procedure Input_EvaluateArguments_context
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.EvaluateArguments_context;
Success : in out Boolean);

procedure Input_SteppingGranularity
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.SteppingGranularity;
Success : in out Boolean);

procedure Input_GotoResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out GotoResponse;
Success : in out Boolean);

procedure Input_ExceptionDetails
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ExceptionDetails;
Success : in out Boolean);

procedure Input_StepInTargetsRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StepInTargetsRequest;
Success : in out Boolean);

procedure Input_ModulesResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ModulesResponse;
Success : in out Boolean);

procedure Input_NextArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out NextArguments;
Success : in out Boolean);

procedure Input_ExceptionInfoRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ExceptionInfoRequest;
Success : in out Boolean);

procedure Input_TerminateThreadsArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out TerminateThreadsArguments;
Success : in out Boolean);

procedure Input_DataBreakpointInfoRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out DataBreakpointInfoRequest;
Success : in out Boolean);

procedure Input_TerminateThreadsRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out TerminateThreadsRequest;
Success : in out Boolean);

procedure Input_SetBreakpointsArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetBreakpointsArguments;
Success : in out Boolean);

procedure Input_ModuleEvent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ModuleEvent;
Success : in out Boolean);

procedure Input_ContinuedEvent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ContinuedEvent;
Success : in out Boolean);

procedure Input_RestartArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out RestartArguments;
Success : in out Boolean);

procedure Input_SetVariableArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetVariableArguments;
Success : in out Boolean);

procedure Input_Checksum
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Checksum;
Success : in out Boolean);

procedure Input_BreakpointLocationsRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out BreakpointLocationsRequest;
Success : in out Boolean);

procedure Input_ModulesViewDescriptor
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ModulesViewDescriptor;
Success : in out Boolean);

procedure Input_ColumnDescriptor
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ColumnDescriptor;
Success : in out Boolean);

procedure Input_Capabilities
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Capabilities;
Success : in out Boolean);

procedure Input_StackTraceResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StackTraceResponse;
Success : in out Boolean);

procedure Input_LoadedSourcesArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out LoadedSourcesArguments;
Success : in out Boolean);

procedure Input_ConfigurationDoneRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ConfigurationDoneRequest;
Success : in out Boolean);

procedure Input_StepInTargetsResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StepInTargetsResponse;
Success : in out Boolean);

procedure Input_StackFrame
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StackFrame;
Success : in out Boolean);

procedure Input_SetExpressionRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetExpressionRequest;
Success : in out Boolean);

procedure Input_SourceArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SourceArguments;
Success : in out Boolean);

procedure Input_ExceptionFilterOptions
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ExceptionFilterOptions;
Success : in out Boolean);

procedure Input_ExceptionBreakpointsFilter
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ExceptionBreakpointsFilter;
Success : in out Boolean);

procedure Input_SetVariableRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetVariableRequest;
Success : in out Boolean);

procedure Input_AttachRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out AttachRequest;
Success : in out Boolean);

procedure Input_MemoryEvent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out MemoryEvent;
Success : in out Boolean);

procedure Input_ReadMemoryArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ReadMemoryArguments;
Success : in out Boolean);

procedure Input_LoadedSourcesRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out LoadedSourcesRequest;
Success : in out Boolean);

procedure Input_LaunchRequestArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out LaunchRequestArguments;
Success : in out Boolean);

procedure Input_ExitedEvent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ExitedEvent;
Success : in out Boolean);

procedure Input_SetBreakpointsRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetBreakpointsRequest;
Success : in out Boolean);

procedure Input_TerminateResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out TerminateResponse;
Success : in out Boolean);

procedure Input_Variable
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Variable;
Success : in out Boolean);

procedure Input_StoppedEvent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StoppedEvent;
Success : in out Boolean);

procedure Input_RestartFrameRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out RestartFrameRequest;
Success : in out Boolean);

procedure Input_AttachRequestArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out AttachRequestArguments;
Success : in out Boolean);

procedure Input_ScopesResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ScopesResponse;
Success : in out Boolean);

procedure Input_StepOutArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StepOutArguments;
Success : in out Boolean);

procedure Input_CompletionsRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out CompletionsRequest;
Success : in out Boolean);

procedure Input_StartDebuggingRequestArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StartDebuggingRequestArguments;
Success : in out Boolean);

procedure Input_ProgressUpdateEvent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ProgressUpdateEvent;
Success : in out Boolean);

procedure Input_ExceptionInfoResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ExceptionInfoResponse;
Success : in out Boolean);

procedure Input_InitializedEvent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out InitializedEvent;
Success : in out Boolean);

procedure Input_SetExpressionResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetExpressionResponse;
Success : in out Boolean);

procedure Input_StepInTarget
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StepInTarget;
Success : in out Boolean);

procedure Input_ReverseContinueResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ReverseContinueResponse;
Success : in out Boolean);

procedure Input_OutputEvent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out OutputEvent;
Success : in out Boolean);

procedure Input_RestartRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out RestartRequest;
Success : in out Boolean);

procedure Input_StackTraceArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StackTraceArguments;
Success : in out Boolean);

procedure Input_Thread
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Thread;
Success : in out Boolean);

procedure Input_SetDataBreakpointsRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetDataBreakpointsRequest;
Success : in out Boolean);

procedure Input_SourceRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SourceRequest;
Success : in out Boolean);

procedure Input_PauseResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out PauseResponse;
Success : in out Boolean);

procedure Input_SetFunctionBreakpointsRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetFunctionBreakpointsRequest;
Success : in out Boolean);

procedure Input_ProcessEvent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ProcessEvent;
Success : in out Boolean);

procedure Input_NextResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out NextResponse;
Success : in out Boolean);

procedure Input_AttachResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out AttachResponse;
Success : in out Boolean);

procedure Input_RestartResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out RestartResponse;
Success : in out Boolean);

procedure Input_CapabilitiesEvent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out CapabilitiesEvent;
Success : in out Boolean);

procedure Input_Scope
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Scope;
Success : in out Boolean);

procedure Input_DisassembleArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out DisassembleArguments;
Success : in out Boolean);

procedure Input_SetInstructionBreakpointsRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetInstructionBreakpointsRequest;
Success : in out Boolean);

procedure Input_Response
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Response;
Success : in out Boolean);

procedure Input_DataBreakpointInfoResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out DataBreakpointInfoResponse;
Success : in out Boolean);

procedure Input_SourceBreakpoint
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SourceBreakpoint;
Success : in out Boolean);

procedure Input_PauseRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out PauseRequest;
Success : in out Boolean);

procedure Input_FunctionBreakpoint
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out FunctionBreakpoint;
Success : in out Boolean);

procedure Input_SetExpressionArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetExpressionArguments;
Success : in out Boolean);

procedure Input_SetExceptionBreakpointsArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetExceptionBreakpointsArguments;
Success : in out Boolean);

procedure Input_ValueFormat
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ValueFormat;
Success : in out Boolean);

procedure Input_RunInTerminalRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out RunInTerminalRequest;
Success : in out Boolean);

procedure Input_CompletionsArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out CompletionsArguments;
Success : in out Boolean);

procedure Input_WriteMemoryResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out WriteMemoryResponse;
Success : in out Boolean);

procedure Input_ReverseContinueArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ReverseContinueArguments;
Success : in out Boolean);

procedure Input_RunInTerminalResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out RunInTerminalResponse;
Success : in out Boolean);

procedure Input_DisconnectArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out DisconnectArguments;
Success : in out Boolean);

procedure Input_Module
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Module;
Success : in out Boolean);

procedure Input_GotoTargetsRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out GotoTargetsRequest;
Success : in out Boolean);

procedure Input_ThreadsResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ThreadsResponse;
Success : in out Boolean);

procedure Input_SetDataBreakpointsResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetDataBreakpointsResponse;
Success : in out Boolean);

procedure Input_DataBreakpoint
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out DataBreakpoint;
Success : in out Boolean);

procedure Input_SetDataBreakpointsArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetDataBreakpointsArguments;
Success : in out Boolean);

procedure Input_ExceptionPathSegment
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ExceptionPathSegment;
Success : in out Boolean);

procedure Input_Message
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Message;
Success : in out Boolean);

procedure Input_SourceResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SourceResponse;
Success : in out Boolean);

procedure Input_ContinueResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ContinueResponse;
Success : in out Boolean);

procedure Input_RestartFrameResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out RestartFrameResponse;
Success : in out Boolean);

procedure Input_StepInArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StepInArguments;
Success : in out Boolean);

procedure Input_LaunchResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out LaunchResponse;
Success : in out Boolean);

procedure Input_StepInResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StepInResponse;
Success : in out Boolean);

procedure Input_TerminateArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out TerminateArguments;
Success : in out Boolean);

procedure Input_LaunchRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out LaunchRequest;
Success : in out Boolean);

procedure Input_StepOutResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StepOutResponse;
Success : in out Boolean);

procedure Input_EvaluateRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out EvaluateRequest;
Success : in out Boolean);

procedure Input_ContinueArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ContinueArguments;
Success : in out Boolean);

procedure Input_StepBackArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StepBackArguments;
Success : in out Boolean);

procedure Input_BreakpointLocationsArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out BreakpointLocationsArguments;
Success : in out Boolean);

procedure Input_CancelArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out CancelArguments;
Success : in out Boolean);

procedure Input_CompletionsResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out CompletionsResponse;
Success : in out Boolean);

procedure Input_Breakpoint
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Breakpoint;
Success : in out Boolean);

procedure Input_Source
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Source;
Success : in out Boolean);

procedure Input_WriteMemoryArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out WriteMemoryArguments;
Success : in out Boolean);

procedure Input_ConfigurationDoneArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ConfigurationDoneArguments;
Success : in out Boolean);

procedure Input_StepOutRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StepOutRequest;
Success : in out Boolean);

procedure Input_Request
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Request;
Success : in out Boolean);

procedure Input_LoadedSourceEvent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out LoadedSourceEvent;
Success : in out Boolean);

procedure Input_StackFrameFormat
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StackFrameFormat;
Success : in out Boolean);

procedure Input_DisassembleRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out DisassembleRequest;
Success : in out Boolean);

procedure Input_ReadMemoryResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ReadMemoryResponse;
Success : in out Boolean);

procedure Input_StepBackRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StepBackRequest;
Success : in out Boolean);

procedure Input_ProtocolMessage
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ProtocolMessage;
Success : in out Boolean);

procedure Input_ThreadsRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ThreadsRequest;
Success : in out Boolean);

procedure Input_VariablesResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out VariablesResponse;
Success : in out Boolean);

procedure Input_RunInTerminalRequestArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out RunInTerminalRequestArguments;
Success : in out Boolean);

procedure Input_TerminateRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out TerminateRequest;
Success : in out Boolean);

procedure Input_VariablesArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out VariablesArguments;
Success : in out Boolean);

procedure Input_InitializeRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out InitializeRequest;
Success : in out Boolean);

procedure Input_BreakpointLocationsResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out BreakpointLocationsResponse;
Success : in out Boolean);

procedure Input_VariablePresentationHint
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out VariablePresentationHint;
Success : in out Boolean);

procedure Input_DisassembledInstruction
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out DisassembledInstruction;
Success : in out Boolean);

procedure Input_PauseArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out PauseArguments;
Success : in out Boolean);

procedure Input_CancelResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out CancelResponse;
Success : in out Boolean);

procedure Input_InitializeRequestArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out InitializeRequestArguments;
Success : in out Boolean);

procedure Input_SetInstructionBreakpointsResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetInstructionBreakpointsResponse;
Success : in out Boolean);

procedure Input_CancelRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out CancelRequest;
Success : in out Boolean);

procedure Input_ProgressEndEvent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ProgressEndEvent;
Success : in out Boolean);

procedure Input_Event
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Event;
Success : in out Boolean);

procedure Input_VariablesRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out VariablesRequest;
Success : in out Boolean);

procedure Input_ExceptionOptions
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ExceptionOptions;
Success : in out Boolean);

procedure Input_TerminatedEvent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out TerminatedEvent;
Success : in out Boolean);

procedure Input_StartDebuggingRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StartDebuggingRequest;
Success : in out Boolean);

procedure Input_ThreadEvent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ThreadEvent;
Success : in out Boolean);

procedure Input_GotoTargetsResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out GotoTargetsResponse;
Success : in out Boolean);

procedure Input_CompletionItem
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out CompletionItem;
Success : in out Boolean);

procedure Input_ScopesArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ScopesArguments;
Success : in out Boolean);

procedure Input_ErrorResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ErrorResponse;
Success : in out Boolean);

procedure Input_SetInstructionBreakpointsArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetInstructionBreakpointsArguments;
Success : in out Boolean);

procedure Input_GotoArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out GotoArguments;
Success : in out Boolean);

procedure Input_BreakpointEvent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out BreakpointEvent;
Success : in out Boolean);

procedure Input_GotoTarget
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out GotoTarget;
Success : in out Boolean);

procedure Input_ReadMemoryRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ReadMemoryRequest;
Success : in out Boolean);

procedure Input_ModulesArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ModulesArguments;
Success : in out Boolean);

procedure Input_NextRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out NextRequest;
Success : in out Boolean);

procedure Input_ProgressStartEvent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ProgressStartEvent;
Success : in out Boolean);

procedure Input_SetVariableResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetVariableResponse;
Success : in out Boolean);

procedure Input_BreakpointLocation
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out BreakpointLocation;
Success : in out Boolean);

procedure Input_RestartFrameArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out RestartFrameArguments;
Success : in out Boolean);

procedure Input_DisconnectResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out DisconnectResponse;
Success : in out Boolean);

procedure Input_SetExceptionBreakpointsRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetExceptionBreakpointsRequest;
Success : in out Boolean);

procedure Input_WriteMemoryRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out WriteMemoryRequest;
Success : in out Boolean);

procedure Input_DataBreakpointInfoArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out DataBreakpointInfoArguments;
Success : in out Boolean);

procedure Input_InitializeResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out InitializeResponse;
Success : in out Boolean);

procedure Input_ConfigurationDoneResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ConfigurationDoneResponse;
Success : in out Boolean);

procedure Input_StepInTargetsArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StepInTargetsArguments;
Success : in out Boolean);

procedure Input_EvaluateArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out EvaluateArguments;
Success : in out Boolean);

procedure Input_SetFunctionBreakpointsArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetFunctionBreakpointsArguments;
Success : in out Boolean);

procedure Input_GotoRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out GotoRequest;
Success : in out Boolean);

procedure Input_SetFunctionBreakpointsResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetFunctionBreakpointsResponse;
Success : in out Boolean);

procedure Input_ExceptionInfoArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ExceptionInfoArguments;
Success : in out Boolean);

procedure Input_StackTraceRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StackTraceRequest;
Success : in out Boolean);

procedure Input_EvaluateResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out EvaluateResponse;
Success : in out Boolean);

procedure Input_ReverseContinueRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ReverseContinueRequest;
Success : in out Boolean);

procedure Input_ModulesRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ModulesRequest;
Success : in out Boolean);

procedure Input_SetBreakpointsResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetBreakpointsResponse;
Success : in out Boolean);

procedure Input_InstructionBreakpoint
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out InstructionBreakpoint;
Success : in out Boolean);

procedure Input_DisconnectRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out DisconnectRequest;
Success : in out Boolean);

procedure Input_TerminateThreadsResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out TerminateThreadsResponse;
Success : in out Boolean);

procedure Input_ScopesRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ScopesRequest;
Success : in out Boolean);

procedure Input_SetExceptionBreakpointsResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetExceptionBreakpointsResponse;
Success : in out Boolean);

procedure Input_StepBackResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StepBackResponse;
Success : in out Boolean);

procedure Input_DisassembleResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out DisassembleResponse;
Success : in out Boolean);

procedure Input_InvalidatedEvent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out InvalidatedEvent;
Success : in out Boolean);

procedure Input_GotoTargetsArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out GotoTargetsArguments;
Success : in out Boolean);

procedure Input_StepInRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StepInRequest;
Success : in out Boolean);

procedure Input_ContinueRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ContinueRequest;
Success : in out Boolean);

procedure Input_LoadedSourcesResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out LoadedSourcesResponse;
Success : in out Boolean);

procedure Input_StartDebuggingResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StartDebuggingResponse;
Success : in out Boolean);

end DAP.Tools.Inputs;
--  Copyright <YEAR> <COPYRIGHT HOLDER>
--
--  Permission is hereby granted, free of charge, to any person obtaining a
--  copy of this software and associated documentation files (the "Software"),
--  to deal in the Software without restriction, including without limitation
--  the rights to use, copy, modify, merge, publish, distribute, sublicense,
--  and/or sell copies of the Software, and to permit persons to whom the
--  Software is furnished to do so, subject to the following conditions:
--
--  The above copyright notice and this permission notice shall be included in
--  all copies or substantial portions of the Software.
--
--  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
--  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
--  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
--  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
--  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
--  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
--  DEALINGS IN THE SOFTWARE.
--
--  DON'T EDIT THIS FILE! It was generated from JSON Schema.

pragma Ada_2022;
with Minimal_Perfect_Hash;

package body DAP.Tools.Inputs is
pragma Style_Checks (Off);
use type VSS.JSON.JSON_Number_Kind;
use type VSS.Strings.Virtual_String;

procedure Input_Any_Value
  (Reader  : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
   Value   : out Any_Value'Class;
   Success : in out Boolean) is
use type VSS.JSON.Streams.JSON_Stream_Element_Kind;
begin
case Reader.Element_Kind is
when VSS.JSON.Streams.Start_Array =>
Value.Append ((Kind => VSS.JSON.Streams.Start_Array));
Reader.Read_Next;
while Success and Reader.Element_Kind /= VSS.JSON.Streams.End_Array loop
Input_Any_Value (Reader, Value, Success);
end loop;
Value.Append ((Kind => VSS.JSON.Streams.End_Array));
when VSS.JSON.Streams.Start_Object =>
Value.Append ((Kind => VSS.JSON.Streams.Start_Object));
Reader.Read_Next;
while Success and Reader.Element_Kind = VSS.JSON.Streams.Key_Name loop
Value.Append (Reader.Element);
Reader.Read_Next;
Input_Any_Value (Reader, Value, Success);
end loop;
Value.Append ((Kind => VSS.JSON.Streams.End_Object));
when VSS.JSON.Streams.String_Value
   | VSS.JSON.Streams.Number_Value
   | VSS.JSON.Streams.Boolean_Value
   | VSS.JSON.Streams.Null_Value
=>
Value.Append (Reader.Element);
when others =>
Success := False;
end case;
if Success then
Reader.Read_Next;
end if;
end Input_Any_Value;

package ModuleEvent_reason_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["new", "changed", "removed"]);

procedure Input_ModuleEvent_reason
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.ModuleEvent_reason;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
ModuleEvent_reason_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
Value := Enum.ModuleEvent_reason'Val (Index - 1);
Reader.Read_Next;
else
Success := False;
end if;
end Input_ModuleEvent_reason;

package ColumnDescriptor_type_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["string", "number", "boolean", "unixTimestampUTC"]);

procedure Input_ColumnDescriptor_type
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.ColumnDescriptor_type;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
ColumnDescriptor_type_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
Value := Enum.ColumnDescriptor_type'Val (Index - 1);
Reader.Read_Next;
else
Success := False;
end if;
end Input_ColumnDescriptor_type;

package StackFrame_presentationHint_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["normal", "label", "subtle"]);

procedure Input_StackFrame_presentationHint
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.StackFrame_presentationHint;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
StackFrame_presentationHint_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
Value := Enum.StackFrame_presentationHint'Val (Index - 1);
Reader.Read_Next;
else
Success := False;
end if;
end Input_StackFrame_presentationHint;

package ExceptionBreakMode_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["never", "always", "unhandled", "userUnhandled"]);

procedure Input_ExceptionBreakMode
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.ExceptionBreakMode;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
ExceptionBreakMode_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
Value := Enum.ExceptionBreakMode'Val (Index - 1);
Reader.Read_Next;
else
Success := False;
end if;
end Input_ExceptionBreakMode;

package StoppedEvent_reason_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["step", "breakpoint", "exception", "pause", "entry", "goto", "function breakpoint", "data breakpoint", "instruction breakpoint"]);

procedure Input_StoppedEvent_reason
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.StoppedEvent_reason;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
StoppedEvent_reason_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
pragma Warnings (Off, "redundant conversion");
Value := (Kind => Enum.StoppedEvent_reason_Predefined (Enum.StoppedEvent_reason_Value'Val (Index - 1)));pragma Warnings (On, "redundant conversion");
Reader.Read_Next;
elsif Index = 0 then
Value := (Enum.Custom_Value, Reader.String_Value);Reader.Read_Next;
else
Success := False;
end if;
end Input_StoppedEvent_reason;

package StartDebuggingRequestArguments_request_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["launch", "attach"]);

procedure Input_StartDebuggingRequestArguments_request
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.StartDebuggingRequestArguments_request;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
StartDebuggingRequestArguments_request_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
Value := Enum.StartDebuggingRequestArguments_request'Val (Index - 1);
Reader.Read_Next;
else
Success := False;
end if;
end Input_StartDebuggingRequestArguments_request;

package OutputEvent_category_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["console", "important", "stdout", "stderr", "telemetry"]);

procedure Input_OutputEvent_category
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.OutputEvent_category;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
OutputEvent_category_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
pragma Warnings (Off, "redundant conversion");
Value := (Kind => Enum.OutputEvent_category_Predefined (Enum.OutputEvent_category_Value'Val (Index - 1)));pragma Warnings (On, "redundant conversion");
Reader.Read_Next;
elsif Index = 0 then
Value := (Enum.Custom_Value, Reader.String_Value);Reader.Read_Next;
else
Success := False;
end if;
end Input_OutputEvent_category;

package OutputEvent_group_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["start", "startCollapsed", "end"]);

procedure Input_OutputEvent_group
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.OutputEvent_group;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
OutputEvent_group_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
Value := Enum.OutputEvent_group'Val (Index - 1);
Reader.Read_Next;
else
Success := False;
end if;
end Input_OutputEvent_group;

package ChecksumAlgorithm_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["MD5", "SHA1", "SHA256", "timestamp"]);

procedure Input_ChecksumAlgorithm
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.ChecksumAlgorithm;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
ChecksumAlgorithm_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
Value := Enum.ChecksumAlgorithm'Val (Index - 1);
Reader.Read_Next;
else
Success := False;
end if;
end Input_ChecksumAlgorithm;

package ProcessEvent_startMethod_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["launch", "attach", "attachForSuspendedLaunch"]);

procedure Input_ProcessEvent_startMethod
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.ProcessEvent_startMethod;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
ProcessEvent_startMethod_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
Value := Enum.ProcessEvent_startMethod'Val (Index - 1);
Reader.Read_Next;
else
Success := False;
end if;
end Input_ProcessEvent_startMethod;

package Scope_presentationHint_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["arguments", "locals", "registers"]);

procedure Input_Scope_presentationHint
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.Scope_presentationHint;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
Scope_presentationHint_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
pragma Warnings (Off, "redundant conversion");
Value := (Kind => Enum.Scope_presentationHint_Predefined (Enum.Scope_presentationHint_Value'Val (Index - 1)));pragma Warnings (On, "redundant conversion");
Reader.Read_Next;
elsif Index = 0 then
Value := (Enum.Custom_Value, Reader.String_Value);Reader.Read_Next;
else
Success := False;
end if;
end Input_Scope_presentationHint;

package Response_message_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["cancelled", "notStopped"]);

procedure Input_Response_message
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.Response_message;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
Response_message_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
pragma Warnings (Off, "redundant conversion");
Value := (Kind => Enum.Response_message_Predefined (Enum.Response_message_Value'Val (Index - 1)));pragma Warnings (On, "redundant conversion");
Reader.Read_Next;
elsif Index = 0 then
Value := (Enum.Custom_Value, Reader.String_Value);Reader.Read_Next;
else
Success := False;
end if;
end Input_Response_message;

package CompletionItemType_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["method", "function", "constructor", "field", "variable", "class", "interface", "module", "property", "unit", "value", "enum", "keyword", "snippet", "text", "color", "file", "reference", "customcolor"]);

procedure Input_CompletionItemType
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.CompletionItemType;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
CompletionItemType_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
Value := Enum.CompletionItemType'Val (Index - 1);
Reader.Read_Next;
else
Success := False;
end if;
end Input_CompletionItemType;

package InvalidatedAreas_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["all", "stacks", "threads", "variables"]);

procedure Input_InvalidatedAreas
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.InvalidatedAreas;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
InvalidatedAreas_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
pragma Warnings (Off, "redundant conversion");
Value := (Kind => Enum.InvalidatedAreas_Predefined (Enum.InvalidatedAreas_Value'Val (Index - 1)));pragma Warnings (On, "redundant conversion");
Reader.Read_Next;
elsif Index = 0 then
Value := (Enum.Custom_Value, Reader.String_Value);Reader.Read_Next;
else
Success := False;
end if;
end Input_InvalidatedAreas;

package Source_presentationHint_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["normal", "emphasize", "deemphasize"]);

procedure Input_Source_presentationHint
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.Source_presentationHint;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
Source_presentationHint_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
Value := Enum.Source_presentationHint'Val (Index - 1);
Reader.Read_Next;
else
Success := False;
end if;
end Input_Source_presentationHint;

package LoadedSourceEvent_reason_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["new", "changed", "removed"]);

procedure Input_LoadedSourceEvent_reason
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.LoadedSourceEvent_reason;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
LoadedSourceEvent_reason_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
Value := Enum.LoadedSourceEvent_reason'Val (Index - 1);
Reader.Read_Next;
else
Success := False;
end if;
end Input_LoadedSourceEvent_reason;

package ProtocolMessage_type_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["request", "response", "event"]);

procedure Input_ProtocolMessage_type
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.ProtocolMessage_type;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
ProtocolMessage_type_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
pragma Warnings (Off, "redundant conversion");
Value := (Kind => Enum.ProtocolMessage_type_Predefined (Enum.ProtocolMessage_type_Value'Val (Index - 1)));pragma Warnings (On, "redundant conversion");
Reader.Read_Next;
elsif Index = 0 then
Value := (Enum.Custom_Value, Reader.String_Value);Reader.Read_Next;
else
Success := False;
end if;
end Input_ProtocolMessage_type;

package RunInTerminalRequestArguments_kind_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["integrated", "external"]);

procedure Input_RunInTerminalRequestArguments_kind
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.RunInTerminalRequestArguments_kind;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
RunInTerminalRequestArguments_kind_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
Value := Enum.RunInTerminalRequestArguments_kind'Val (Index - 1);
Reader.Read_Next;
else
Success := False;
end if;
end Input_RunInTerminalRequestArguments_kind;

package VariablesArguments_filter_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["indexed", "named"]);

procedure Input_VariablesArguments_filter
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.VariablesArguments_filter;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
VariablesArguments_filter_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
Value := Enum.VariablesArguments_filter'Val (Index - 1);
Reader.Read_Next;
else
Success := False;
end if;
end Input_VariablesArguments_filter;

package VariablePresentationHint_kind_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["property", "method", "class", "data", "event", "baseClass", "innerClass", "interface", "mostDerivedClass", "virtual", "dataBreakpoint"]);

procedure Input_VariablePresentationHint_kind
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.VariablePresentationHint_kind;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
VariablePresentationHint_kind_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
pragma Warnings (Off, "redundant conversion");
Value := (Kind => Enum.VariablePresentationHint_kind_Predefined (Enum.VariablePresentationHint_kind_Value'Val (Index - 1)));pragma Warnings (On, "redundant conversion");
Reader.Read_Next;
elsif Index = 0 then
Value := (Enum.Custom_Value, Reader.String_Value);Reader.Read_Next;
else
Success := False;
end if;
end Input_VariablePresentationHint_kind;

package VariablePresentationHint_attributes_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["static", "constant", "readOnly", "rawString", "hasObjectId", "canHaveObjectId", "hasSideEffects", "hasDataBreakpoint"]);

procedure Input_VariablePresentationHint_attributes
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.VariablePresentationHint_attributes;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
VariablePresentationHint_attributes_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
pragma Warnings (Off, "redundant conversion");
Value := (Kind => Enum.VariablePresentationHint_attributes_Predefined (Enum.VariablePresentationHint_attributes_Value'Val (Index - 1)));pragma Warnings (On, "redundant conversion");
Reader.Read_Next;
elsif Index = 0 then
Value := (Enum.Custom_Value, Reader.String_Value);Reader.Read_Next;
else
Success := False;
end if;
end Input_VariablePresentationHint_attributes;

package VariablePresentationHint_visibility_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["public", "private", "protected", "internal", "final"]);

procedure Input_VariablePresentationHint_visibility
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.VariablePresentationHint_visibility;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
VariablePresentationHint_visibility_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
pragma Warnings (Off, "redundant conversion");
Value := (Kind => Enum.VariablePresentationHint_visibility_Predefined (Enum.VariablePresentationHint_visibility_Value'Val (Index - 1)));pragma Warnings (On, "redundant conversion");
Reader.Read_Next;
elsif Index = 0 then
Value := (Enum.Custom_Value, Reader.String_Value);Reader.Read_Next;
else
Success := False;
end if;
end Input_VariablePresentationHint_visibility;

package InitializeRequestArguments_pathFormat_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["path", "uri"]);

procedure Input_InitializeRequestArguments_pathFormat
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.InitializeRequestArguments_pathFormat;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
InitializeRequestArguments_pathFormat_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
pragma Warnings (Off, "redundant conversion");
Value := (Kind => Enum.InitializeRequestArguments_pathFormat_Predefined (Enum.InitializeRequestArguments_pathFormat_Value'Val (Index - 1)));pragma Warnings (On, "redundant conversion");
Reader.Read_Next;
elsif Index = 0 then
Value := (Enum.Custom_Value, Reader.String_Value);Reader.Read_Next;
else
Success := False;
end if;
end Input_InitializeRequestArguments_pathFormat;

package ThreadEvent_reason_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["started", "exited"]);

procedure Input_ThreadEvent_reason
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.ThreadEvent_reason;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
ThreadEvent_reason_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
pragma Warnings (Off, "redundant conversion");
Value := (Kind => Enum.ThreadEvent_reason_Predefined (Enum.ThreadEvent_reason_Value'Val (Index - 1)));pragma Warnings (On, "redundant conversion");
Reader.Read_Next;
elsif Index = 0 then
Value := (Enum.Custom_Value, Reader.String_Value);Reader.Read_Next;
else
Success := False;
end if;
end Input_ThreadEvent_reason;

package DataBreakpointAccessType_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["read", "write", "readWrite"]);

procedure Input_DataBreakpointAccessType
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.DataBreakpointAccessType;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
DataBreakpointAccessType_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
Value := Enum.DataBreakpointAccessType'Val (Index - 1);
Reader.Read_Next;
else
Success := False;
end if;
end Input_DataBreakpointAccessType;

package BreakpointEvent_reason_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["changed", "new", "removed"]);

procedure Input_BreakpointEvent_reason
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.BreakpointEvent_reason;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
BreakpointEvent_reason_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
pragma Warnings (Off, "redundant conversion");
Value := (Kind => Enum.BreakpointEvent_reason_Predefined (Enum.BreakpointEvent_reason_Value'Val (Index - 1)));pragma Warnings (On, "redundant conversion");
Reader.Read_Next;
elsif Index = 0 then
Value := (Enum.Custom_Value, Reader.String_Value);Reader.Read_Next;
else
Success := False;
end if;
end Input_BreakpointEvent_reason;

package EvaluateArguments_context_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["watch", "repl", "hover", "clipboard", "variables"]);

procedure Input_EvaluateArguments_context
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.EvaluateArguments_context;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
EvaluateArguments_context_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
pragma Warnings (Off, "redundant conversion");
Value := (Kind => Enum.EvaluateArguments_context_Predefined (Enum.EvaluateArguments_context_Value'Val (Index - 1)));pragma Warnings (On, "redundant conversion");
Reader.Read_Next;
elsif Index = 0 then
Value := (Enum.Custom_Value, Reader.String_Value);Reader.Read_Next;
else
Success := False;
end if;
end Input_EvaluateArguments_context;

package SteppingGranularity_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["statement", "line", "instruction"]);

procedure Input_SteppingGranularity
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.SteppingGranularity;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
SteppingGranularity_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
Value := Enum.SteppingGranularity'Val (Index - 1);
Reader.Read_Next;
else
Success := False;
end if;
end Input_SteppingGranularity;

package GotoResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

procedure Input_GotoResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out GotoResponse;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
GotoResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_Any_Value (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_GotoResponse;

package ExceptionDetails_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["message", "typeName", "fullTypeName", "evaluateName", "stackTrace", "innerException"]);

procedure Input_ExceptionDetails
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ExceptionDetails;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ExceptionDetails_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  message
if Reader.Is_String_Value then
Value.message := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  typeName
if Reader.Is_String_Value then
Value.typeName := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  fullTypeName
if Reader.Is_String_Value then
Value.fullTypeName := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  evaluateName
if Reader.Is_String_Value then
Value.evaluateName := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  stackTrace
if Reader.Is_String_Value then
Value.stackTrace := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  innerException
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : ExceptionDetails;
begin
Input_ExceptionDetails (Reader, Item, Success);
Value.innerException.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ExceptionDetails;

package StepInTargetsRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_StepInTargetsRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StepInTargetsRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
StepInTargetsRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "stepInTargets" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_StepInTargetsArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_StepInTargetsRequest;

package ModulesResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

package ModulesResponse_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["modules", "totalModules"]);

procedure Input_ModulesResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ModulesResponse;
Success : in out Boolean) is
procedure Input_ModulesResponse_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ModulesResponse_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ModulesResponse_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  modules
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : Module;
begin
Input_Module (Reader, Item, Success);
Value.modules.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 2 =>  --  totalModules
Value.totalModules := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.totalModules.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ModulesResponse_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ModulesResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_ModulesResponse_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ModulesResponse;

package NextArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["threadId", "singleThread", "granularity"]);

procedure Input_NextArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out NextArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
NextArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  threadId
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.threadId := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  singleThread
if Reader.Is_Boolean_Value then
Value.singleThread := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  granularity
Value.granularity := (Is_Set => True, Value => <>);
Input_SteppingGranularity (Reader, Value.granularity.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_NextArguments;

package ExceptionInfoRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_ExceptionInfoRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ExceptionInfoRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ExceptionInfoRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "exceptionInfo" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_ExceptionInfoArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ExceptionInfoRequest;

package TerminateThreadsArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["threadIds"]);

procedure Input_TerminateThreadsArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out TerminateThreadsArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
TerminateThreadsArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  threadIds
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : Integer;
begin
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Item := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
Value.threadIds.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_TerminateThreadsArguments;

package DataBreakpointInfoRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_DataBreakpointInfoRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out DataBreakpointInfoRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
DataBreakpointInfoRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "dataBreakpointInfo" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_DataBreakpointInfoArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_DataBreakpointInfoRequest;

package TerminateThreadsRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_TerminateThreadsRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out TerminateThreadsRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
TerminateThreadsRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "terminateThreads" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_TerminateThreadsArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_TerminateThreadsRequest;

package SetBreakpointsArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["source", "breakpoints", "lines", "sourceModified"]);

procedure Input_SetBreakpointsArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetBreakpointsArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
SetBreakpointsArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  source
Input_Source (Reader, Value.source, Success);
   when 2 =>  --  breakpoints
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : SourceBreakpoint;
begin
Input_SourceBreakpoint (Reader, Item, Success);
Value.breakpoints.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 3 =>  --  lines
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : Integer;
begin
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Item := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
Value.lines.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 4 =>  --  sourceModified
if Reader.Is_Boolean_Value then
Value.sourceModified := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_SetBreakpointsArguments;

package ModuleEvent_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "event", "body"]);

package ModuleEvent_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["reason", "module"]);

procedure Input_ModuleEvent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ModuleEvent;
Success : in out Boolean) is
procedure Input_ModuleEvent_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ModuleEvent_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ModuleEvent_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  reason
Input_ModuleEvent_reason (Reader, Value.reason, Success);
   when 2 =>  --  module
Input_Module (Reader, Value.module, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ModuleEvent_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ModuleEvent_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "event" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  event
if Reader.Is_String_Value and then Reader.String_Value = "module" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  body
Input_ModuleEvent_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ModuleEvent;

package ContinuedEvent_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "event", "body"]);

package ContinuedEvent_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["threadId", "allThreadsContinued"]);

procedure Input_ContinuedEvent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ContinuedEvent;
Success : in out Boolean) is
procedure Input_ContinuedEvent_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ContinuedEvent_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ContinuedEvent_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  threadId
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.threadId := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  allThreadsContinued
if Reader.Is_Boolean_Value then
Value.allThreadsContinued := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ContinuedEvent_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ContinuedEvent_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "event" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  event
if Reader.Is_String_Value and then Reader.String_Value = "continued" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  body
Input_ContinuedEvent_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ContinuedEvent;

package RestartArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["arguments"]);

procedure Input_RestartArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out RestartArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
RestartArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  arguments
Value.arguments := (Is_Set => True, Value => <>);
Input_AttachRequestArguments (Reader, Value.arguments.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_RestartArguments;

package SetVariableArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["variablesReference", "name", "value", "format"]);

procedure Input_SetVariableArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetVariableArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
SetVariableArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  variablesReference
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.variablesReference := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  name
if Reader.Is_String_Value then
Value.name := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  value
if Reader.Is_String_Value then
Value.value := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  format
Value.format := (Is_Set => True, Value => <>);
Input_ValueFormat (Reader, Value.format.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_SetVariableArguments;

package Checksum_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["algorithm", "checksum"]);

procedure Input_Checksum
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Checksum;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
Checksum_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  algorithm
Input_ChecksumAlgorithm (Reader, Value.algorithm, Success);
   when 2 =>  --  checksum
if Reader.Is_String_Value then
Value.checksum := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_Checksum;

package BreakpointLocationsRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_BreakpointLocationsRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out BreakpointLocationsRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
BreakpointLocationsRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "breakpointLocations" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Value.arguments := (Is_Set => True, Value => <>);
Input_BreakpointLocationsArguments (Reader, Value.arguments.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_BreakpointLocationsRequest;

package ModulesViewDescriptor_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["columns"]);

procedure Input_ModulesViewDescriptor
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ModulesViewDescriptor;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ModulesViewDescriptor_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  columns
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : ColumnDescriptor;
begin
Input_ColumnDescriptor (Reader, Item, Success);
Value.columns.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ModulesViewDescriptor;

package ColumnDescriptor_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["attributeName", "label", "format", "type", "width"]);

procedure Input_ColumnDescriptor
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ColumnDescriptor;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ColumnDescriptor_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  attributeName
if Reader.Is_String_Value then
Value.attributeName := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  label
if Reader.Is_String_Value then
Value.label := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  format
if Reader.Is_String_Value then
Value.format := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  type
Value.a_type := (Is_Set => True, Value => <>);
Input_ColumnDescriptor_type (Reader, Value.a_type.Value, Success);
   when 5 =>  --  width
Value.width := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.width.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ColumnDescriptor;

package Capabilities_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["supportsConfigurationDoneRequest", "supportsFunctionBreakpoints", "supportsConditionalBreakpoints", "supportsHitConditionalBreakpoints", "supportsEvaluateForHovers", "exceptionBreakpointFilters", "supportsStepBack", "supportsSetVariable", "supportsRestartFrame", "supportsGotoTargetsRequest", "supportsStepInTargetsRequest", "supportsCompletionsRequest", "completionTriggerCharacters", "supportsModulesRequest", "additionalModuleColumns", "supportedChecksumAlgorithms", "supportsRestartRequest", "supportsExceptionOptions", "supportsValueFormattingOptions", "supportsExceptionInfoRequest", "supportTerminateDebuggee", "supportSuspendDebuggee", "supportsDelayedStackTraceLoading", "supportsLoadedSourcesRequest", "supportsLogPoints", "supportsTerminateThreadsRequest", "supportsSetExpression", "supportsTerminateRequest", "supportsDataBreakpoints", "supportsReadMemoryRequest", "supportsWriteMemoryRequest", "supportsDisassembleRequest", "supportsCancelRequest", "supportsBreakpointLocationsRequest", "supportsClipboardContext", "supportsSteppingGranularity", "supportsInstructionBreakpoints", "supportsExceptionFilterOptions", "supportsSingleThreadExecutionRequests"]);

procedure Input_Capabilities
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Capabilities;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
Capabilities_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  supportsConfigurationDoneRequest
if Reader.Is_Boolean_Value then
Value.supportsConfigurationDoneRequest := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  supportsFunctionBreakpoints
if Reader.Is_Boolean_Value then
Value.supportsFunctionBreakpoints := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  supportsConditionalBreakpoints
if Reader.Is_Boolean_Value then
Value.supportsConditionalBreakpoints := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  supportsHitConditionalBreakpoints
if Reader.Is_Boolean_Value then
Value.supportsHitConditionalBreakpoints := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  supportsEvaluateForHovers
if Reader.Is_Boolean_Value then
Value.supportsEvaluateForHovers := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  exceptionBreakpointFilters
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : ExceptionBreakpointsFilter;
begin
Input_ExceptionBreakpointsFilter (Reader, Item, Success);
Value.exceptionBreakpointFilters.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 7 =>  --  supportsStepBack
if Reader.Is_Boolean_Value then
Value.supportsStepBack := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 8 =>  --  supportsSetVariable
if Reader.Is_Boolean_Value then
Value.supportsSetVariable := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 9 =>  --  supportsRestartFrame
if Reader.Is_Boolean_Value then
Value.supportsRestartFrame := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 10 =>  --  supportsGotoTargetsRequest
if Reader.Is_Boolean_Value then
Value.supportsGotoTargetsRequest := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 11 =>  --  supportsStepInTargetsRequest
if Reader.Is_Boolean_Value then
Value.supportsStepInTargetsRequest := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 12 =>  --  supportsCompletionsRequest
if Reader.Is_Boolean_Value then
Value.supportsCompletionsRequest := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 13 =>  --  completionTriggerCharacters
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : VSS.Strings.Virtual_String;
begin
if Reader.Is_String_Value then
Item := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
Value.completionTriggerCharacters.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 14 =>  --  supportsModulesRequest
if Reader.Is_Boolean_Value then
Value.supportsModulesRequest := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 15 =>  --  additionalModuleColumns
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : ColumnDescriptor;
begin
Input_ColumnDescriptor (Reader, Item, Success);
Value.additionalModuleColumns.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 16 =>  --  supportedChecksumAlgorithms
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : Enum.ChecksumAlgorithm;
begin
Input_ChecksumAlgorithm (Reader, Item, Success);
Value.supportedChecksumAlgorithms.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 17 =>  --  supportsRestartRequest
if Reader.Is_Boolean_Value then
Value.supportsRestartRequest := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 18 =>  --  supportsExceptionOptions
if Reader.Is_Boolean_Value then
Value.supportsExceptionOptions := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 19 =>  --  supportsValueFormattingOptions
if Reader.Is_Boolean_Value then
Value.supportsValueFormattingOptions := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 20 =>  --  supportsExceptionInfoRequest
if Reader.Is_Boolean_Value then
Value.supportsExceptionInfoRequest := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 21 =>  --  supportTerminateDebuggee
if Reader.Is_Boolean_Value then
Value.supportTerminateDebuggee := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 22 =>  --  supportSuspendDebuggee
if Reader.Is_Boolean_Value then
Value.supportSuspendDebuggee := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 23 =>  --  supportsDelayedStackTraceLoading
if Reader.Is_Boolean_Value then
Value.supportsDelayedStackTraceLoading := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 24 =>  --  supportsLoadedSourcesRequest
if Reader.Is_Boolean_Value then
Value.supportsLoadedSourcesRequest := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 25 =>  --  supportsLogPoints
if Reader.Is_Boolean_Value then
Value.supportsLogPoints := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 26 =>  --  supportsTerminateThreadsRequest
if Reader.Is_Boolean_Value then
Value.supportsTerminateThreadsRequest := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 27 =>  --  supportsSetExpression
if Reader.Is_Boolean_Value then
Value.supportsSetExpression := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 28 =>  --  supportsTerminateRequest
if Reader.Is_Boolean_Value then
Value.supportsTerminateRequest := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 29 =>  --  supportsDataBreakpoints
if Reader.Is_Boolean_Value then
Value.supportsDataBreakpoints := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 30 =>  --  supportsReadMemoryRequest
if Reader.Is_Boolean_Value then
Value.supportsReadMemoryRequest := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 31 =>  --  supportsWriteMemoryRequest
if Reader.Is_Boolean_Value then
Value.supportsWriteMemoryRequest := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 32 =>  --  supportsDisassembleRequest
if Reader.Is_Boolean_Value then
Value.supportsDisassembleRequest := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 33 =>  --  supportsCancelRequest
if Reader.Is_Boolean_Value then
Value.supportsCancelRequest := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 34 =>  --  supportsBreakpointLocationsRequest
if Reader.Is_Boolean_Value then
Value.supportsBreakpointLocationsRequest := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 35 =>  --  supportsClipboardContext
if Reader.Is_Boolean_Value then
Value.supportsClipboardContext := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 36 =>  --  supportsSteppingGranularity
if Reader.Is_Boolean_Value then
Value.supportsSteppingGranularity := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 37 =>  --  supportsInstructionBreakpoints
if Reader.Is_Boolean_Value then
Value.supportsInstructionBreakpoints := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 38 =>  --  supportsExceptionFilterOptions
if Reader.Is_Boolean_Value then
Value.supportsExceptionFilterOptions := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 39 =>  --  supportsSingleThreadExecutionRequests
if Reader.Is_Boolean_Value then
Value.supportsSingleThreadExecutionRequests := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_Capabilities;

package StackTraceResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

package StackTraceResponse_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["stackFrames", "totalFrames"]);

procedure Input_StackTraceResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StackTraceResponse;
Success : in out Boolean) is
procedure Input_StackTraceResponse_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StackTraceResponse_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
StackTraceResponse_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  stackFrames
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : StackFrame;
begin
Input_StackFrame (Reader, Item, Success);
Value.stackFrames.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 2 =>  --  totalFrames
Value.totalFrames := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.totalFrames.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_StackTraceResponse_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
StackTraceResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_StackTraceResponse_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_StackTraceResponse;

procedure Input_LoadedSourcesArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out LoadedSourcesArguments;
Success : in out Boolean) is
begin
Input_Any_Value (Reader, Value, Success);
end Input_LoadedSourcesArguments;

package ConfigurationDoneRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_ConfigurationDoneRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ConfigurationDoneRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ConfigurationDoneRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "configurationDone" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Value.arguments := (Is_Set => True, Value => <>);
Input_ConfigurationDoneArguments (Reader, Value.arguments.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ConfigurationDoneRequest;

package StepInTargetsResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

package StepInTargetsResponse_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["targets"]);

procedure Input_StepInTargetsResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StepInTargetsResponse;
Success : in out Boolean) is
procedure Input_StepInTargetsResponse_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StepInTargetsResponse_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
StepInTargetsResponse_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  targets
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : StepInTarget;
begin
Input_StepInTarget (Reader, Item, Success);
Value.targets.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_StepInTargetsResponse_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
StepInTargetsResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_StepInTargetsResponse_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_StepInTargetsResponse;

package StackFrame_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["id", "name", "source", "line", "column", "endLine", "endColumn", "canRestart", "instructionPointerReference", "moduleId", "presentationHint"]);

procedure Input_StackFrame
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StackFrame;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
StackFrame_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  id
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.id := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  name
if Reader.Is_String_Value then
Value.name := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  source
Value.source := (Is_Set => True, Value => <>);
Input_Source (Reader, Value.source.Value, Success);
   when 4 =>  --  line
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.line := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  column
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.column := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  endLine
Value.endLine := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.endLine.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 7 =>  --  endColumn
Value.endColumn := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.endColumn.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 8 =>  --  canRestart
if Reader.Is_Boolean_Value then
Value.canRestart := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 9 =>  --  instructionPointerReference
if Reader.Is_String_Value then
Value.instructionPointerReference := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 10 =>  --  moduleId
Value.moduleId := (Is_Set => True, Value => <>);
Value.moduleId.Value := (False, Integer => <>);
if Reader.Is_String_Value then
Value.moduleId.Value := (True, Reader.String_Value);
Reader.Read_Next;
elsif Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.moduleId.Value.Integer := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 11 =>  --  presentationHint
Value.presentationHint := (Is_Set => True, Value => <>);
Input_StackFrame_presentationHint (Reader, Value.presentationHint.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_StackFrame;

package SetExpressionRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_SetExpressionRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetExpressionRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
SetExpressionRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "setExpression" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_SetExpressionArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_SetExpressionRequest;

package SourceArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["source", "sourceReference"]);

procedure Input_SourceArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SourceArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
SourceArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  source
Value.source := (Is_Set => True, Value => <>);
Input_Source (Reader, Value.source.Value, Success);
   when 2 =>  --  sourceReference
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.sourceReference := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_SourceArguments;

package ExceptionFilterOptions_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["filterId", "condition"]);

procedure Input_ExceptionFilterOptions
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ExceptionFilterOptions;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ExceptionFilterOptions_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  filterId
if Reader.Is_String_Value then
Value.filterId := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  condition
if Reader.Is_String_Value then
Value.condition := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ExceptionFilterOptions;

package ExceptionBreakpointsFilter_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["filter", "label", "description", "default", "supportsCondition", "conditionDescription"]);

procedure Input_ExceptionBreakpointsFilter
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ExceptionBreakpointsFilter;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ExceptionBreakpointsFilter_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  filter
if Reader.Is_String_Value then
Value.filter := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  label
if Reader.Is_String_Value then
Value.label := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  description
if Reader.Is_String_Value then
Value.description := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  default
if Reader.Is_Boolean_Value then
Value.default := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  supportsCondition
if Reader.Is_Boolean_Value then
Value.supportsCondition := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  conditionDescription
if Reader.Is_String_Value then
Value.conditionDescription := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ExceptionBreakpointsFilter;

package SetVariableRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_SetVariableRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetVariableRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
SetVariableRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "setVariable" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_SetVariableArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_SetVariableRequest;

package AttachRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_AttachRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out AttachRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
AttachRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "attach" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_AttachRequestArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_AttachRequest;

package MemoryEvent_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "event", "body"]);

package MemoryEvent_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["memoryReference", "offset", "count"]);

procedure Input_MemoryEvent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out MemoryEvent;
Success : in out Boolean) is
procedure Input_MemoryEvent_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out MemoryEvent_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
MemoryEvent_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  memoryReference
if Reader.Is_String_Value then
Value.memoryReference := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  offset
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.offset := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  count
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.count := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_MemoryEvent_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
MemoryEvent_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "event" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  event
if Reader.Is_String_Value and then Reader.String_Value = "memory" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  body
Input_MemoryEvent_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_MemoryEvent;

package ReadMemoryArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["memoryReference", "offset", "count"]);

procedure Input_ReadMemoryArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ReadMemoryArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ReadMemoryArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  memoryReference
if Reader.Is_String_Value then
Value.memoryReference := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  offset
Value.offset := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.offset.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  count
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.count := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ReadMemoryArguments;

package LoadedSourcesRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_LoadedSourcesRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out LoadedSourcesRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
LoadedSourcesRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "loadedSources" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Value.arguments := (Is_Set => True, Value => <>);
Input_LoadedSourcesArguments (Reader, Value.arguments.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_LoadedSourcesRequest;

package LaunchRequestArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["noDebug", "__restart", "program", "args", "cwd", "stopAtBeginningOfMainSubprogram"]);

procedure Input_LaunchRequestArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out LaunchRequestArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
LaunchRequestArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  noDebug
if Reader.Is_Boolean_Value then
Value.noDebug := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  __restart
Input_Any_Value (Reader, Value.restart, Success);
   when 3 =>  --  program
if Reader.Is_String_Value then
Value.program := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  args
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : VSS.Strings.Virtual_String;
begin
if Reader.Is_String_Value then
Item := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
Value.args.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 5 =>  --  cwd
if Reader.Is_String_Value then
Value.cwd := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  stopAtBeginningOfMainSubprogram
if Reader.Is_Boolean_Value then
Value.stopAtBeginningOfMainSubprogram := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_LaunchRequestArguments;

package ExitedEvent_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "event", "body"]);

package ExitedEvent_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["exitCode"]);

procedure Input_ExitedEvent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ExitedEvent;
Success : in out Boolean) is
procedure Input_ExitedEvent_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ExitedEvent_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ExitedEvent_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  exitCode
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.exitCode := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ExitedEvent_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ExitedEvent_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "event" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  event
if Reader.Is_String_Value and then Reader.String_Value = "exited" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  body
Input_ExitedEvent_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ExitedEvent;

package SetBreakpointsRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_SetBreakpointsRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetBreakpointsRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
SetBreakpointsRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "setBreakpoints" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_SetBreakpointsArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_SetBreakpointsRequest;

package TerminateResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

procedure Input_TerminateResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out TerminateResponse;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
TerminateResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_Any_Value (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_TerminateResponse;

package Variable_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["name", "value", "type", "presentationHint", "evaluateName", "variablesReference", "namedVariables", "indexedVariables", "memoryReference"]);

procedure Input_Variable
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Variable;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
Variable_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  name
if Reader.Is_String_Value then
Value.name := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  value
if Reader.Is_String_Value then
Value.value := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  type
if Reader.Is_String_Value then
Value.a_type := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  presentationHint
Value.presentationHint := (Is_Set => True, Value => <>);
Input_VariablePresentationHint (Reader, Value.presentationHint.Value, Success);
   when 5 =>  --  evaluateName
if Reader.Is_String_Value then
Value.evaluateName := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  variablesReference
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.variablesReference := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 7 =>  --  namedVariables
Value.namedVariables := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.namedVariables.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 8 =>  --  indexedVariables
Value.indexedVariables := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.indexedVariables.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 9 =>  --  memoryReference
if Reader.Is_String_Value then
Value.memoryReference := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_Variable;

package StoppedEvent_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "event", "body"]);

package StoppedEvent_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["reason", "description", "threadId", "preserveFocusHint", "text", "allThreadsStopped", "hitBreakpointIds"]);

procedure Input_StoppedEvent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StoppedEvent;
Success : in out Boolean) is
procedure Input_StoppedEvent_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StoppedEvent_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
StoppedEvent_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  reason
Input_StoppedEvent_reason (Reader, Value.reason, Success);
   when 2 =>  --  description
if Reader.Is_String_Value then
Value.description := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  threadId
Value.threadId := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.threadId.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  preserveFocusHint
if Reader.Is_Boolean_Value then
Value.preserveFocusHint := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  text
if Reader.Is_String_Value then
Value.text := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  allThreadsStopped
if Reader.Is_Boolean_Value then
Value.allThreadsStopped := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 7 =>  --  hitBreakpointIds
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : Integer;
begin
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Item := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
Value.hitBreakpointIds.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_StoppedEvent_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
StoppedEvent_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "event" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  event
if Reader.Is_String_Value and then Reader.String_Value = "stopped" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  body
Input_StoppedEvent_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_StoppedEvent;

package RestartFrameRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_RestartFrameRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out RestartFrameRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
RestartFrameRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "restartFrame" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_RestartFrameArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_RestartFrameRequest;

package AttachRequestArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["__restart", "pid", "target"]);

procedure Input_AttachRequestArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out AttachRequestArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
AttachRequestArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  __restart
Input_Any_Value (Reader, Value.restart, Success);
   when 2 =>  --  pid
Value.pid := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.pid.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  target
if Reader.Is_String_Value then
Value.target := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_AttachRequestArguments;

package ScopesResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

package ScopesResponse_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["scopes"]);

procedure Input_ScopesResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ScopesResponse;
Success : in out Boolean) is
procedure Input_ScopesResponse_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ScopesResponse_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ScopesResponse_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  scopes
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : Scope;
begin
Input_Scope (Reader, Item, Success);
Value.scopes.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ScopesResponse_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ScopesResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_ScopesResponse_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ScopesResponse;

package StepOutArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["threadId", "singleThread", "granularity"]);

procedure Input_StepOutArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StepOutArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
StepOutArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  threadId
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.threadId := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  singleThread
if Reader.Is_Boolean_Value then
Value.singleThread := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  granularity
Value.granularity := (Is_Set => True, Value => <>);
Input_SteppingGranularity (Reader, Value.granularity.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_StepOutArguments;

package CompletionsRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_CompletionsRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out CompletionsRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
CompletionsRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "completions" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_CompletionsArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_CompletionsRequest;

package StartDebuggingRequestArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["configuration", "request"]);

procedure Input_StartDebuggingRequestArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StartDebuggingRequestArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
StartDebuggingRequestArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  configuration
Input_Any_Value (Reader, Value.configuration, Success);
   when 2 =>  --  request
Input_StartDebuggingRequestArguments_request (Reader, Value.request, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_StartDebuggingRequestArguments;

package ProgressUpdateEvent_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "event", "body"]);

package ProgressUpdateEvent_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["progressId", "message", "percentage"]);

procedure Input_ProgressUpdateEvent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ProgressUpdateEvent;
Success : in out Boolean) is
procedure Input_ProgressUpdateEvent_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ProgressUpdateEvent_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ProgressUpdateEvent_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  progressId
if Reader.Is_String_Value then
Value.progressId := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  message
if Reader.Is_String_Value then
Value.message := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  percentage
Value.percentage := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value then
if Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.percentage.Value := Float (Reader.Number_Value.Integer_Value);
elsif Reader.Number_Value.Kind = VSS.JSON.JSON_Float then
Value.percentage.Value := Float (Reader.Number_Value.Float_Value);
else
Success := False;
end if;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ProgressUpdateEvent_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ProgressUpdateEvent_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "event" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  event
if Reader.Is_String_Value and then Reader.String_Value = "progressUpdate" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  body
Input_ProgressUpdateEvent_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ProgressUpdateEvent;

package ExceptionInfoResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

package ExceptionInfoResponse_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["exceptionId", "description", "breakMode", "details"]);

procedure Input_ExceptionInfoResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ExceptionInfoResponse;
Success : in out Boolean) is
procedure Input_ExceptionInfoResponse_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ExceptionInfoResponse_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ExceptionInfoResponse_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  exceptionId
if Reader.Is_String_Value then
Value.exceptionId := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  description
if Reader.Is_String_Value then
Value.description := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  breakMode
Input_ExceptionBreakMode (Reader, Value.breakMode, Success);
   when 4 =>  --  details
Value.details := (Is_Set => True, Value => <>);
Input_ExceptionDetails (Reader, Value.details.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ExceptionInfoResponse_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ExceptionInfoResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_ExceptionInfoResponse_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ExceptionInfoResponse;

package InitializedEvent_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "event", "body"]);

procedure Input_InitializedEvent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out InitializedEvent;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
InitializedEvent_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "event" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  event
if Reader.Is_String_Value and then Reader.String_Value = "initialized" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  body
Input_Any_Value (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_InitializedEvent;

package SetExpressionResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

package SetExpressionResponse_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["value", "type", "presentationHint", "variablesReference", "namedVariables", "indexedVariables"]);

procedure Input_SetExpressionResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetExpressionResponse;
Success : in out Boolean) is
procedure Input_SetExpressionResponse_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetExpressionResponse_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
SetExpressionResponse_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  value
if Reader.Is_String_Value then
Value.value := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value then
Value.a_type := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  presentationHint
Value.presentationHint := (Is_Set => True, Value => <>);
Input_VariablePresentationHint (Reader, Value.presentationHint.Value, Success);
   when 4 =>  --  variablesReference
Value.variablesReference := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.variablesReference.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  namedVariables
Value.namedVariables := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.namedVariables.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  indexedVariables
Value.indexedVariables := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.indexedVariables.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_SetExpressionResponse_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
SetExpressionResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_SetExpressionResponse_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_SetExpressionResponse;

package StepInTarget_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["id", "label", "line", "column", "endLine", "endColumn"]);

procedure Input_StepInTarget
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StepInTarget;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
StepInTarget_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  id
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.id := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  label
if Reader.Is_String_Value then
Value.label := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  line
Value.line := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.line.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  column
Value.column := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.column.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  endLine
Value.endLine := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.endLine.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  endColumn
Value.endColumn := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.endColumn.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_StepInTarget;

package ReverseContinueResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

procedure Input_ReverseContinueResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ReverseContinueResponse;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ReverseContinueResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_Any_Value (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ReverseContinueResponse;

package OutputEvent_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "event", "body"]);

package OutputEvent_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["category", "output", "group", "variablesReference", "source", "line", "column", "data"]);

procedure Input_OutputEvent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out OutputEvent;
Success : in out Boolean) is
procedure Input_OutputEvent_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out OutputEvent_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
OutputEvent_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  category
Value.category := (Is_Set => True, Value => <>);
Input_OutputEvent_category (Reader, Value.category.Value, Success);
   when 2 =>  --  output
if Reader.Is_String_Value then
Value.output := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  group
Value.group := (Is_Set => True, Value => <>);
Input_OutputEvent_group (Reader, Value.group.Value, Success);
   when 4 =>  --  variablesReference
Value.variablesReference := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.variablesReference.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  source
Value.source := (Is_Set => True, Value => <>);
Input_Source (Reader, Value.source.Value, Success);
   when 6 =>  --  line
Value.line := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.line.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 7 =>  --  column
Value.column := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.column.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 8 =>  --  data
Input_Any_Value (Reader, Value.data, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_OutputEvent_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
OutputEvent_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "event" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  event
if Reader.Is_String_Value and then Reader.String_Value = "output" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  body
Input_OutputEvent_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_OutputEvent;

package RestartRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_RestartRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out RestartRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
RestartRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "restart" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Value.arguments := (Is_Set => True, Value => <>);
Input_RestartArguments (Reader, Value.arguments.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_RestartRequest;

package StackTraceArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["threadId", "startFrame", "levels", "format"]);

procedure Input_StackTraceArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StackTraceArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
StackTraceArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  threadId
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.threadId := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  startFrame
Value.startFrame := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.startFrame.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  levels
Value.levels := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.levels.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  format
Value.format := (Is_Set => True, Value => <>);
Input_StackFrameFormat (Reader, Value.format.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_StackTraceArguments;

package Thread_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["id", "name"]);

procedure Input_Thread
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Thread;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
Thread_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  id
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.id := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  name
if Reader.Is_String_Value then
Value.name := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_Thread;

package SetDataBreakpointsRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_SetDataBreakpointsRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetDataBreakpointsRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
SetDataBreakpointsRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "setDataBreakpoints" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_SetDataBreakpointsArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_SetDataBreakpointsRequest;

package SourceRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_SourceRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SourceRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
SourceRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "source" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_SourceArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_SourceRequest;

package PauseResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

procedure Input_PauseResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out PauseResponse;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
PauseResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_Any_Value (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_PauseResponse;

package SetFunctionBreakpointsRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_SetFunctionBreakpointsRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetFunctionBreakpointsRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
SetFunctionBreakpointsRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "setFunctionBreakpoints" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_SetFunctionBreakpointsArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_SetFunctionBreakpointsRequest;

package ProcessEvent_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "event", "body"]);

package ProcessEvent_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["name", "systemProcessId", "isLocalProcess", "startMethod", "pointerSize"]);

procedure Input_ProcessEvent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ProcessEvent;
Success : in out Boolean) is
procedure Input_ProcessEvent_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ProcessEvent_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ProcessEvent_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  name
if Reader.Is_String_Value then
Value.name := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  systemProcessId
Value.systemProcessId := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.systemProcessId.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  isLocalProcess
if Reader.Is_Boolean_Value then
Value.isLocalProcess := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  startMethod
Value.startMethod := (Is_Set => True, Value => <>);
Input_ProcessEvent_startMethod (Reader, Value.startMethod.Value, Success);
   when 5 =>  --  pointerSize
Value.pointerSize := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.pointerSize.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ProcessEvent_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ProcessEvent_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "event" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  event
if Reader.Is_String_Value and then Reader.String_Value = "process" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  body
Input_ProcessEvent_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ProcessEvent;

package NextResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

procedure Input_NextResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out NextResponse;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
NextResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_Any_Value (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_NextResponse;

package AttachResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

procedure Input_AttachResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out AttachResponse;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
AttachResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_Any_Value (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_AttachResponse;

package RestartResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

procedure Input_RestartResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out RestartResponse;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
RestartResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_Any_Value (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_RestartResponse;

package CapabilitiesEvent_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "event", "body"]);

package CapabilitiesEvent_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["capabilities"]);

procedure Input_CapabilitiesEvent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out CapabilitiesEvent;
Success : in out Boolean) is
procedure Input_CapabilitiesEvent_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out CapabilitiesEvent_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
CapabilitiesEvent_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  capabilities
Input_Capabilities (Reader, Value.capabilities, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_CapabilitiesEvent_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
CapabilitiesEvent_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "event" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  event
if Reader.Is_String_Value and then Reader.String_Value = "capabilities" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  body
Input_CapabilitiesEvent_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_CapabilitiesEvent;

package Scope_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["name", "presentationHint", "variablesReference", "namedVariables", "indexedVariables", "expensive", "source", "line", "column", "endLine", "endColumn"]);

procedure Input_Scope
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Scope;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
Scope_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  name
if Reader.Is_String_Value then
Value.name := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  presentationHint
Value.presentationHint := (Is_Set => True, Value => <>);
Input_Scope_presentationHint (Reader, Value.presentationHint.Value, Success);
   when 3 =>  --  variablesReference
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.variablesReference := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  namedVariables
Value.namedVariables := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.namedVariables.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  indexedVariables
Value.indexedVariables := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.indexedVariables.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  expensive
if Reader.Is_Boolean_Value then
Value.expensive := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 7 =>  --  source
Value.source := (Is_Set => True, Value => <>);
Input_Source (Reader, Value.source.Value, Success);
   when 8 =>  --  line
Value.line := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.line.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 9 =>  --  column
Value.column := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.column.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 10 =>  --  endLine
Value.endLine := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.endLine.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 11 =>  --  endColumn
Value.endColumn := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.endColumn.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_Scope;

package DisassembleArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["memoryReference", "offset", "instructionOffset", "instructionCount", "resolveSymbols"]);

procedure Input_DisassembleArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out DisassembleArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
DisassembleArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  memoryReference
if Reader.Is_String_Value then
Value.memoryReference := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  offset
Value.offset := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.offset.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  instructionOffset
Value.instructionOffset := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.instructionOffset.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  instructionCount
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.instructionCount := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  resolveSymbols
if Reader.Is_Boolean_Value then
Value.resolveSymbols := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_DisassembleArguments;

package SetInstructionBreakpointsRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_SetInstructionBreakpointsRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetInstructionBreakpointsRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
SetInstructionBreakpointsRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "setInstructionBreakpoints" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_SetInstructionBreakpointsArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_SetInstructionBreakpointsRequest;

package Response_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

procedure Input_Response
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Response;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
Response_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_Any_Value (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_Response;

package DataBreakpointInfoResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

package DataBreakpointInfoResponse_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["dataId", "description", "accessTypes", "canPersist"]);

procedure Input_DataBreakpointInfoResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out DataBreakpointInfoResponse;
Success : in out Boolean) is
procedure Input_DataBreakpointInfoResponse_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out DataBreakpointInfoResponse_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
DataBreakpointInfoResponse_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  dataId
if Reader.Is_String_Value then
Value.dataId := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  description
if Reader.Is_String_Value then
Value.description := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  accessTypes
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : Enum.DataBreakpointAccessType;
begin
Input_DataBreakpointAccessType (Reader, Item, Success);
Value.accessTypes.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 4 =>  --  canPersist
if Reader.Is_Boolean_Value then
Value.canPersist := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_DataBreakpointInfoResponse_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
DataBreakpointInfoResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_DataBreakpointInfoResponse_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_DataBreakpointInfoResponse;

package SourceBreakpoint_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["line", "column", "condition", "hitCondition", "logMessage"]);

procedure Input_SourceBreakpoint
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SourceBreakpoint;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
SourceBreakpoint_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  line
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.line := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  column
Value.column := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.column.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  condition
if Reader.Is_String_Value then
Value.condition := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  hitCondition
if Reader.Is_String_Value then
Value.hitCondition := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  logMessage
if Reader.Is_String_Value then
Value.logMessage := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_SourceBreakpoint;

package PauseRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_PauseRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out PauseRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
PauseRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "pause" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_PauseArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_PauseRequest;

package FunctionBreakpoint_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["name", "condition", "hitCondition"]);

procedure Input_FunctionBreakpoint
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out FunctionBreakpoint;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
FunctionBreakpoint_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  name
if Reader.Is_String_Value then
Value.name := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  condition
if Reader.Is_String_Value then
Value.condition := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  hitCondition
if Reader.Is_String_Value then
Value.hitCondition := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_FunctionBreakpoint;

package SetExpressionArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["expression", "value", "frameId", "format"]);

procedure Input_SetExpressionArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetExpressionArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
SetExpressionArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  expression
if Reader.Is_String_Value then
Value.expression := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  value
if Reader.Is_String_Value then
Value.value := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  frameId
Value.frameId := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.frameId.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  format
Value.format := (Is_Set => True, Value => <>);
Input_ValueFormat (Reader, Value.format.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_SetExpressionArguments;

package SetExceptionBreakpointsArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["filters", "filterOptions", "exceptionOptions"]);

procedure Input_SetExceptionBreakpointsArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetExceptionBreakpointsArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
SetExceptionBreakpointsArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  filters
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : VSS.Strings.Virtual_String;
begin
if Reader.Is_String_Value then
Item := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
Value.filters.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 2 =>  --  filterOptions
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : ExceptionFilterOptions;
begin
Input_ExceptionFilterOptions (Reader, Item, Success);
Value.filterOptions.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 3 =>  --  exceptionOptions
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : ExceptionOptions;
begin
Input_ExceptionOptions (Reader, Item, Success);
Value.exceptionOptions.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_SetExceptionBreakpointsArguments;

package ValueFormat_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["hex"]);

procedure Input_ValueFormat
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ValueFormat;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ValueFormat_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  hex
if Reader.Is_Boolean_Value then
Value.hex := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ValueFormat;

package RunInTerminalRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_RunInTerminalRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out RunInTerminalRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
RunInTerminalRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "runInTerminal" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_RunInTerminalRequestArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_RunInTerminalRequest;

package CompletionsArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["frameId", "text", "column", "line"]);

procedure Input_CompletionsArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out CompletionsArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
CompletionsArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  frameId
Value.frameId := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.frameId.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  text
if Reader.Is_String_Value then
Value.text := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  column
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.column := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  line
Value.line := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.line.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_CompletionsArguments;

package WriteMemoryResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

package WriteMemoryResponse_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["offset", "bytesWritten"]);

procedure Input_WriteMemoryResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out WriteMemoryResponse;
Success : in out Boolean) is
procedure Input_WriteMemoryResponse_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out WriteMemoryResponse_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
WriteMemoryResponse_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  offset
Value.offset := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.offset.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  bytesWritten
Value.bytesWritten := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.bytesWritten.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_WriteMemoryResponse_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
WriteMemoryResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Value.a_body := (Is_Set => True, Value => <>);
Input_WriteMemoryResponse_body (Reader, Value.a_body.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_WriteMemoryResponse;

package ReverseContinueArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["threadId", "singleThread"]);

procedure Input_ReverseContinueArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ReverseContinueArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ReverseContinueArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  threadId
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.threadId := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  singleThread
if Reader.Is_Boolean_Value then
Value.singleThread := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ReverseContinueArguments;

package RunInTerminalResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

package RunInTerminalResponse_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["processId", "shellProcessId"]);

procedure Input_RunInTerminalResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out RunInTerminalResponse;
Success : in out Boolean) is
procedure Input_RunInTerminalResponse_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out RunInTerminalResponse_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
RunInTerminalResponse_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  processId
Value.processId := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.processId.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  shellProcessId
Value.shellProcessId := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.shellProcessId.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_RunInTerminalResponse_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
RunInTerminalResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_RunInTerminalResponse_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_RunInTerminalResponse;

package DisconnectArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["restart", "terminateDebuggee", "suspendDebuggee"]);

procedure Input_DisconnectArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out DisconnectArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
DisconnectArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  restart
if Reader.Is_Boolean_Value then
Value.restart := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  terminateDebuggee
if Reader.Is_Boolean_Value then
Value.terminateDebuggee := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  suspendDebuggee
if Reader.Is_Boolean_Value then
Value.suspendDebuggee := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_DisconnectArguments;

package Module_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["id", "name", "path", "isOptimized", "isUserCode", "version", "symbolStatus", "symbolFilePath", "dateTimeStamp", "addressRange"]);

procedure Input_Module
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Module;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
Module_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  id
Value.id := (False, Integer => <>);
if Reader.Is_String_Value then
Value.id := (True, Reader.String_Value);
Reader.Read_Next;
elsif Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.id.Integer := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  name
if Reader.Is_String_Value then
Value.name := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  path
if Reader.Is_String_Value then
Value.path := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  isOptimized
if Reader.Is_Boolean_Value then
Value.isOptimized := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  isUserCode
if Reader.Is_Boolean_Value then
Value.isUserCode := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  version
if Reader.Is_String_Value then
Value.version := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 7 =>  --  symbolStatus
if Reader.Is_String_Value then
Value.symbolStatus := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 8 =>  --  symbolFilePath
if Reader.Is_String_Value then
Value.symbolFilePath := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 9 =>  --  dateTimeStamp
if Reader.Is_String_Value then
Value.dateTimeStamp := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 10 =>  --  addressRange
if Reader.Is_String_Value then
Value.addressRange := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_Module;

package GotoTargetsRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_GotoTargetsRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out GotoTargetsRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
GotoTargetsRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "gotoTargets" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_GotoTargetsArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_GotoTargetsRequest;

package ThreadsResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

package ThreadsResponse_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["threads"]);

procedure Input_ThreadsResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ThreadsResponse;
Success : in out Boolean) is
procedure Input_ThreadsResponse_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ThreadsResponse_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ThreadsResponse_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  threads
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : Thread;
begin
Input_Thread (Reader, Item, Success);
Value.threads.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ThreadsResponse_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ThreadsResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_ThreadsResponse_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ThreadsResponse;

package SetDataBreakpointsResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

package SetDataBreakpointsResponse_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["breakpoints"]);

procedure Input_SetDataBreakpointsResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetDataBreakpointsResponse;
Success : in out Boolean) is
procedure Input_SetDataBreakpointsResponse_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetDataBreakpointsResponse_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
SetDataBreakpointsResponse_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  breakpoints
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : Breakpoint;
begin
Input_Breakpoint (Reader, Item, Success);
Value.breakpoints.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_SetDataBreakpointsResponse_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
SetDataBreakpointsResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_SetDataBreakpointsResponse_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_SetDataBreakpointsResponse;

package DataBreakpoint_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["dataId", "accessType", "condition", "hitCondition"]);

procedure Input_DataBreakpoint
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out DataBreakpoint;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
DataBreakpoint_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  dataId
if Reader.Is_String_Value then
Value.dataId := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  accessType
Value.accessType := (Is_Set => True, Value => <>);
Input_DataBreakpointAccessType (Reader, Value.accessType.Value, Success);
   when 3 =>  --  condition
if Reader.Is_String_Value then
Value.condition := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  hitCondition
if Reader.Is_String_Value then
Value.hitCondition := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_DataBreakpoint;

package SetDataBreakpointsArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["breakpoints"]);

procedure Input_SetDataBreakpointsArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetDataBreakpointsArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
SetDataBreakpointsArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  breakpoints
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : DataBreakpoint;
begin
Input_DataBreakpoint (Reader, Item, Success);
Value.breakpoints.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_SetDataBreakpointsArguments;

package ExceptionPathSegment_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["negate", "names"]);

procedure Input_ExceptionPathSegment
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ExceptionPathSegment;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ExceptionPathSegment_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  negate
if Reader.Is_Boolean_Value then
Value.negate := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  names
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : VSS.Strings.Virtual_String;
begin
if Reader.Is_String_Value then
Item := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
Value.names.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ExceptionPathSegment;

package Message_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["id", "format", "variables", "sendTelemetry", "showUser", "url", "urlLabel"]);

procedure Input_Message
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Message;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
Message_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  id
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.id := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  format
if Reader.Is_String_Value then
Value.format := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  variables
Input_Any_Value (Reader, Value.variables, Success);
   when 4 =>  --  sendTelemetry
if Reader.Is_Boolean_Value then
Value.sendTelemetry := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  showUser
if Reader.Is_Boolean_Value then
Value.showUser := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  url
if Reader.Is_String_Value then
Value.url := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 7 =>  --  urlLabel
if Reader.Is_String_Value then
Value.urlLabel := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_Message;

package SourceResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

package SourceResponse_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["content", "mimeType"]);

procedure Input_SourceResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SourceResponse;
Success : in out Boolean) is
procedure Input_SourceResponse_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SourceResponse_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
SourceResponse_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  content
if Reader.Is_String_Value then
Value.content := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  mimeType
if Reader.Is_String_Value then
Value.mimeType := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_SourceResponse_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
SourceResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_SourceResponse_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_SourceResponse;

package ContinueResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

package ContinueResponse_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["allThreadsContinued"]);

procedure Input_ContinueResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ContinueResponse;
Success : in out Boolean) is
procedure Input_ContinueResponse_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ContinueResponse_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ContinueResponse_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  allThreadsContinued
if Reader.Is_Boolean_Value then
Value.allThreadsContinued := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ContinueResponse_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ContinueResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_ContinueResponse_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ContinueResponse;

package RestartFrameResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

procedure Input_RestartFrameResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out RestartFrameResponse;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
RestartFrameResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_Any_Value (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_RestartFrameResponse;

package StepInArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["threadId", "singleThread", "targetId", "granularity"]);

procedure Input_StepInArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StepInArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
StepInArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  threadId
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.threadId := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  singleThread
if Reader.Is_Boolean_Value then
Value.singleThread := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  targetId
Value.targetId := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.targetId.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  granularity
Value.granularity := (Is_Set => True, Value => <>);
Input_SteppingGranularity (Reader, Value.granularity.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_StepInArguments;

package LaunchResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

procedure Input_LaunchResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out LaunchResponse;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
LaunchResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_Any_Value (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_LaunchResponse;

package StepInResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

procedure Input_StepInResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StepInResponse;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
StepInResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_Any_Value (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_StepInResponse;

package TerminateArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["restart"]);

procedure Input_TerminateArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out TerminateArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
TerminateArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  restart
if Reader.Is_Boolean_Value then
Value.restart := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_TerminateArguments;

package LaunchRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_LaunchRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out LaunchRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
LaunchRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "launch" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_LaunchRequestArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_LaunchRequest;

package StepOutResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

procedure Input_StepOutResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StepOutResponse;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
StepOutResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_Any_Value (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_StepOutResponse;

package EvaluateRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_EvaluateRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out EvaluateRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
EvaluateRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "evaluate" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_EvaluateArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_EvaluateRequest;

package ContinueArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["threadId", "singleThread"]);

procedure Input_ContinueArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ContinueArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ContinueArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  threadId
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.threadId := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  singleThread
if Reader.Is_Boolean_Value then
Value.singleThread := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ContinueArguments;

package StepBackArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["threadId", "singleThread", "granularity"]);

procedure Input_StepBackArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StepBackArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
StepBackArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  threadId
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.threadId := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  singleThread
if Reader.Is_Boolean_Value then
Value.singleThread := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  granularity
Value.granularity := (Is_Set => True, Value => <>);
Input_SteppingGranularity (Reader, Value.granularity.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_StepBackArguments;

package BreakpointLocationsArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["source", "line", "column", "endLine", "endColumn"]);

procedure Input_BreakpointLocationsArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out BreakpointLocationsArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
BreakpointLocationsArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  source
Input_Source (Reader, Value.source, Success);
   when 2 =>  --  line
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.line := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  column
Value.column := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.column.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  endLine
Value.endLine := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.endLine.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  endColumn
Value.endColumn := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.endColumn.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_BreakpointLocationsArguments;

package CancelArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["requestId", "progressId"]);

procedure Input_CancelArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out CancelArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
CancelArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  requestId
Value.requestId := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.requestId.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  progressId
if Reader.Is_String_Value then
Value.progressId := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_CancelArguments;

package CompletionsResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

package CompletionsResponse_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["targets"]);

procedure Input_CompletionsResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out CompletionsResponse;
Success : in out Boolean) is
procedure Input_CompletionsResponse_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out CompletionsResponse_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
CompletionsResponse_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  targets
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : CompletionItem;
begin
Input_CompletionItem (Reader, Item, Success);
Value.targets.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_CompletionsResponse_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
CompletionsResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_CompletionsResponse_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_CompletionsResponse;

package Breakpoint_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["id", "verified", "message", "source", "line", "column", "endLine", "endColumn", "instructionReference", "offset"]);

procedure Input_Breakpoint
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Breakpoint;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
Breakpoint_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  id
Value.id := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.id.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  verified
if Reader.Is_Boolean_Value then
Value.verified := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  message
if Reader.Is_String_Value then
Value.message := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  source
Value.source := (Is_Set => True, Value => <>);
Input_Source (Reader, Value.source.Value, Success);
   when 5 =>  --  line
Value.line := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.line.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  column
Value.column := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.column.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 7 =>  --  endLine
Value.endLine := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.endLine.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 8 =>  --  endColumn
Value.endColumn := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.endColumn.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 9 =>  --  instructionReference
if Reader.Is_String_Value then
Value.instructionReference := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 10 =>  --  offset
Value.offset := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.offset.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_Breakpoint;

package Source_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["name", "path", "sourceReference", "presentationHint", "origin", "sources", "adapterData", "checksums"]);

procedure Input_Source
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Source;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
Source_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  name
if Reader.Is_String_Value then
Value.name := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  path
if Reader.Is_String_Value then
Value.path := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  sourceReference
Value.sourceReference := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.sourceReference.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  presentationHint
Value.presentationHint := (Is_Set => True, Value => <>);
Input_Source_presentationHint (Reader, Value.presentationHint.Value, Success);
   when 5 =>  --  origin
if Reader.Is_String_Value then
Value.origin := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  sources
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : Source;
begin
Input_Source (Reader, Item, Success);
Value.sources.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 7 =>  --  adapterData
Input_Any_Value (Reader, Value.adapterData, Success);
   when 8 =>  --  checksums
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : Checksum;
begin
Input_Checksum (Reader, Item, Success);
Value.checksums.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_Source;

package WriteMemoryArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["memoryReference", "offset", "allowPartial", "data"]);

procedure Input_WriteMemoryArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out WriteMemoryArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
WriteMemoryArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  memoryReference
if Reader.Is_String_Value then
Value.memoryReference := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  offset
Value.offset := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.offset.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  allowPartial
if Reader.Is_Boolean_Value then
Value.allowPartial := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  data
if Reader.Is_String_Value then
Value.data := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_WriteMemoryArguments;

procedure Input_ConfigurationDoneArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ConfigurationDoneArguments;
Success : in out Boolean) is
begin
Input_Any_Value (Reader, Value, Success);
end Input_ConfigurationDoneArguments;

package StepOutRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_StepOutRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StepOutRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
StepOutRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "stepOut" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_StepOutArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_StepOutRequest;

package Request_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_Request
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Request;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
Request_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_Any_Value (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_Request;

package LoadedSourceEvent_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "event", "body"]);

package LoadedSourceEvent_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["reason", "source"]);

procedure Input_LoadedSourceEvent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out LoadedSourceEvent;
Success : in out Boolean) is
procedure Input_LoadedSourceEvent_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out LoadedSourceEvent_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
LoadedSourceEvent_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  reason
Input_LoadedSourceEvent_reason (Reader, Value.reason, Success);
   when 2 =>  --  source
Input_Source (Reader, Value.source, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_LoadedSourceEvent_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
LoadedSourceEvent_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "event" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  event
if Reader.Is_String_Value and then Reader.String_Value = "loadedSource" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  body
Input_LoadedSourceEvent_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_LoadedSourceEvent;

package StackFrameFormat_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["hex", "parameters", "parameterTypes", "parameterNames", "parameterValues", "line", "module", "includeAll"]);

procedure Input_StackFrameFormat
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StackFrameFormat;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
StackFrameFormat_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  hex
if Reader.Is_Boolean_Value then
Value.hex := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  parameters
if Reader.Is_Boolean_Value then
Value.parameters := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  parameterTypes
if Reader.Is_Boolean_Value then
Value.parameterTypes := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  parameterNames
if Reader.Is_Boolean_Value then
Value.parameterNames := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  parameterValues
if Reader.Is_Boolean_Value then
Value.parameterValues := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  line
if Reader.Is_Boolean_Value then
Value.line := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 7 =>  --  module
if Reader.Is_Boolean_Value then
Value.module := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 8 =>  --  includeAll
if Reader.Is_Boolean_Value then
Value.includeAll := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_StackFrameFormat;

package DisassembleRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_DisassembleRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out DisassembleRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
DisassembleRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "disassemble" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_DisassembleArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_DisassembleRequest;

package ReadMemoryResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

package ReadMemoryResponse_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["address", "unreadableBytes", "data"]);

procedure Input_ReadMemoryResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ReadMemoryResponse;
Success : in out Boolean) is
procedure Input_ReadMemoryResponse_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ReadMemoryResponse_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ReadMemoryResponse_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  address
if Reader.Is_String_Value then
Value.address := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  unreadableBytes
Value.unreadableBytes := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.unreadableBytes.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  data
if Reader.Is_String_Value then
Value.data := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ReadMemoryResponse_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ReadMemoryResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Value.a_body := (Is_Set => True, Value => <>);
Input_ReadMemoryResponse_body (Reader, Value.a_body.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ReadMemoryResponse;

package StepBackRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_StepBackRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StepBackRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
StepBackRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "stepBack" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_StepBackArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_StepBackRequest;

package ProtocolMessage_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type"]);

procedure Input_ProtocolMessage
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ProtocolMessage;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ProtocolMessage_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
Input_ProtocolMessage_type (Reader, Value.a_type, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ProtocolMessage;

package ThreadsRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_ThreadsRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ThreadsRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ThreadsRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "threads" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_Any_Value (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ThreadsRequest;

package VariablesResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

package VariablesResponse_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["variables"]);

procedure Input_VariablesResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out VariablesResponse;
Success : in out Boolean) is
procedure Input_VariablesResponse_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out VariablesResponse_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
VariablesResponse_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  variables
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : Variable;
begin
Input_Variable (Reader, Item, Success);
Value.variables.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_VariablesResponse_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
VariablesResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_VariablesResponse_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_VariablesResponse;

package RunInTerminalRequestArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["kind", "title", "cwd", "args", "env", "argsCanBeInterpretedByShell"]);

procedure Input_RunInTerminalRequestArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out RunInTerminalRequestArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
RunInTerminalRequestArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  kind
Value.kind := (Is_Set => True, Value => <>);
Input_RunInTerminalRequestArguments_kind (Reader, Value.kind.Value, Success);
   when 2 =>  --  title
if Reader.Is_String_Value then
Value.title := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  cwd
if Reader.Is_String_Value then
Value.cwd := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  args
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : VSS.Strings.Virtual_String;
begin
if Reader.Is_String_Value then
Item := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
Value.args.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 5 =>  --  env
Input_Any_Value (Reader, Value.env, Success);
   when 6 =>  --  argsCanBeInterpretedByShell
if Reader.Is_Boolean_Value then
Value.argsCanBeInterpretedByShell := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_RunInTerminalRequestArguments;

package TerminateRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_TerminateRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out TerminateRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
TerminateRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "terminate" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Value.arguments := (Is_Set => True, Value => <>);
Input_TerminateArguments (Reader, Value.arguments.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_TerminateRequest;

package VariablesArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["variablesReference", "filter", "start", "count", "format"]);

procedure Input_VariablesArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out VariablesArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
VariablesArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  variablesReference
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.variablesReference := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  filter
Value.filter := (Is_Set => True, Value => <>);
Input_VariablesArguments_filter (Reader, Value.filter.Value, Success);
   when 3 =>  --  start
Value.start := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.start.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  count
Value.count := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.count.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  format
Value.format := (Is_Set => True, Value => <>);
Input_ValueFormat (Reader, Value.format.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_VariablesArguments;

package InitializeRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_InitializeRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out InitializeRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
InitializeRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "initialize" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_InitializeRequestArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_InitializeRequest;

package BreakpointLocationsResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

package BreakpointLocationsResponse_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["breakpoints"]);

procedure Input_BreakpointLocationsResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out BreakpointLocationsResponse;
Success : in out Boolean) is
procedure Input_BreakpointLocationsResponse_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out BreakpointLocationsResponse_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
BreakpointLocationsResponse_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  breakpoints
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : BreakpointLocation;
begin
Input_BreakpointLocation (Reader, Item, Success);
Value.breakpoints.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_BreakpointLocationsResponse_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
BreakpointLocationsResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_BreakpointLocationsResponse_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_BreakpointLocationsResponse;

package VariablePresentationHint_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["kind", "attributes", "visibility", "lazy"]);

procedure Input_VariablePresentationHint
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out VariablePresentationHint;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
VariablePresentationHint_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  kind
Value.kind := (Is_Set => True, Value => <>);
Input_VariablePresentationHint_kind (Reader, Value.kind.Value, Success);
   when 2 =>  --  attributes
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : Enum.VariablePresentationHint_attributes;
begin
Input_VariablePresentationHint_attributes (Reader, Item, Success);
Value.attributes.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 3 =>  --  visibility
Value.visibility := (Is_Set => True, Value => <>);
Input_VariablePresentationHint_visibility (Reader, Value.visibility.Value, Success);
   when 4 =>  --  lazy
if Reader.Is_Boolean_Value then
Value.lazy := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_VariablePresentationHint;

package DisassembledInstruction_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["address", "instructionBytes", "instruction", "symbol", "location", "line", "column", "endLine", "endColumn"]);

procedure Input_DisassembledInstruction
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out DisassembledInstruction;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
DisassembledInstruction_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  address
if Reader.Is_String_Value then
Value.address := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  instructionBytes
if Reader.Is_String_Value then
Value.instructionBytes := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  instruction
if Reader.Is_String_Value then
Value.instruction := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  symbol
if Reader.Is_String_Value then
Value.symbol := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  location
Value.location := (Is_Set => True, Value => <>);
Input_Source (Reader, Value.location.Value, Success);
   when 6 =>  --  line
Value.line := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.line.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 7 =>  --  column
Value.column := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.column.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 8 =>  --  endLine
Value.endLine := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.endLine.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 9 =>  --  endColumn
Value.endColumn := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.endColumn.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_DisassembledInstruction;

package PauseArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["threadId"]);

procedure Input_PauseArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out PauseArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
PauseArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  threadId
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.threadId := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_PauseArguments;

package CancelResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

procedure Input_CancelResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out CancelResponse;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
CancelResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_Any_Value (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_CancelResponse;

package InitializeRequestArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["clientID", "clientName", "adapterID", "locale", "linesStartAt1", "columnsStartAt1", "pathFormat", "supportsVariableType", "supportsVariablePaging", "supportsRunInTerminalRequest", "supportsMemoryReferences", "supportsProgressReporting", "supportsInvalidatedEvent", "supportsMemoryEvent", "supportsArgsCanBeInterpretedByShell", "supportsStartDebuggingRequest"]);

procedure Input_InitializeRequestArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out InitializeRequestArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
InitializeRequestArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  clientID
if Reader.Is_String_Value then
Value.clientID := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  clientName
if Reader.Is_String_Value then
Value.clientName := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  adapterID
if Reader.Is_String_Value then
Value.adapterID := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  locale
if Reader.Is_String_Value then
Value.locale := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  linesStartAt1
if Reader.Is_Boolean_Value then
Value.linesStartAt1 := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  columnsStartAt1
if Reader.Is_Boolean_Value then
Value.columnsStartAt1 := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 7 =>  --  pathFormat
Value.pathFormat := (Is_Set => True, Value => <>);
Input_InitializeRequestArguments_pathFormat (Reader, Value.pathFormat.Value, Success);
   when 8 =>  --  supportsVariableType
if Reader.Is_Boolean_Value then
Value.supportsVariableType := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 9 =>  --  supportsVariablePaging
if Reader.Is_Boolean_Value then
Value.supportsVariablePaging := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 10 =>  --  supportsRunInTerminalRequest
if Reader.Is_Boolean_Value then
Value.supportsRunInTerminalRequest := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 11 =>  --  supportsMemoryReferences
if Reader.Is_Boolean_Value then
Value.supportsMemoryReferences := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 12 =>  --  supportsProgressReporting
if Reader.Is_Boolean_Value then
Value.supportsProgressReporting := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 13 =>  --  supportsInvalidatedEvent
if Reader.Is_Boolean_Value then
Value.supportsInvalidatedEvent := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 14 =>  --  supportsMemoryEvent
if Reader.Is_Boolean_Value then
Value.supportsMemoryEvent := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 15 =>  --  supportsArgsCanBeInterpretedByShell
if Reader.Is_Boolean_Value then
Value.supportsArgsCanBeInterpretedByShell := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 16 =>  --  supportsStartDebuggingRequest
if Reader.Is_Boolean_Value then
Value.supportsStartDebuggingRequest := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_InitializeRequestArguments;

package SetInstructionBreakpointsResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

package SetInstructionBreakpointsResponse_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["breakpoints"]);

procedure Input_SetInstructionBreakpointsResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetInstructionBreakpointsResponse;
Success : in out Boolean) is
procedure Input_SetInstructionBreakpointsResponse_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetInstructionBreakpointsResponse_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
SetInstructionBreakpointsResponse_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  breakpoints
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : Breakpoint;
begin
Input_Breakpoint (Reader, Item, Success);
Value.breakpoints.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_SetInstructionBreakpointsResponse_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
SetInstructionBreakpointsResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_SetInstructionBreakpointsResponse_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_SetInstructionBreakpointsResponse;

package CancelRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_CancelRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out CancelRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
CancelRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "cancel" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Value.arguments := (Is_Set => True, Value => <>);
Input_CancelArguments (Reader, Value.arguments.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_CancelRequest;

package ProgressEndEvent_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "event", "body"]);

package ProgressEndEvent_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["progressId", "message"]);

procedure Input_ProgressEndEvent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ProgressEndEvent;
Success : in out Boolean) is
procedure Input_ProgressEndEvent_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ProgressEndEvent_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ProgressEndEvent_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  progressId
if Reader.Is_String_Value then
Value.progressId := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  message
if Reader.Is_String_Value then
Value.message := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ProgressEndEvent_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ProgressEndEvent_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "event" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  event
if Reader.Is_String_Value and then Reader.String_Value = "progressEnd" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  body
Input_ProgressEndEvent_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ProgressEndEvent;

package Event_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "event", "body"]);

procedure Input_Event
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Event;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
Event_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "event" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  event
if Reader.Is_String_Value then
Value.event := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  body
Input_Any_Value (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_Event;

package VariablesRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_VariablesRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out VariablesRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
VariablesRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "variables" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_VariablesArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_VariablesRequest;

package ExceptionOptions_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["path", "breakMode"]);

procedure Input_ExceptionOptions
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ExceptionOptions;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ExceptionOptions_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  path
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : ExceptionPathSegment;
begin
Input_ExceptionPathSegment (Reader, Item, Success);
Value.path.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 2 =>  --  breakMode
Input_ExceptionBreakMode (Reader, Value.breakMode, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ExceptionOptions;

package TerminatedEvent_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "event", "body"]);

package TerminatedEvent_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["restart"]);

procedure Input_TerminatedEvent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out TerminatedEvent;
Success : in out Boolean) is
procedure Input_TerminatedEvent_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out TerminatedEvent_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
TerminatedEvent_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  restart
Input_Any_Value (Reader, Value.restart, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_TerminatedEvent_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
TerminatedEvent_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "event" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  event
if Reader.Is_String_Value and then Reader.String_Value = "terminated" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  body
Value.a_body := (Is_Set => True, Value => <>);
Input_TerminatedEvent_body (Reader, Value.a_body.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_TerminatedEvent;

package StartDebuggingRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_StartDebuggingRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StartDebuggingRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
StartDebuggingRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "startDebugging" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_StartDebuggingRequestArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_StartDebuggingRequest;

package ThreadEvent_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "event", "body"]);

package ThreadEvent_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["reason", "threadId"]);

procedure Input_ThreadEvent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ThreadEvent;
Success : in out Boolean) is
procedure Input_ThreadEvent_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ThreadEvent_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ThreadEvent_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  reason
Input_ThreadEvent_reason (Reader, Value.reason, Success);
   when 2 =>  --  threadId
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.threadId := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ThreadEvent_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ThreadEvent_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "event" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  event
if Reader.Is_String_Value and then Reader.String_Value = "thread" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  body
Input_ThreadEvent_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ThreadEvent;

package GotoTargetsResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

package GotoTargetsResponse_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["targets"]);

procedure Input_GotoTargetsResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out GotoTargetsResponse;
Success : in out Boolean) is
procedure Input_GotoTargetsResponse_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out GotoTargetsResponse_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
GotoTargetsResponse_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  targets
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : GotoTarget;
begin
Input_GotoTarget (Reader, Item, Success);
Value.targets.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_GotoTargetsResponse_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
GotoTargetsResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_GotoTargetsResponse_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_GotoTargetsResponse;

package CompletionItem_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["label", "text", "sortText", "detail", "type", "start", "length", "selectionStart", "selectionLength"]);

procedure Input_CompletionItem
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out CompletionItem;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
CompletionItem_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  label
if Reader.Is_String_Value then
Value.label := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  text
if Reader.Is_String_Value then
Value.text := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  sortText
if Reader.Is_String_Value then
Value.sortText := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  detail
if Reader.Is_String_Value then
Value.detail := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  type
Value.a_type := (Is_Set => True, Value => <>);
Input_CompletionItemType (Reader, Value.a_type.Value, Success);
   when 6 =>  --  start
Value.start := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.start.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 7 =>  --  length
Value.length := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.length.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 8 =>  --  selectionStart
Value.selectionStart := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.selectionStart.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 9 =>  --  selectionLength
Value.selectionLength := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.selectionLength.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_CompletionItem;

package ScopesArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["frameId"]);

procedure Input_ScopesArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ScopesArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ScopesArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  frameId
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.frameId := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ScopesArguments;

package ErrorResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

package ErrorResponse_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["error"]);

procedure Input_ErrorResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ErrorResponse;
Success : in out Boolean) is
procedure Input_ErrorResponse_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ErrorResponse_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ErrorResponse_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  error
Value.error := (Is_Set => True, Value => <>);
Input_Message (Reader, Value.error.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ErrorResponse_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ErrorResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_ErrorResponse_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ErrorResponse;

package SetInstructionBreakpointsArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["breakpoints"]);

procedure Input_SetInstructionBreakpointsArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetInstructionBreakpointsArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
SetInstructionBreakpointsArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  breakpoints
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : InstructionBreakpoint;
begin
Input_InstructionBreakpoint (Reader, Item, Success);
Value.breakpoints.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_SetInstructionBreakpointsArguments;

package GotoArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["threadId", "targetId"]);

procedure Input_GotoArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out GotoArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
GotoArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  threadId
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.threadId := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  targetId
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.targetId := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_GotoArguments;

package BreakpointEvent_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "event", "body"]);

package BreakpointEvent_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["reason", "breakpoint"]);

procedure Input_BreakpointEvent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out BreakpointEvent;
Success : in out Boolean) is
procedure Input_BreakpointEvent_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out BreakpointEvent_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
BreakpointEvent_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  reason
Input_BreakpointEvent_reason (Reader, Value.reason, Success);
   when 2 =>  --  breakpoint
Input_Breakpoint (Reader, Value.breakpoint, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_BreakpointEvent_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
BreakpointEvent_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "event" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  event
if Reader.Is_String_Value and then Reader.String_Value = "breakpoint" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  body
Input_BreakpointEvent_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_BreakpointEvent;

package GotoTarget_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["id", "label", "line", "column", "endLine", "endColumn", "instructionPointerReference"]);

procedure Input_GotoTarget
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out GotoTarget;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
GotoTarget_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  id
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.id := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  label
if Reader.Is_String_Value then
Value.label := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  line
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.line := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  column
Value.column := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.column.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  endLine
Value.endLine := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.endLine.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  endColumn
Value.endColumn := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.endColumn.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 7 =>  --  instructionPointerReference
if Reader.Is_String_Value then
Value.instructionPointerReference := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_GotoTarget;

package ReadMemoryRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_ReadMemoryRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ReadMemoryRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ReadMemoryRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "readMemory" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_ReadMemoryArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ReadMemoryRequest;

package ModulesArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["startModule", "moduleCount"]);

procedure Input_ModulesArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ModulesArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ModulesArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  startModule
Value.startModule := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.startModule.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  moduleCount
Value.moduleCount := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.moduleCount.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ModulesArguments;

package NextRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_NextRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out NextRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
NextRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "next" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_NextArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_NextRequest;

package ProgressStartEvent_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "event", "body"]);

package ProgressStartEvent_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["progressId", "title", "requestId", "cancellable", "message", "percentage"]);

procedure Input_ProgressStartEvent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ProgressStartEvent;
Success : in out Boolean) is
procedure Input_ProgressStartEvent_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ProgressStartEvent_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ProgressStartEvent_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  progressId
if Reader.Is_String_Value then
Value.progressId := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  title
if Reader.Is_String_Value then
Value.title := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  requestId
Value.requestId := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.requestId.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  cancellable
if Reader.Is_Boolean_Value then
Value.cancellable := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  message
if Reader.Is_String_Value then
Value.message := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  percentage
Value.percentage := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value then
if Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.percentage.Value := Float (Reader.Number_Value.Integer_Value);
elsif Reader.Number_Value.Kind = VSS.JSON.JSON_Float then
Value.percentage.Value := Float (Reader.Number_Value.Float_Value);
else
Success := False;
end if;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ProgressStartEvent_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ProgressStartEvent_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "event" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  event
if Reader.Is_String_Value and then Reader.String_Value = "progressStart" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  body
Input_ProgressStartEvent_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ProgressStartEvent;

package SetVariableResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

package SetVariableResponse_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["value", "type", "variablesReference", "namedVariables", "indexedVariables"]);

procedure Input_SetVariableResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetVariableResponse;
Success : in out Boolean) is
procedure Input_SetVariableResponse_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetVariableResponse_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
SetVariableResponse_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  value
if Reader.Is_String_Value then
Value.value := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value then
Value.a_type := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  variablesReference
Value.variablesReference := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.variablesReference.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  namedVariables
Value.namedVariables := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.namedVariables.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  indexedVariables
Value.indexedVariables := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.indexedVariables.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_SetVariableResponse_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
SetVariableResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_SetVariableResponse_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_SetVariableResponse;

package BreakpointLocation_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["line", "column", "endLine", "endColumn"]);

procedure Input_BreakpointLocation
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out BreakpointLocation;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
BreakpointLocation_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  line
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.line := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  column
Value.column := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.column.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  endLine
Value.endLine := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.endLine.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  endColumn
Value.endColumn := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.endColumn.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_BreakpointLocation;

package RestartFrameArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["frameId"]);

procedure Input_RestartFrameArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out RestartFrameArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
RestartFrameArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  frameId
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.frameId := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_RestartFrameArguments;

package DisconnectResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

procedure Input_DisconnectResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out DisconnectResponse;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
DisconnectResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_Any_Value (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_DisconnectResponse;

package SetExceptionBreakpointsRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_SetExceptionBreakpointsRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetExceptionBreakpointsRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
SetExceptionBreakpointsRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "setExceptionBreakpoints" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_SetExceptionBreakpointsArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_SetExceptionBreakpointsRequest;

package WriteMemoryRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_WriteMemoryRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out WriteMemoryRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
WriteMemoryRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "writeMemory" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_WriteMemoryArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_WriteMemoryRequest;

package DataBreakpointInfoArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["variablesReference", "name", "frameId"]);

procedure Input_DataBreakpointInfoArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out DataBreakpointInfoArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
DataBreakpointInfoArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  variablesReference
Value.variablesReference := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.variablesReference.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  name
if Reader.Is_String_Value then
Value.name := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  frameId
Value.frameId := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.frameId.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_DataBreakpointInfoArguments;

package InitializeResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

procedure Input_InitializeResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out InitializeResponse;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
InitializeResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Value.a_body := (Is_Set => True, Value => <>);
Input_Capabilities (Reader, Value.a_body.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_InitializeResponse;

package ConfigurationDoneResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

procedure Input_ConfigurationDoneResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ConfigurationDoneResponse;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ConfigurationDoneResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_Any_Value (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ConfigurationDoneResponse;

package StepInTargetsArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["frameId"]);

procedure Input_StepInTargetsArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StepInTargetsArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
StepInTargetsArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  frameId
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.frameId := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_StepInTargetsArguments;

package EvaluateArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["expression", "frameId", "context", "format"]);

procedure Input_EvaluateArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out EvaluateArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
EvaluateArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  expression
if Reader.Is_String_Value then
Value.expression := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  frameId
Value.frameId := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.frameId.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  context
Value.context := (Is_Set => True, Value => <>);
Input_EvaluateArguments_context (Reader, Value.context.Value, Success);
   when 4 =>  --  format
Value.format := (Is_Set => True, Value => <>);
Input_ValueFormat (Reader, Value.format.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_EvaluateArguments;

package SetFunctionBreakpointsArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["breakpoints"]);

procedure Input_SetFunctionBreakpointsArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetFunctionBreakpointsArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
SetFunctionBreakpointsArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  breakpoints
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : FunctionBreakpoint;
begin
Input_FunctionBreakpoint (Reader, Item, Success);
Value.breakpoints.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_SetFunctionBreakpointsArguments;

package GotoRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_GotoRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out GotoRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
GotoRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "goto" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_GotoArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_GotoRequest;

package SetFunctionBreakpointsResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

package SetFunctionBreakpointsResponse_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["breakpoints"]);

procedure Input_SetFunctionBreakpointsResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetFunctionBreakpointsResponse;
Success : in out Boolean) is
procedure Input_SetFunctionBreakpointsResponse_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetFunctionBreakpointsResponse_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
SetFunctionBreakpointsResponse_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  breakpoints
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : Breakpoint;
begin
Input_Breakpoint (Reader, Item, Success);
Value.breakpoints.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_SetFunctionBreakpointsResponse_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
SetFunctionBreakpointsResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_SetFunctionBreakpointsResponse_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_SetFunctionBreakpointsResponse;

package ExceptionInfoArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["threadId"]);

procedure Input_ExceptionInfoArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ExceptionInfoArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ExceptionInfoArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  threadId
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.threadId := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ExceptionInfoArguments;

package StackTraceRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_StackTraceRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StackTraceRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
StackTraceRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "stackTrace" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_StackTraceArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_StackTraceRequest;

package EvaluateResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

package EvaluateResponse_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["result", "type", "presentationHint", "variablesReference", "namedVariables", "indexedVariables", "memoryReference"]);

procedure Input_EvaluateResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out EvaluateResponse;
Success : in out Boolean) is
procedure Input_EvaluateResponse_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out EvaluateResponse_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
EvaluateResponse_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  result
if Reader.Is_String_Value then
Value.result := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value then
Value.a_type := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  presentationHint
Value.presentationHint := (Is_Set => True, Value => <>);
Input_VariablePresentationHint (Reader, Value.presentationHint.Value, Success);
   when 4 =>  --  variablesReference
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.variablesReference := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  namedVariables
Value.namedVariables := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.namedVariables.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  indexedVariables
Value.indexedVariables := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.indexedVariables.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 7 =>  --  memoryReference
if Reader.Is_String_Value then
Value.memoryReference := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_EvaluateResponse_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
EvaluateResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_EvaluateResponse_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_EvaluateResponse;

package ReverseContinueRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_ReverseContinueRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ReverseContinueRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ReverseContinueRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "reverseContinue" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_ReverseContinueArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ReverseContinueRequest;

package ModulesRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_ModulesRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ModulesRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ModulesRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "modules" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_ModulesArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ModulesRequest;

package SetBreakpointsResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

package SetBreakpointsResponse_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["breakpoints"]);

procedure Input_SetBreakpointsResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetBreakpointsResponse;
Success : in out Boolean) is
procedure Input_SetBreakpointsResponse_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetBreakpointsResponse_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
SetBreakpointsResponse_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  breakpoints
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : Breakpoint;
begin
Input_Breakpoint (Reader, Item, Success);
Value.breakpoints.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_SetBreakpointsResponse_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
SetBreakpointsResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_SetBreakpointsResponse_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_SetBreakpointsResponse;

package InstructionBreakpoint_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["instructionReference", "offset", "condition", "hitCondition"]);

procedure Input_InstructionBreakpoint
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out InstructionBreakpoint;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
InstructionBreakpoint_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  instructionReference
if Reader.Is_String_Value then
Value.instructionReference := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  offset
Value.offset := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.offset.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  condition
if Reader.Is_String_Value then
Value.condition := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  hitCondition
if Reader.Is_String_Value then
Value.hitCondition := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_InstructionBreakpoint;

package DisconnectRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_DisconnectRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out DisconnectRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
DisconnectRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "disconnect" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Value.arguments := (Is_Set => True, Value => <>);
Input_DisconnectArguments (Reader, Value.arguments.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_DisconnectRequest;

package TerminateThreadsResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

procedure Input_TerminateThreadsResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out TerminateThreadsResponse;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
TerminateThreadsResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_Any_Value (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_TerminateThreadsResponse;

package ScopesRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_ScopesRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ScopesRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ScopesRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "scopes" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_ScopesArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ScopesRequest;

package SetExceptionBreakpointsResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

package SetExceptionBreakpointsResponse_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["breakpoints"]);

procedure Input_SetExceptionBreakpointsResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetExceptionBreakpointsResponse;
Success : in out Boolean) is
procedure Input_SetExceptionBreakpointsResponse_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out SetExceptionBreakpointsResponse_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
SetExceptionBreakpointsResponse_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  breakpoints
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : Breakpoint;
begin
Input_Breakpoint (Reader, Item, Success);
Value.breakpoints.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_SetExceptionBreakpointsResponse_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
SetExceptionBreakpointsResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Value.a_body := (Is_Set => True, Value => <>);
Input_SetExceptionBreakpointsResponse_body (Reader, Value.a_body.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_SetExceptionBreakpointsResponse;

package StepBackResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

procedure Input_StepBackResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StepBackResponse;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
StepBackResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_Any_Value (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_StepBackResponse;

package DisassembleResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

package DisassembleResponse_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["instructions"]);

procedure Input_DisassembleResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out DisassembleResponse;
Success : in out Boolean) is
procedure Input_DisassembleResponse_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out DisassembleResponse_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
DisassembleResponse_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  instructions
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : DisassembledInstruction;
begin
Input_DisassembledInstruction (Reader, Item, Success);
Value.instructions.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_DisassembleResponse_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
DisassembleResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Value.a_body := (Is_Set => True, Value => <>);
Input_DisassembleResponse_body (Reader, Value.a_body.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_DisassembleResponse;

package InvalidatedEvent_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "event", "body"]);

package InvalidatedEvent_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["areas", "threadId", "stackFrameId"]);

procedure Input_InvalidatedEvent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out InvalidatedEvent;
Success : in out Boolean) is
procedure Input_InvalidatedEvent_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out InvalidatedEvent_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
InvalidatedEvent_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  areas
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : Enum.InvalidatedAreas;
begin
Input_InvalidatedAreas (Reader, Item, Success);
Value.areas.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 2 =>  --  threadId
Value.threadId := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.threadId.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  stackFrameId
Value.stackFrameId := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.stackFrameId.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_InvalidatedEvent_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
InvalidatedEvent_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "event" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  event
if Reader.Is_String_Value and then Reader.String_Value = "invalidated" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  body
Input_InvalidatedEvent_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_InvalidatedEvent;

package GotoTargetsArguments_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["source", "line", "column"]);

procedure Input_GotoTargetsArguments
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out GotoTargetsArguments;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
GotoTargetsArguments_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  source
Input_Source (Reader, Value.source, Success);
   when 2 =>  --  line
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.line := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  column
Value.column := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.column.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_GotoTargetsArguments;

package StepInRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_StepInRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StepInRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
StepInRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "stepIn" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_StepInArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_StepInRequest;

package ContinueRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "command", "arguments"]);

procedure Input_ContinueRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out ContinueRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
ContinueRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "request" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  command
if Reader.Is_String_Value and then Reader.String_Value = "continue" then
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
Input_ContinueArguments (Reader, Value.arguments, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_ContinueRequest;

package LoadedSourcesResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

package LoadedSourcesResponse_body_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["sources"]);

procedure Input_LoadedSourcesResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out LoadedSourcesResponse;
Success : in out Boolean) is
procedure Input_LoadedSourcesResponse_body
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out LoadedSourcesResponse_body;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
LoadedSourcesResponse_body_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  sources
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : Source;
begin
Input_Source (Reader, Item, Success);
Value.sources.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_LoadedSourcesResponse_body;

begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
LoadedSourcesResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_LoadedSourcesResponse_body (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_LoadedSourcesResponse;

package StartDebuggingResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["seq", "type", "request_seq", "success", "command", "message", "body"]);

procedure Input_StartDebuggingResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out StartDebuggingResponse;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
StartDebuggingResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  type
if Reader.Is_String_Value and then Reader.String_Value = "response" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  request_seq
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.request_seq := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  success
if Reader.Is_Boolean_Value then
Value.success := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  command
if Reader.Is_String_Value then
Value.command := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_Response_message (Reader, Value.message.Value, Success);
   when 7 =>  --  body
Input_Any_Value (Reader, Value.a_body, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_StartDebuggingResponse;

end DAP.Tools.Inputs;
