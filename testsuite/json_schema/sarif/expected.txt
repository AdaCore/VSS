--
--  Copyright (C) 2024, AdaCore
--
--  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-

pragma Style_Checks ("M99");  --  suppress style warning unitl gnatpp is fixed
with Ada.Containers.Doubly_Linked_Lists;
with Ada.Finalization;
with VSS.JSON.Streams;
with VSS.Strings;
with VSS.String_Vectors;

package SARIF.Types is
package JSON_Event_Lists is new Ada.Containers.Doubly_Linked_Lists
(VSS.JSON.Streams.JSON_Stream_Element, VSS.JSON.Streams."=");

type Any_Value is new JSON_Event_Lists.List with null record;
type Any_Object is new Any_Value with null record;

type Optional_Integer (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : Integer;
when False => null;
end case; end record;

type Optional_Float (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : Float;
when False => null;
end case; end record;

type Integer_Or_String (Is_String : Boolean := False) is record
case Is_String is
when False =>
Integer : Standard.Integer;
when True =>
String : VSS.Strings.Virtual_String;
end case;
end record;

type Optional_Integer_Or_String (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : Integer_Or_String;
when False => null;
end case; end record;


type configurationOverride_Vector is tagged private
with Variable_Indexing => Get_configurationOverride_Variable_Reference,
Constant_Indexing => Get_configurationOverride_Constant_Reference;

type locationRelationship_Vector is tagged private
with Variable_Indexing => Get_locationRelationship_Variable_Reference,
Constant_Indexing => Get_locationRelationship_Constant_Reference;

type threadFlowLocation_Vector is tagged private
with Variable_Indexing => Get_threadFlowLocation_Variable_Reference,
Constant_Indexing => Get_threadFlowLocation_Constant_Reference;

type result_Vector is tagged private
with Variable_Indexing => Get_result_Variable_Reference,
Constant_Indexing => Get_result_Constant_Reference;

type runAutomationDetails_Vector is tagged private
with Variable_Indexing => Get_runAutomationDetails_Variable_Reference,
Constant_Indexing => Get_runAutomationDetails_Constant_Reference;

type replacement_Vector is tagged private
with Variable_Indexing => Get_replacement_Variable_Reference,
Constant_Indexing => Get_replacement_Constant_Reference;

type webResponse_Vector is tagged private
with Variable_Indexing => Get_webResponse_Variable_Reference,
Constant_Indexing => Get_webResponse_Constant_Reference;

type address_Vector is tagged private
with Variable_Indexing => Get_address_Variable_Reference,
Constant_Indexing => Get_address_Constant_Reference;

type physicalLocation_Vector is tagged private
with Variable_Indexing => Get_physicalLocation_Variable_Reference,
Constant_Indexing => Get_physicalLocation_Constant_Reference;

type stackFrame_Vector is tagged private
with Variable_Indexing => Get_stackFrame_Variable_Reference,
Constant_Indexing => Get_stackFrame_Constant_Reference;

type toolComponent_Vector is tagged private
with Variable_Indexing => Get_toolComponent_Variable_Reference,
Constant_Indexing => Get_toolComponent_Constant_Reference;

type externalPropertyFileReference_Vector is tagged private
with Variable_Indexing => Get_externalPropertyFileReference_Variable_Reference,
Constant_Indexing => Get_externalPropertyFileReference_Constant_Reference;

type stack_Vector is tagged private
with Variable_Indexing => Get_stack_Variable_Reference,
Constant_Indexing => Get_stack_Constant_Reference;

type Integer_Vector is tagged private
with Variable_Indexing => Get_Integer_Variable_Reference,
Constant_Indexing => Get_Integer_Constant_Reference;

type notification_Vector is tagged private
with Variable_Indexing => Get_notification_Variable_Reference,
Constant_Indexing => Get_notification_Constant_Reference;

type attachment_Vector is tagged private
with Variable_Indexing => Get_attachment_Variable_Reference,
Constant_Indexing => Get_attachment_Constant_Reference;

type suppression_Vector is tagged private
with Variable_Indexing => Get_suppression_Variable_Reference,
Constant_Indexing => Get_suppression_Constant_Reference;

type edgeTraversal_Vector is tagged private
with Variable_Indexing => Get_edgeTraversal_Variable_Reference,
Constant_Indexing => Get_edgeTraversal_Constant_Reference;

type graphTraversal_Vector is tagged private
with Variable_Indexing => Get_graphTraversal_Variable_Reference,
Constant_Indexing => Get_graphTraversal_Constant_Reference;

type location_Vector is tagged private
with Variable_Indexing => Get_location_Variable_Reference,
Constant_Indexing => Get_location_Constant_Reference;

type graph_Vector is tagged private
with Variable_Indexing => Get_graph_Variable_Reference,
Constant_Indexing => Get_graph_Constant_Reference;

type reportingDescriptorReference_Vector is tagged private
with Variable_Indexing => Get_reportingDescriptorReference_Variable_Reference,
Constant_Indexing => Get_reportingDescriptorReference_Constant_Reference;

type reportingDescriptorRelationship_Vector is tagged private
with Variable_Indexing => Get_reportingDescriptorRelationship_Variable_Reference,
Constant_Indexing => Get_reportingDescriptorRelationship_Constant_Reference;

type region_Vector is tagged private
with Variable_Indexing => Get_region_Variable_Reference,
Constant_Indexing => Get_region_Constant_Reference;

type versionControlDetails_Vector is tagged private
with Variable_Indexing => Get_versionControlDetails_Variable_Reference,
Constant_Indexing => Get_versionControlDetails_Constant_Reference;

type rectangle_Vector is tagged private
with Variable_Indexing => Get_rectangle_Variable_Reference,
Constant_Indexing => Get_rectangle_Constant_Reference;

type codeFlow_Vector is tagged private
with Variable_Indexing => Get_codeFlow_Variable_Reference,
Constant_Indexing => Get_codeFlow_Constant_Reference;

type toolComponentReference_Vector is tagged private
with Variable_Indexing => Get_toolComponentReference_Variable_Reference,
Constant_Indexing => Get_toolComponentReference_Constant_Reference;

type edge_Vector is tagged private
with Variable_Indexing => Get_edge_Variable_Reference,
Constant_Indexing => Get_edge_Constant_Reference;

type toolComponent_contents_Vector is tagged private
with Variable_Indexing => Get_toolComponent_contents_Variable_Reference,
Constant_Indexing => Get_toolComponent_contents_Constant_Reference;

type node_Vector is tagged private
with Variable_Indexing => Get_node_Variable_Reference,
Constant_Indexing => Get_node_Constant_Reference;

type threadFlow_Vector is tagged private
with Variable_Indexing => Get_threadFlow_Variable_Reference,
Constant_Indexing => Get_threadFlow_Constant_Reference;

type fix_Vector is tagged private
with Variable_Indexing => Get_fix_Variable_Reference,
Constant_Indexing => Get_fix_Constant_Reference;

type invocation_Vector is tagged private
with Variable_Indexing => Get_invocation_Variable_Reference,
Constant_Indexing => Get_invocation_Constant_Reference;

type artifactChange_Vector is tagged private
with Variable_Indexing => Get_artifactChange_Variable_Reference,
Constant_Indexing => Get_artifactChange_Constant_Reference;

type artifact_roles_Vector is tagged private
with Variable_Indexing => Get_artifact_roles_Variable_Reference,
Constant_Indexing => Get_artifact_roles_Constant_Reference;

type artifact_Vector is tagged private
with Variable_Indexing => Get_artifact_Variable_Reference,
Constant_Indexing => Get_artifact_Constant_Reference;

type logicalLocation_Vector is tagged private
with Variable_Indexing => Get_logicalLocation_Variable_Reference,
Constant_Indexing => Get_logicalLocation_Constant_Reference;

type webRequest_Vector is tagged private
with Variable_Indexing => Get_webRequest_Variable_Reference,
Constant_Indexing => Get_webRequest_Constant_Reference;

type externalProperties_Vector is tagged private
with Variable_Indexing => Get_externalProperties_Variable_Reference,
Constant_Indexing => Get_externalProperties_Constant_Reference;

type run_Vector is tagged private
with Variable_Indexing => Get_run_Variable_Reference,
Constant_Indexing => Get_run_Constant_Reference;

type a_exception_Vector is tagged private
with Variable_Indexing => Get_a_exception_Variable_Reference,
Constant_Indexing => Get_a_exception_Constant_Reference;

type reportingDescriptor_Vector is tagged private
with Variable_Indexing => Get_reportingDescriptor_Variable_Reference,
Constant_Indexing => Get_reportingDescriptor_Constant_Reference;

type artifactLocation_Vector is tagged private
with Variable_Indexing => Get_artifactLocation_Variable_Reference,
Constant_Indexing => Get_artifactLocation_Constant_Reference;


package Enum is

type notification_level is (none, note, warning, error);

type Optional_notification_level (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : notification_level;
when False => null;
end case; end record;

type suppression_kind is (inSource, external);

type suppression_status is (accepted, underReview, rejected);

type Optional_suppression_status (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : suppression_status;
when False => null;
end case; end record;

type toolComponent_contents is (localizedData, nonLocalizedData);

type artifact_roles is (analysisTarget, attachment, responseFile, resultFile, standardStream, tracedFile, unmodified, modified, added, deleted, renamed, uncontrolled, driver, extension, translation, taxonomy, policy, referencedOnCommandLine, memoryContents, directory, userSpecifiedConfiguration, toolSpecifiedConfiguration, debugOutputFile);

type reportingConfiguration_level is (none, note, warning, error);

type Optional_reportingConfiguration_level (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : reportingConfiguration_level;
when False => null;
end case; end record;

type result_kind is (notApplicable, pass, fail, review, open, informational);

type Optional_result_kind (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : result_kind;
when False => null;
end case; end record;

type result_level is (none, note, warning, error);

type Optional_result_level (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : result_level;
when False => null;
end case; end record;

type result_baselineState is (a_new, unchanged, updated, absent);

type Optional_result_baselineState (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : result_baselineState;
when False => null;
end case; end record;

type run_columnKind is (utf16CodeUnits, unicodeCodePoints);

type Optional_run_columnKind (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : run_columnKind;
when False => null;
end case; end record;

type threadFlowLocation_importance is (important, essential, unimportant);

type Optional_threadFlowLocation_importance (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : threadFlowLocation_importance;
when False => null;
end case; end record;

end Enum;

type propertyBag is record
tags : VSS.String_Vectors.Virtual_String_Vector;
      --  A set of distinct strings that provide additional information.
end record;

type Optional_propertyBag (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : propertyBag;
when False => null;
end case; end record;

type message is record
text : VSS.Strings.Virtual_String;
      --  A plain text message string.
markdown : VSS.Strings.Virtual_String;
      --  A Markdown message string.
id : VSS.Strings.Virtual_String;
      --  The identifier for this message.
arguments : VSS.String_Vectors.Virtual_String_Vector;
      --  An array of strings to substitute into the message string.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the message.
end record;

type Optional_message (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : message;
when False => null;
end case; end record;

type address is record
absoluteAddress : Optional_Integer;
      --  The address expressed as a byte offset from the start of the addressable region.
relativeAddress : Optional_Integer;
      --  The address expressed as a byte offset from the absolute address of the top-most parent object.
length : Optional_Integer;
      --  The number of bytes in this range of addresses.
kind : VSS.Strings.Virtual_String;
      --  An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.
name : VSS.Strings.Virtual_String;
      --  A name that is associated with the address, e.g., '.text'.
fullyQualifiedName : VSS.Strings.Virtual_String;
      --  A human-readable fully qualified name that is associated with the address.
offsetFromParent : Optional_Integer;
      --  The byte offset of this address from the absolute or relative address of the parent object.
index : Optional_Integer;
      --  The index within run.addresses of the cached object for this address.
parentIndex : Optional_Integer;
      --  The index within run.addresses of the parent object.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the address.
end record;

type Optional_address (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : address;
when False => null;
end case; end record;

type artifactLocation is record
uri : VSS.Strings.Virtual_String;
      --  A string containing a valid relative or absolute URI.
uriBaseId : VSS.Strings.Virtual_String;
      --  A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.
index : Optional_Integer;
      --  The index within the run artifacts array of the artifact object associated with the artifact location.
description : Optional_message;
      --  A short description of the artifact location.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the artifact location.
end record;

type Optional_artifactLocation (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : artifactLocation;
when False => null;
end case; end record;

type multiformatMessageString is record
text : VSS.Strings.Virtual_String;
      --  A plain text message string or format string.
markdown : VSS.Strings.Virtual_String;
      --  A Markdown message string or format string.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the message.
end record;

type Optional_multiformatMessageString (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : multiformatMessageString;
when False => null;
end case; end record;

type artifactContent is record
text : VSS.Strings.Virtual_String;
      --  UTF-8-encoded content from a text artifact.
binary : VSS.Strings.Virtual_String;
      --  MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.
rendered : Optional_multiformatMessageString;
      --  An alternate rendered representation of the artifact (e.g., a decompiled representation of a binary region).
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the artifact content.
end record;

type Optional_artifactContent (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : artifactContent;
when False => null;
end case; end record;

type region is record
startLine : Optional_Integer;
      --  The line number of the first character in the region.
startColumn : Optional_Integer;
      --  The column number of the first character in the region.
endLine : Optional_Integer;
      --  The line number of the last character in the region.
endColumn : Optional_Integer;
      --  The column number of the character following the end of the region.
charOffset : Optional_Integer;
      --  The zero-based offset from the beginning of the artifact of the first character in the region.
charLength : Optional_Integer;
      --  The length of the region in characters.
byteOffset : Optional_Integer;
      --  The zero-based offset from the beginning of the artifact of the first byte in the region.
byteLength : Optional_Integer;
      --  The length of the region in bytes.
snippet : Optional_artifactContent;
      --  The portion of the artifact contents within the specified region.
message : Optional_message;
      --  A message relevant to the region.
sourceLanguage : VSS.Strings.Virtual_String;
      --  Specifies the source language, if any, of the portion of the artifact specified by the region object.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the region.
end record;

type Optional_region (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : region;
when False => null;
end case; end record;

type physicalLocation is record
address : Optional_address;
      --  The address of the location.
artifactLocation : Optional_artifactLocation;
      --  The location of the artifact.
region : Optional_region;
      --  Specifies a portion of the artifact.
contextRegion : Optional_region;
      --  Specifies a portion of the artifact that encloses the region. Allows a viewer to display additional context around the region.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the physical location.
end record;

type Optional_physicalLocation (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : physicalLocation;
when False => null;
end case; end record;

type location is record
id : Optional_Integer;
      --  Value that distinguishes this location from all other locations within a single result object.
physicalLocation : Optional_physicalLocation;
      --  Identifies the artifact and region.
logicalLocations : logicalLocation_Vector;
      --  The logical locations associated with the result.
message : Optional_message;
      --  A message relevant to the location.
annotations : region_Vector;
      --  A set of regions relevant to the location.
relationships : locationRelationship_Vector;
      --  An array of objects that describe relationships between this location and others.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the location.
end record;

type Optional_location (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : location;
when False => null;
end case; end record;

type node is record
id : VSS.Strings.Virtual_String;
      --  A string that uniquely identifies the node within its graph.
label : Optional_message;
      --  A short description of the node.
location : Optional_location;
      --  A code location associated with the node.
children : node_Vector;
      --  Array of child nodes.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the node.
end record;

type edgeTraversal is record
edgeId : VSS.Strings.Virtual_String;
      --  Identifies the edge being traversed.
message : Optional_message;
      --  A message to display to the user as the edge is traversed.
finalState : Any_Object;
      --  The values of relevant expressions after the edge has been traversed.
stepOverEdgeCount : Optional_Integer;
      --  The number of edge traversals necessary to return from a nested graph.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the edge traversal.
end record;

type stackFrame is record
location : Optional_location;
      --  The location to which this stack frame refers.
module : VSS.Strings.Virtual_String;
      --  The name of the module that contains the code of this stack frame.
threadId : Optional_Integer;
      --  The thread identifier of the stack frame.
parameters : VSS.String_Vectors.Virtual_String_Vector;
      --  The parameters of the call that is executing.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the stack frame.
end record;

type toolComponentReference is record
name : VSS.Strings.Virtual_String;
      --  The 'name' property of the referenced toolComponent.
index : Optional_Integer;
      --  An index into the referenced toolComponent in tool.extensions.
guid : VSS.Strings.Virtual_String;
      --  The 'guid' property of the referenced toolComponent.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the toolComponentReference.
end record;

type Optional_toolComponentReference (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : toolComponentReference;
when False => null;
end case; end record;

type reportingDescriptorReference is record
id : VSS.Strings.Virtual_String;
      --  The id of the descriptor.
index : Optional_Integer;
      --  The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.
guid : VSS.Strings.Virtual_String;
      --  A guid that uniquely identifies the descriptor.
toolComponent : Optional_toolComponentReference;
      --  A reference used to locate the toolComponent associated with the descriptor.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the reporting descriptor reference.
end record;

type Optional_reportingDescriptorReference (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : reportingDescriptorReference;
when False => null;
end case; end record;

type reportingDescriptorRelationship is record
target : reportingDescriptorReference;
      --  A reference to the related reporting descriptor.
kinds : VSS.String_Vectors.Virtual_String_Vector;
      --  A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.
description : Optional_message;
      --  A description of the reporting descriptor relationship.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the reporting descriptor reference.
end record;

type logicalLocation is record
name : VSS.Strings.Virtual_String;
      --  Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.
index : Optional_Integer;
      --  The index within the logical locations array.
fullyQualifiedName : VSS.Strings.Virtual_String;
      --  The human-readable fully qualified name of the logical location.
decoratedName : VSS.Strings.Virtual_String;
      --  The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.
parentIndex : Optional_Integer;
      --  Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.
kind : VSS.Strings.Virtual_String;
      --  The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the logical location.
end record;

type resultProvenance is record
firstDetectionTimeUtc : VSS.Strings.Virtual_String;
      --  The Coordinated Universal Time (UTC) date and time at which the result was first detected. See "Date/time properties" in the SARIF spec for the required format.
lastDetectionTimeUtc : VSS.Strings.Virtual_String;
      --  The Coordinated Universal Time (UTC) date and time at which the result was most recently detected. See "Date/time properties" in the SARIF spec for the required format.
firstDetectionRunGuid : VSS.Strings.Virtual_String;
      --  A GUID-valued string equal to the automationDetails.guid property of the run in which the result was first detected.
lastDetectionRunGuid : VSS.Strings.Virtual_String;
      --  A GUID-valued string equal to the automationDetails.guid property of the run in which the result was most recently detected.
invocationIndex : Optional_Integer;
      --  The index within the run.invocations array of the invocation object which describes the tool invocation that detected the result.
conversionSources : physicalLocation_Vector;
      --  An array of physicalLocation objects which specify the portions of an analysis tool's output that a converter transformed into the result.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the result.
end record;

type Optional_resultProvenance (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : resultProvenance;
when False => null;
end case; end record;

type artifactChange is record
artifactLocation : SARIF.Types.artifactLocation;
      --  The location of the artifact to change.
replacements : replacement_Vector;
      --  An array of replacement objects, each of which represents the replacement of a single region in a single artifact specified by 'artifactLocation'.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the change.
end record;

type translationMetadata is record
name : VSS.Strings.Virtual_String;
      --  The name associated with the translation metadata.
fullName : VSS.Strings.Virtual_String;
      --  The full name associated with the translation metadata.
shortDescription : Optional_multiformatMessageString;
      --  A brief description of the translation metadata.
fullDescription : Optional_multiformatMessageString;
      --  A comprehensive description of the translation metadata.
downloadUri : VSS.Strings.Virtual_String;
      --  The absolute URI from which the translation metadata can be downloaded.
informationUri : VSS.Strings.Virtual_String;
      --  The absolute URI from which information related to the translation metadata can be downloaded.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the translation metadata.
end record;

type Optional_translationMetadata (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : translationMetadata;
when False => null;
end case; end record;

type stack is record
message : Optional_message;
      --  A message relevant to this call stack.
frames : stackFrame_Vector;
      --  An array of stack frames that represents a sequence of calls, rendered in reverse chronological order, that comprise the call stack.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the stack.
end record;

type Optional_stack (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : stack;
when False => null;
end case; end record;

type a_exception is record
kind : VSS.Strings.Virtual_String;
      --  A string that identifies the kind of exception, for example, the fully qualified type name of an object that was thrown, or the symbolic name of a signal.
message : VSS.Strings.Virtual_String;
      --  A message that describes the exception.
stack : Optional_stack;
      --  The sequence of function calls leading to the exception.
innerExceptions : a_exception_Vector;
      --  An array of exception objects each of which is considered a cause of this exception.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the exception.
end record;

type Optional_a_exception (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : a_exception;
when False => null;
end case; end record;

type notification is record
locations : location_Vector;
      --  The locations relevant to this notification.
message : SARIF.Types.message;
      --  A message that describes the condition that was encountered.
level : Enum.Optional_notification_level;
      --  A value specifying the severity level of the notification.
threadId : Optional_Integer;
      --  The thread identifier of the code that generated the notification.
timeUtc : VSS.Strings.Virtual_String;
      --  The Coordinated Universal Time (UTC) date and time at which the analysis tool generated the notification.
a_exception : Optional_a_exception;
      --  The runtime exception, if any, relevant to this notification.
descriptor : Optional_reportingDescriptorReference;
      --  A reference used to locate the descriptor relevant to this notification.
associatedRule : Optional_reportingDescriptorReference;
      --  A reference used to locate the rule descriptor associated with this notification.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the notification.
end record;

type versionControlDetails is record
repositoryUri : VSS.Strings.Virtual_String;
      --  The absolute URI of the repository.
revisionId : VSS.Strings.Virtual_String;
      --  A string that uniquely and permanently identifies the revision within the repository.
branch : VSS.Strings.Virtual_String;
      --  The name of a branch containing the revision.
revisionTag : VSS.Strings.Virtual_String;
      --  A tag that has been applied to the revision.
asOfTimeUtc : VSS.Strings.Virtual_String;
      --  A Coordinated Universal Time (UTC) date and time that can be used to synchronize an enlistment to the state of the repository at that time.
mappedTo : Optional_artifactLocation;
      --  The location in the local file system to which the root of the repository was mapped at the time of the analysis.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the version control details.
end record;

type suppression is record
guid : VSS.Strings.Virtual_String;
      --  A stable, unique identifer for the suprression in the form of a GUID.
kind : Enum.suppression_kind;
      --  A string that indicates where the suppression is persisted.
status : Enum.Optional_suppression_status;
      --  A string that indicates the review status of the suppression.
justification : VSS.Strings.Virtual_String;
      --  A string representing the justification for the suppression.
location : Optional_location;
      --  Identifies the location associated with the suppression.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the suppression.
end record;

type externalPropertyFileReference is record
location : Optional_artifactLocation;
      --  The location of the external property file.
guid : VSS.Strings.Virtual_String;
      --  A stable, unique identifer for the external property file in the form of a GUID.
itemCount : Optional_Integer;
      --  A non-negative integer specifying the number of items contained in the external property file.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the external property file.
end record;

type Optional_externalPropertyFileReference (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : externalPropertyFileReference;
when False => null;
end case; end record;

type locationRelationship is record
target : Integer;
      --  A reference to the related location.
kinds : VSS.String_Vectors.Virtual_String_Vector;
      --  A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.
description : Optional_message;
      --  A description of the location relationship.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the location relationship.
end record;

type edge is record
id : VSS.Strings.Virtual_String;
      --  A string that uniquely identifies the edge within its graph.
label : Optional_message;
      --  A short description of the edge.
sourceNodeId : VSS.Strings.Virtual_String;
      --  Identifies the source node (the node at which the edge starts).
targetNodeId : VSS.Strings.Virtual_String;
      --  Identifies the target node (the node at which the edge ends).
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the edge.
end record;

type Root is record
schema : VSS.Strings.Virtual_String;
      --  The URI of the JSON schema corresponding to the version.
runs : run_Vector;
      --  The set of runs contained in this log file.
inlineExternalProperties : externalProperties_Vector;
      --  References to external property files that share data between runs.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the log file.
end record;

type specialLocations is record
displayBase : Optional_artifactLocation;
      --  Provides a suggestion to SARIF consumers to display file paths relative to the specified location.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the special locations.
end record;

type Optional_specialLocations (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : specialLocations;
when False => null;
end case; end record;

type toolComponent is record
guid : VSS.Strings.Virtual_String;
      --  A unique identifer for the tool component in the form of a GUID.
name : VSS.Strings.Virtual_String;
      --  The name of the tool component.
organization : VSS.Strings.Virtual_String;
      --  The organization or company that produced the tool component.
product : VSS.Strings.Virtual_String;
      --  A product suite to which the tool component belongs.
productSuite : VSS.Strings.Virtual_String;
      --  A localizable string containing the name of the suite of products to which the tool component belongs.
shortDescription : Optional_multiformatMessageString;
      --  A brief description of the tool component.
fullDescription : Optional_multiformatMessageString;
      --  A comprehensive description of the tool component.
fullName : VSS.Strings.Virtual_String;
      --  The name of the tool component along with its version and any other useful identifying information, such as its locale.
version : VSS.Strings.Virtual_String;
      --  The tool component version, in whatever format the component natively provides.
semanticVersion : VSS.Strings.Virtual_String;
      --  The tool component version in the format specified by Semantic Versioning 2.0.
dottedQuadFileVersion : VSS.Strings.Virtual_String;
      --  The binary version of the tool component's primary executable file expressed as four non-negative integers separated by a period (for operating systems that express file versions in this way).
releaseDateUtc : VSS.Strings.Virtual_String;
      --  A string specifying the UTC date (and optionally, the time) of the component's release.
downloadUri : VSS.Strings.Virtual_String;
      --  The absolute URI from which the tool component can be downloaded.
informationUri : VSS.Strings.Virtual_String;
      --  The absolute URI at which information about this version of the tool component can be found.
globalMessageStrings : Any_Object;
      --  A dictionary, each of whose keys is a resource identifier and each of whose values is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.
notifications : reportingDescriptor_Vector;
      --  An array of reportingDescriptor objects relevant to the notifications related to the configuration and runtime execution of the tool component.
rules : reportingDescriptor_Vector;
      --  An array of reportingDescriptor objects relevant to the analysis performed by the tool component.
taxa : reportingDescriptor_Vector;
      --  An array of reportingDescriptor objects relevant to the definitions of both standalone and tool-defined taxonomies.
locations : artifactLocation_Vector;
      --  An array of the artifactLocation objects associated with the tool component.
language : VSS.Strings.Virtual_String;
      --  The language of the messages emitted into the log file during this run (expressed as an ISO 639-1 two-letter lowercase language code) and an optional region (expressed as an ISO 3166-1 two-letter uppercase subculture code associated with a country or region). The casing is recommended but not required (in order for this data to conform to RFC5646).
contents : toolComponent_contents_Vector;
      --  The kinds of data contained in this object.
isComprehensive : Boolean := Boolean'First;
      --  Specifies whether this object contains a complete definition of the localizable and/or non-localizable data for this component, as opposed to including only data that is relevant to the results persisted to this log file.
localizedDataSemanticVersion : VSS.Strings.Virtual_String;
      --  The semantic version of the localized strings defined in this component; maintained by components that provide translations.
minimumRequiredLocalizedDataSemanticVersion : VSS.Strings.Virtual_String;
      --  The minimum value of localizedDataSemanticVersion required in translations consumed by this component; used by components that consume translations.
associatedComponent : Optional_toolComponentReference;
      --  The component which is strongly associated with this component. For a translation, this refers to the component which has been translated. For an extension, this is the driver that provides the extension's plugin model.
translationMetadata : Optional_translationMetadata;
      --  Translation metadata, required for a translation, not populated by other component types.
supportedTaxonomies : toolComponentReference_Vector;
      --  An array of toolComponentReference objects to declare the taxonomies supported by the tool component.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the tool component.
end record;

type Optional_toolComponent (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : toolComponent;
when False => null;
end case; end record;

type invocation is record
commandLine : VSS.Strings.Virtual_String;
      --  The command line used to invoke the tool.
arguments : VSS.String_Vectors.Virtual_String_Vector;
      --  An array of strings, containing in order the command line arguments passed to the tool from the operating system.
responseFiles : artifactLocation_Vector;
      --  The locations of any response files specified on the tool's command line.
startTimeUtc : VSS.Strings.Virtual_String;
      --  The Coordinated Universal Time (UTC) date and time at which the invocation started. See "Date/time properties" in the SARIF spec for the required format.
endTimeUtc : VSS.Strings.Virtual_String;
      --  The Coordinated Universal Time (UTC) date and time at which the invocation ended. See "Date/time properties" in the SARIF spec for the required format.
exitCode : Optional_Integer;
      --  The process exit code.
ruleConfigurationOverrides : configurationOverride_Vector;
      --  An array of configurationOverride objects that describe rules related runtime overrides.
notificationConfigurationOverrides : configurationOverride_Vector;
      --  An array of configurationOverride objects that describe notifications related runtime overrides.
toolExecutionNotifications : notification_Vector;
      --  A list of runtime conditions detected by the tool during the analysis.
toolConfigurationNotifications : notification_Vector;
      --  A list of conditions detected by the tool that are relevant to the tool's configuration.
exitCodeDescription : VSS.Strings.Virtual_String;
      --  The reason for the process exit.
exitSignalName : VSS.Strings.Virtual_String;
      --  The name of the signal that caused the process to exit.
exitSignalNumber : Optional_Integer;
      --  The numeric value of the signal that caused the process to exit.
processStartFailureMessage : VSS.Strings.Virtual_String;
      --  The reason given by the operating system that the process failed to start.
executionSuccessful : Boolean;
      --  Specifies whether the tool's execution completed successfully.
machine : VSS.Strings.Virtual_String;
      --  The machine on which the invocation occurred.
account : VSS.Strings.Virtual_String;
      --  The account under which the invocation occurred.
processId : Optional_Integer;
      --  The id of the process in which the invocation occurred.
executableLocation : Optional_artifactLocation;
      --  An absolute URI specifying the location of the executable that was invoked.
workingDirectory : Optional_artifactLocation;
      --  The working directory for the invocation.
environmentVariables : Any_Object;
      --  The environment variables associated with the analysis tool process, expressed as key/value pairs.
stdin : Optional_artifactLocation;
      --  A file containing the standard input stream to the process that was invoked.
stdout : Optional_artifactLocation;
      --  A file containing the standard output stream from the process that was invoked.
stderr : Optional_artifactLocation;
      --  A file containing the standard error stream from the process that was invoked.
stdoutStderr : Optional_artifactLocation;
      --  A file containing the interleaved standard output and standard error stream from the process that was invoked.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the invocation.
end record;

type Optional_invocation (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : invocation;
when False => null;
end case; end record;

type tool is record
driver : toolComponent;
      --  The analysis tool that was run.
extensions : toolComponent_Vector;
      --  Tool extensions that contributed to or reconfigured the analysis tool that was run.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the tool.
end record;

type conversion is record
tool : SARIF.Types.tool;
      --  A tool object that describes the converter.
invocation : Optional_invocation;
      --  An invocation object that describes the invocation of the converter.
analysisToolLogFiles : artifactLocation_Vector;
      --  The locations of the analysis tool's per-run log files.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the conversion.
end record;

type Optional_conversion (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : conversion;
when False => null;
end case; end record;

type runAutomationDetails is record
description : Optional_message;
      --  A description of the identity and role played within the engineering system by this object's containing run object.
id : VSS.Strings.Virtual_String;
      --  A hierarchical string that uniquely identifies this object's containing run object.
guid : VSS.Strings.Virtual_String;
      --  A stable, unique identifer for this object's containing run object in the form of a GUID.
correlationGuid : VSS.Strings.Virtual_String;
      --  A stable, unique identifier for the equivalence class of runs to which this object's containing run object belongs in the form of a GUID.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the run automation details.
end record;

type Optional_runAutomationDetails (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : runAutomationDetails;
when False => null;
end case; end record;

type graph is record
description : Optional_message;
      --  A description of the graph.
nodes : node_Vector;
      --  An array of node objects representing the nodes of the graph.
edges : edge_Vector;
      --  An array of edge objects representing the edges of the graph.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the graph.
end record;

type externalProperties is record
schema : VSS.Strings.Virtual_String;
      --  The URI of the JSON schema corresponding to the version of the external property file format.
guid : VSS.Strings.Virtual_String;
      --  A stable, unique identifer for this external properties object, in the form of a GUID.
runGuid : VSS.Strings.Virtual_String;
      --  A stable, unique identifer for the run associated with this external properties object, in the form of a GUID.
conversion : Optional_conversion;
      --  A conversion object that will be merged with a separate run.
graphs : graph_Vector;
      --  An array of graph objects that will be merged with a separate run.
externalizedProperties : Optional_propertyBag;
      --  Key/value pairs that provide additional information that will be merged with a separate run.
artifacts : artifact_Vector;
      --  An array of artifact objects that will be merged with a separate run.
invocations : invocation_Vector;
      --  Describes the invocation of the analysis tool that will be merged with a separate run.
logicalLocations : logicalLocation_Vector;
      --  An array of logical locations such as namespaces, types or functions that will be merged with a separate run.
threadFlowLocations : threadFlowLocation_Vector;
      --  An array of threadFlowLocation objects that will be merged with a separate run.
results : result_Vector;
      --  An array of result objects that will be merged with a separate run.
taxonomies : toolComponent_Vector;
      --  Tool taxonomies that will be merged with a separate run.
driver : Optional_toolComponent;
      --  The analysis tool object that will be merged with a separate run.
extensions : toolComponent_Vector;
      --  Tool extensions that will be merged with a separate run.
policies : toolComponent_Vector;
      --  Tool policies that will be merged with a separate run.
translations : toolComponent_Vector;
      --  Tool translations that will be merged with a separate run.
addresses : address_Vector;
      --  Addresses that will be merged with a separate run.
webRequests : webRequest_Vector;
      --  Requests that will be merged with a separate run.
webResponses : webResponse_Vector;
      --  Responses that will be merged with a separate run.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the external properties.
end record;

type rectangle is record
top : Optional_Float;
      --  The Y coordinate of the top edge of the rectangle, measured in the image's natural units.
left : Optional_Float;
      --  The X coordinate of the left edge of the rectangle, measured in the image's natural units.
bottom : Optional_Float;
      --  The Y coordinate of the bottom edge of the rectangle, measured in the image's natural units.
right : Optional_Float;
      --  The X coordinate of the right edge of the rectangle, measured in the image's natural units.
message : Optional_message;
      --  A message relevant to the rectangle.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the rectangle.
end record;

type reportingConfiguration is record
enabled : Boolean := Boolean'First;
      --  Specifies whether the report may be produced during the scan.
level : Enum.Optional_reportingConfiguration_level;
      --  Specifies the failure level for the report.
rank : Optional_Float;
      --  Specifies the relative priority of the report. Used for analysis output only.
parameters : Optional_propertyBag;
      --  Contains configuration information specific to a report.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the reporting configuration.
end record;

type Optional_reportingConfiguration (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : reportingConfiguration;
when False => null;
end case; end record;

type reportingDescriptor is record
id : VSS.Strings.Virtual_String;
      --  A stable, opaque identifier for the report.
deprecatedIds : VSS.String_Vectors.Virtual_String_Vector;
      --  An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.
guid : VSS.Strings.Virtual_String;
      --  A unique identifer for the reporting descriptor in the form of a GUID.
deprecatedGuids : VSS.String_Vectors.Virtual_String_Vector;
      --  An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.
name : VSS.Strings.Virtual_String;
      --  A report identifier that is understandable to an end user.
deprecatedNames : VSS.String_Vectors.Virtual_String_Vector;
      --  An array of readable identifiers by which this report was known in some previous version of the analysis tool.
shortDescription : Optional_multiformatMessageString;
      --  A concise description of the report. Should be a single sentence that is understandable when visible space is limited to a single line of text.
fullDescription : Optional_multiformatMessageString;
      --  A description of the report. Should, as far as possible, provide details sufficient to enable resolution of any problem indicated by the result.
messageStrings : Any_Object;
      --  A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.
defaultConfiguration : Optional_reportingConfiguration;
      --  Default reporting configuration information.
helpUri : VSS.Strings.Virtual_String;
      --  A URI where the primary documentation for the report can be found.
help : Optional_multiformatMessageString;
      --  Provides the primary documentation for the report, useful when there is no online documentation.
relationships : reportingDescriptorRelationship_Vector;
      --  An array of objects that describe relationships between this reporting descriptor and others.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the report.
end record;

type artifact is record
description : Optional_message;
      --  A short description of the artifact.
location : Optional_artifactLocation;
      --  The location of the artifact.
parentIndex : Optional_Integer;
      --  Identifies the index of the immediate parent of the artifact, if this artifact is nested.
offset : Optional_Integer;
      --  The offset in bytes of the artifact within its containing artifact.
length : Optional_Integer;
      --  The length of the artifact in bytes.
roles : artifact_roles_Vector;
      --  The role or roles played by the artifact in the analysis.
mimeType : VSS.Strings.Virtual_String;
      --  The MIME type (RFC 2045) of the artifact.
contents : Optional_artifactContent;
      --  The contents of the artifact.
encoding : VSS.Strings.Virtual_String;
      --  Specifies the encoding for an artifact object that refers to a text file.
sourceLanguage : VSS.Strings.Virtual_String;
      --  Specifies the source language for any artifact object that refers to a text file that contains source code.
hashes : Any_Object;
      --  A dictionary, each of whose keys is the name of a hash function and each of whose values is the hashed value of the artifact produced by the specified hash function.
lastModifiedTimeUtc : VSS.Strings.Virtual_String;
      --  The Coordinated Universal Time (UTC) date and time at which the artifact was most recently modified. See "Date/time properties" in the SARIF spec for the required format.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the artifact.
end record;

type webRequest is record
index : Optional_Integer;
      --  The index within the run.webRequests array of the request object associated with this result.
protocol : VSS.Strings.Virtual_String;
      --  The request protocol. Example: 'http'.
version : VSS.Strings.Virtual_String;
      --  The request version. Example: '1.1'.
target : VSS.Strings.Virtual_String;
      --  The target of the request.
method : VSS.Strings.Virtual_String;
      --  The HTTP method. Well-known values are 'GET', 'PUT', 'POST', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS', 'TRACE', 'CONNECT'.
headers : Any_Object;
      --  The request headers.
parameters : Any_Object;
      --  The request parameters.
a_body : Optional_artifactContent;
      --  The body of the request.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the request.
end record;

type Optional_webRequest (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : webRequest;
when False => null;
end case; end record;

type fix is record
description : Optional_message;
      --  A message that describes the proposed fix, enabling viewers to present the proposed change to an end user.
artifactChanges : artifactChange_Vector;
      --  One or more artifact changes that comprise a fix for a result.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the fix.
end record;

type webResponse is record
index : Optional_Integer;
      --  The index within the run.webResponses array of the response object associated with this result.
protocol : VSS.Strings.Virtual_String;
      --  The response protocol. Example: 'http'.
version : VSS.Strings.Virtual_String;
      --  The response version. Example: '1.1'.
statusCode : Optional_Integer;
      --  The response status code. Example: 451.
reasonPhrase : VSS.Strings.Virtual_String;
      --  The response reason. Example: 'Not found'.
headers : Any_Object;
      --  The response headers.
a_body : Optional_artifactContent;
      --  The body of the response.
noResponseReceived : Boolean := Boolean'First;
      --  Specifies whether a response was received from the server.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the response.
end record;

type Optional_webResponse (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : webResponse;
when False => null;
end case; end record;

type result is record
ruleId : VSS.Strings.Virtual_String;
      --  The stable, unique identifier of the rule, if any, to which this result is relevant.
ruleIndex : Optional_Integer;
      --  The index within the tool component rules array of the rule object associated with this result.
rule : Optional_reportingDescriptorReference;
      --  A reference used to locate the rule descriptor relevant to this result.
kind : Enum.Optional_result_kind;
      --  A value that categorizes results by evaluation state.
level : Enum.Optional_result_level;
      --  A value specifying the severity level of the result.
message : SARIF.Types.message;
      --  A message that describes the result. The first sentence of the message only will be displayed when visible space is limited.
analysisTarget : Optional_artifactLocation;
      --  Identifies the artifact that the analysis tool was instructed to scan. This need not be the same as the artifact where the result actually occurred.
locations : location_Vector;
      --  The set of locations where the result was detected. Specify only one location unless the problem indicated by the result can only be corrected by making a change at every specified location.
guid : VSS.Strings.Virtual_String;
      --  A stable, unique identifer for the result in the form of a GUID.
correlationGuid : VSS.Strings.Virtual_String;
      --  A stable, unique identifier for the equivalence class of logically identical results to which this result belongs, in the form of a GUID.
occurrenceCount : Optional_Integer;
      --  A positive integer specifying the number of times this logically unique result was observed in this run.
partialFingerprints : Any_Object;
      --  A set of strings that contribute to the stable, unique identity of the result.
fingerprints : Any_Object;
      --  A set of strings each of which individually defines a stable, unique identity for the result.
stacks : stack_Vector;
      --  An array of 'stack' objects relevant to the result.
codeFlows : codeFlow_Vector;
      --  An array of 'codeFlow' objects relevant to the result.
graphs : graph_Vector;
      --  An array of zero or more unique graph objects associated with the result.
graphTraversals : graphTraversal_Vector;
      --  An array of one or more unique 'graphTraversal' objects.
relatedLocations : location_Vector;
      --  A set of locations relevant to this result.
suppressions : suppression_Vector;
      --  A set of suppressions relevant to this result.
baselineState : Enum.Optional_result_baselineState;
      --  The state of a result relative to a baseline of a previous run.
rank : Optional_Float;
      --  A number representing the priority or importance of the result.
attachments : attachment_Vector;
      --  A set of artifacts relevant to the result.
hostedViewerUri : VSS.Strings.Virtual_String;
      --  An absolute URI at which the result can be viewed.
workItemUris : VSS.String_Vectors.Virtual_String_Vector;
      --  The URIs of the work items associated with this result.
provenance : Optional_resultProvenance;
      --  Information about how and when the result was detected.
fixes : fix_Vector;
      --  An array of 'fix' objects, each of which represents a proposed fix to the problem indicated by the result.
taxa : reportingDescriptorReference_Vector;
      --  An array of references to taxonomy reporting descriptors that are applicable to the result.
webRequest : Optional_webRequest;
      --  A web request associated with this result.
webResponse : Optional_webResponse;
      --  A web response associated with this result.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the result.
end record;

type graphTraversal is record
runGraphIndex : Optional_Integer;
      --  The index within the run.graphs to be associated with the result.
resultGraphIndex : Optional_Integer;
      --  The index within the result.graphs to be associated with the result.
description : Optional_message;
      --  A description of this graph traversal.
initialState : Any_Object;
      --  Values of relevant expressions at the start of the graph traversal that may change during graph traversal.
immutableState : Any_Object;
      --  Values of relevant expressions at the start of the graph traversal that remain constant for the graph traversal.
edgeTraversals : edgeTraversal_Vector;
      --  The sequences of edges traversed by this graph traversal.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the graph traversal.
end record;

type attachment is record
description : Optional_message;
      --  A message describing the role played by the attachment.
artifactLocation : SARIF.Types.artifactLocation;
      --  The location of the attachment.
regions : region_Vector;
      --  An array of regions of interest within the attachment.
rectangles : rectangle_Vector;
      --  An array of rectangles specifying areas of interest within the image.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the attachment.
end record;

type replacement is record
deletedRegion : region;
      --  The region of the artifact to delete.
insertedContent : Optional_artifactContent;
      --  The content to insert at the location specified by the 'deletedRegion' property.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the replacement.
end record;

type externalPropertyFileReferences is record
conversion : Optional_externalPropertyFileReference;
      --  An external property file containing a run.conversion object to be merged with the root log file.
graphs : externalPropertyFileReference_Vector;
      --  An array of external property files containing a run.graphs object to be merged with the root log file.
externalizedProperties : Optional_externalPropertyFileReference;
      --  An external property file containing a run.properties object to be merged with the root log file.
artifacts : externalPropertyFileReference_Vector;
      --  An array of external property files containing run.artifacts arrays to be merged with the root log file.
invocations : externalPropertyFileReference_Vector;
      --  An array of external property files containing run.invocations arrays to be merged with the root log file.
logicalLocations : externalPropertyFileReference_Vector;
      --  An array of external property files containing run.logicalLocations arrays to be merged with the root log file.
threadFlowLocations : externalPropertyFileReference_Vector;
      --  An array of external property files containing run.threadFlowLocations arrays to be merged with the root log file.
results : externalPropertyFileReference_Vector;
      --  An array of external property files containing run.results arrays to be merged with the root log file.
taxonomies : externalPropertyFileReference_Vector;
      --  An array of external property files containing run.taxonomies arrays to be merged with the root log file.
addresses : externalPropertyFileReference_Vector;
      --  An array of external property files containing run.addresses arrays to be merged with the root log file.
driver : Optional_externalPropertyFileReference;
      --  An external property file containing a run.driver object to be merged with the root log file.
extensions : externalPropertyFileReference_Vector;
      --  An array of external property files containing run.extensions arrays to be merged with the root log file.
policies : externalPropertyFileReference_Vector;
      --  An array of external property files containing run.policies arrays to be merged with the root log file.
translations : externalPropertyFileReference_Vector;
      --  An array of external property files containing run.translations arrays to be merged with the root log file.
webRequests : externalPropertyFileReference_Vector;
      --  An array of external property files containing run.requests arrays to be merged with the root log file.
webResponses : externalPropertyFileReference_Vector;
      --  An array of external property files containing run.responses arrays to be merged with the root log file.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the external property files.
end record;

type Optional_externalPropertyFileReferences (Is_Set : Boolean := False) is record
case Is_Set is
when True => Value : externalPropertyFileReferences;
when False => null;
end case; end record;

type run is record
tool : SARIF.Types.tool;
      --  Information about the tool or tool pipeline that generated the results in this run. A run can only contain results produced by a single tool or tool pipeline. A run can aggregate results from multiple log files, as long as context around the tool run (tool command-line arguments and the like) is identical for all aggregated files.
invocations : invocation_Vector;
      --  Describes the invocation of the analysis tool.
conversion : Optional_conversion;
      --  A conversion object that describes how a converter transformed an analysis tool's native reporting format into the SARIF format.
language : VSS.Strings.Virtual_String;
      --  The language of the messages emitted into the log file during this run (expressed as an ISO 639-1 two-letter lowercase culture code) and an optional region (expressed as an ISO 3166-1 two-letter uppercase subculture code associated with a country or region). The casing is recommended but not required (in order for this data to conform to RFC5646).
versionControlProvenance : versionControlDetails_Vector;
      --  Specifies the revision in version control of the artifacts that were scanned.
originalUriBaseIds : Any_Object;
      --  The artifact location specified by each uriBaseId symbol on the machine where the tool originally ran.
artifacts : artifact_Vector;
      --  An array of artifact objects relevant to the run.
logicalLocations : logicalLocation_Vector;
      --  An array of logical locations such as namespaces, types or functions.
graphs : graph_Vector;
      --  An array of zero or more unique graph objects associated with the run.
results : result_Vector;
      --  The set of results contained in an SARIF log. The results array can be omitted when a run is solely exporting rules metadata. It must be present (but may be empty) if a log file represents an actual scan.
automationDetails : Optional_runAutomationDetails;
      --  Automation details that describe this run.
runAggregates : runAutomationDetails_Vector;
      --  Automation details that describe the aggregate of runs to which this run belongs.
baselineGuid : VSS.Strings.Virtual_String;
      --  The 'guid' property of a previous SARIF 'run' that comprises the baseline that was used to compute result 'baselineState' properties for the run.
redactionTokens : VSS.String_Vectors.Virtual_String_Vector;
      --  An array of strings used to replace sensitive information in a redaction-aware property.
defaultEncoding : VSS.Strings.Virtual_String;
      --  Specifies the default encoding for any artifact object that refers to a text file.
defaultSourceLanguage : VSS.Strings.Virtual_String;
      --  Specifies the default source language for any artifact object that refers to a text file that contains source code.
newlineSequences : VSS.String_Vectors.Virtual_String_Vector;
      --  An ordered list of character sequences that were treated as line breaks when computing region information for the run.
columnKind : Enum.Optional_run_columnKind;
      --  Specifies the unit in which the tool measures columns.
externalPropertyFileReferences : Optional_externalPropertyFileReferences;
      --  References to external property files that should be inlined with the content of a root log file.
threadFlowLocations : threadFlowLocation_Vector;
      --  An array of threadFlowLocation objects cached at run level.
taxonomies : toolComponent_Vector;
      --  An array of toolComponent objects relevant to a taxonomy in which results are categorized.
addresses : address_Vector;
      --  Addresses associated with this run instance, if any.
translations : toolComponent_Vector;
      --  The set of available translations of the localized data provided by the tool.
policies : toolComponent_Vector;
      --  Contains configurations that may potentially override both reportingDescriptor.defaultConfiguration (the tool's default severities) and invocation.configurationOverrides (severities established at run-time from the command line).
webRequests : webRequest_Vector;
      --  An array of request objects cached at run level.
webResponses : webResponse_Vector;
      --  An array of response objects cached at run level.
specialLocations : Optional_specialLocations;
      --  A specialLocations object that defines locations of special significance to SARIF consumers.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the run.
end record;

type threadFlowLocation is record
index : Optional_Integer;
      --  The index within the run threadFlowLocations array.
location : Optional_location;
      --  The code location.
stack : Optional_stack;
      --  The call stack leading to this location.
kinds : VSS.String_Vectors.Virtual_String_Vector;
      --  A set of distinct strings that categorize the thread flow location. Well-known kinds include 'acquire', 'release', 'enter', 'exit', 'call', 'return', 'branch', 'implicit', 'false', 'true', 'caution', 'danger', 'unknown', 'unreachable', 'taint', 'function', 'handler', 'lock', 'memory', 'resource', 'scope' and 'value'.
taxa : reportingDescriptorReference_Vector;
      --  An array of references to rule or taxonomy reporting descriptors that are applicable to the thread flow location.
module : VSS.Strings.Virtual_String;
      --  The name of the module that contains the code that is executing.
state : Any_Object;
      --  A dictionary, each of whose keys specifies a variable or expression, the associated value of which represents the variable or expression value. For an annotation of kind 'continuation', for example, this dictionary might hold the current assumed values of a set of global variables.
nestingLevel : Optional_Integer;
      --  An integer representing a containment hierarchy within the thread flow.
executionOrder : Optional_Integer;
      --  An integer representing the temporal order in which execution reached this location.
executionTimeUtc : VSS.Strings.Virtual_String;
      --  The Coordinated Universal Time (UTC) date and time at which this location was executed.
importance : Enum.Optional_threadFlowLocation_importance;
      --  Specifies the importance of this location in understanding the code flow in which it occurs. The order from most to least important is "essential", "important", "unimportant". Default: "important".
webRequest : Optional_webRequest;
      --  A web request associated with this thread flow location.
webResponse : Optional_webResponse;
      --  A web response associated with this thread flow location.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the threadflow location.
end record;

type codeFlow is record
message : Optional_message;
      --  A message relevant to the code flow.
threadFlows : threadFlow_Vector;
      --  An array of one or more unique threadFlow objects, each of which describes the progress of a program through a thread of execution.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the code flow.
end record;

type threadFlow is record
id : VSS.Strings.Virtual_String;
      --  An string that uniquely identifies the threadFlow within the codeFlow in which it occurs.
message : Optional_message;
      --  A message relevant to the thread flow.
initialState : Any_Object;
      --  Values of relevant expressions at the start of the thread flow that may change during thread flow execution.
immutableState : Any_Object;
      --  Values of relevant expressions at the start of the thread flow that remain constant.
locations : threadFlowLocation_Vector;
      --  A temporally ordered array of 'threadFlowLocation' objects, each of which describes a location visited by the tool while producing the result.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the thread flow.
end record;

type configurationOverride is record
configuration : reportingConfiguration;
      --  Specifies how the rule or notification was configured during the scan.
descriptor : reportingDescriptorReference;
      --  A reference used to locate the descriptor whose configuration was overridden.
properties : Optional_propertyBag;
      --  Key/value pairs that provide additional information about the configuration override.
end record;

function Length (Self : configurationOverride_Vector) return Natural;

procedure Clear (Self : in out configurationOverride_Vector);

procedure Append
(Self : in out configurationOverride_Vector;
Value : configurationOverride);

type configurationOverride_Variable_Reference
(Element : not null access configurationOverride) is null record
with Implicit_Dereference => Element;

not overriding function Get_configurationOverride_Variable_Reference
(Self : aliased in out configurationOverride_Vector;
Index : Positive)
return configurationOverride_Variable_Reference
with Inline;

type configurationOverride_Constant_Reference
(Element : not null access constant configurationOverride) is null record
with Implicit_Dereference => Element;

not overriding function Get_configurationOverride_Constant_Reference
(Self : aliased configurationOverride_Vector;
Index : Positive)
return configurationOverride_Constant_Reference
with Inline;

function Length (Self : locationRelationship_Vector) return Natural;

procedure Clear (Self : in out locationRelationship_Vector);

procedure Append
(Self : in out locationRelationship_Vector;
Value : locationRelationship);

type locationRelationship_Variable_Reference
(Element : not null access locationRelationship) is null record
with Implicit_Dereference => Element;

not overriding function Get_locationRelationship_Variable_Reference
(Self : aliased in out locationRelationship_Vector;
Index : Positive)
return locationRelationship_Variable_Reference
with Inline;

type locationRelationship_Constant_Reference
(Element : not null access constant locationRelationship) is null record
with Implicit_Dereference => Element;

not overriding function Get_locationRelationship_Constant_Reference
(Self : aliased locationRelationship_Vector;
Index : Positive)
return locationRelationship_Constant_Reference
with Inline;

function Length (Self : threadFlowLocation_Vector) return Natural;

procedure Clear (Self : in out threadFlowLocation_Vector);

procedure Append
(Self : in out threadFlowLocation_Vector;
Value : threadFlowLocation);

type threadFlowLocation_Variable_Reference
(Element : not null access threadFlowLocation) is null record
with Implicit_Dereference => Element;

not overriding function Get_threadFlowLocation_Variable_Reference
(Self : aliased in out threadFlowLocation_Vector;
Index : Positive)
return threadFlowLocation_Variable_Reference
with Inline;

type threadFlowLocation_Constant_Reference
(Element : not null access constant threadFlowLocation) is null record
with Implicit_Dereference => Element;

not overriding function Get_threadFlowLocation_Constant_Reference
(Self : aliased threadFlowLocation_Vector;
Index : Positive)
return threadFlowLocation_Constant_Reference
with Inline;

function Length (Self : result_Vector) return Natural;

procedure Clear (Self : in out result_Vector);

procedure Append
(Self : in out result_Vector;
Value : result);

type result_Variable_Reference
(Element : not null access result) is null record
with Implicit_Dereference => Element;

not overriding function Get_result_Variable_Reference
(Self : aliased in out result_Vector;
Index : Positive)
return result_Variable_Reference
with Inline;

type result_Constant_Reference
(Element : not null access constant result) is null record
with Implicit_Dereference => Element;

not overriding function Get_result_Constant_Reference
(Self : aliased result_Vector;
Index : Positive)
return result_Constant_Reference
with Inline;

function Length (Self : runAutomationDetails_Vector) return Natural;

procedure Clear (Self : in out runAutomationDetails_Vector);

procedure Append
(Self : in out runAutomationDetails_Vector;
Value : runAutomationDetails);

type runAutomationDetails_Variable_Reference
(Element : not null access runAutomationDetails) is null record
with Implicit_Dereference => Element;

not overriding function Get_runAutomationDetails_Variable_Reference
(Self : aliased in out runAutomationDetails_Vector;
Index : Positive)
return runAutomationDetails_Variable_Reference
with Inline;

type runAutomationDetails_Constant_Reference
(Element : not null access constant runAutomationDetails) is null record
with Implicit_Dereference => Element;

not overriding function Get_runAutomationDetails_Constant_Reference
(Self : aliased runAutomationDetails_Vector;
Index : Positive)
return runAutomationDetails_Constant_Reference
with Inline;

function Length (Self : replacement_Vector) return Natural;

procedure Clear (Self : in out replacement_Vector);

procedure Append
(Self : in out replacement_Vector;
Value : replacement);

type replacement_Variable_Reference
(Element : not null access replacement) is null record
with Implicit_Dereference => Element;

not overriding function Get_replacement_Variable_Reference
(Self : aliased in out replacement_Vector;
Index : Positive)
return replacement_Variable_Reference
with Inline;

type replacement_Constant_Reference
(Element : not null access constant replacement) is null record
with Implicit_Dereference => Element;

not overriding function Get_replacement_Constant_Reference
(Self : aliased replacement_Vector;
Index : Positive)
return replacement_Constant_Reference
with Inline;

function Length (Self : webResponse_Vector) return Natural;

procedure Clear (Self : in out webResponse_Vector);

procedure Append
(Self : in out webResponse_Vector;
Value : webResponse);

type webResponse_Variable_Reference
(Element : not null access webResponse) is null record
with Implicit_Dereference => Element;

not overriding function Get_webResponse_Variable_Reference
(Self : aliased in out webResponse_Vector;
Index : Positive)
return webResponse_Variable_Reference
with Inline;

type webResponse_Constant_Reference
(Element : not null access constant webResponse) is null record
with Implicit_Dereference => Element;

not overriding function Get_webResponse_Constant_Reference
(Self : aliased webResponse_Vector;
Index : Positive)
return webResponse_Constant_Reference
with Inline;

function Length (Self : address_Vector) return Natural;

procedure Clear (Self : in out address_Vector);

procedure Append
(Self : in out address_Vector;
Value : address);

type address_Variable_Reference
(Element : not null access address) is null record
with Implicit_Dereference => Element;

not overriding function Get_address_Variable_Reference
(Self : aliased in out address_Vector;
Index : Positive)
return address_Variable_Reference
with Inline;

type address_Constant_Reference
(Element : not null access constant address) is null record
with Implicit_Dereference => Element;

not overriding function Get_address_Constant_Reference
(Self : aliased address_Vector;
Index : Positive)
return address_Constant_Reference
with Inline;

function Length (Self : physicalLocation_Vector) return Natural;

procedure Clear (Self : in out physicalLocation_Vector);

procedure Append
(Self : in out physicalLocation_Vector;
Value : physicalLocation);

type physicalLocation_Variable_Reference
(Element : not null access physicalLocation) is null record
with Implicit_Dereference => Element;

not overriding function Get_physicalLocation_Variable_Reference
(Self : aliased in out physicalLocation_Vector;
Index : Positive)
return physicalLocation_Variable_Reference
with Inline;

type physicalLocation_Constant_Reference
(Element : not null access constant physicalLocation) is null record
with Implicit_Dereference => Element;

not overriding function Get_physicalLocation_Constant_Reference
(Self : aliased physicalLocation_Vector;
Index : Positive)
return physicalLocation_Constant_Reference
with Inline;

function Length (Self : stackFrame_Vector) return Natural;

procedure Clear (Self : in out stackFrame_Vector);

procedure Append
(Self : in out stackFrame_Vector;
Value : stackFrame);

type stackFrame_Variable_Reference
(Element : not null access stackFrame) is null record
with Implicit_Dereference => Element;

not overriding function Get_stackFrame_Variable_Reference
(Self : aliased in out stackFrame_Vector;
Index : Positive)
return stackFrame_Variable_Reference
with Inline;

type stackFrame_Constant_Reference
(Element : not null access constant stackFrame) is null record
with Implicit_Dereference => Element;

not overriding function Get_stackFrame_Constant_Reference
(Self : aliased stackFrame_Vector;
Index : Positive)
return stackFrame_Constant_Reference
with Inline;

function Length (Self : toolComponent_Vector) return Natural;

procedure Clear (Self : in out toolComponent_Vector);

procedure Append
(Self : in out toolComponent_Vector;
Value : toolComponent);

type toolComponent_Variable_Reference
(Element : not null access toolComponent) is null record
with Implicit_Dereference => Element;

not overriding function Get_toolComponent_Variable_Reference
(Self : aliased in out toolComponent_Vector;
Index : Positive)
return toolComponent_Variable_Reference
with Inline;

type toolComponent_Constant_Reference
(Element : not null access constant toolComponent) is null record
with Implicit_Dereference => Element;

not overriding function Get_toolComponent_Constant_Reference
(Self : aliased toolComponent_Vector;
Index : Positive)
return toolComponent_Constant_Reference
with Inline;

function Length (Self : externalPropertyFileReference_Vector) return Natural;

procedure Clear (Self : in out externalPropertyFileReference_Vector);

procedure Append
(Self : in out externalPropertyFileReference_Vector;
Value : externalPropertyFileReference);

type externalPropertyFileReference_Variable_Reference
(Element : not null access externalPropertyFileReference) is null record
with Implicit_Dereference => Element;

not overriding function Get_externalPropertyFileReference_Variable_Reference
(Self : aliased in out externalPropertyFileReference_Vector;
Index : Positive)
return externalPropertyFileReference_Variable_Reference
with Inline;

type externalPropertyFileReference_Constant_Reference
(Element : not null access constant externalPropertyFileReference) is null record
with Implicit_Dereference => Element;

not overriding function Get_externalPropertyFileReference_Constant_Reference
(Self : aliased externalPropertyFileReference_Vector;
Index : Positive)
return externalPropertyFileReference_Constant_Reference
with Inline;

function Length (Self : stack_Vector) return Natural;

procedure Clear (Self : in out stack_Vector);

procedure Append
(Self : in out stack_Vector;
Value : stack);

type stack_Variable_Reference
(Element : not null access stack) is null record
with Implicit_Dereference => Element;

not overriding function Get_stack_Variable_Reference
(Self : aliased in out stack_Vector;
Index : Positive)
return stack_Variable_Reference
with Inline;

type stack_Constant_Reference
(Element : not null access constant stack) is null record
with Implicit_Dereference => Element;

not overriding function Get_stack_Constant_Reference
(Self : aliased stack_Vector;
Index : Positive)
return stack_Constant_Reference
with Inline;

function Length (Self : Integer_Vector) return Natural;

procedure Clear (Self : in out Integer_Vector);

procedure Append
(Self : in out Integer_Vector;
Value : Integer);

type Integer_Variable_Reference
(Element : not null access Integer) is null record
with Implicit_Dereference => Element;

not overriding function Get_Integer_Variable_Reference
(Self : aliased in out Integer_Vector;
Index : Positive)
return Integer_Variable_Reference
with Inline;

type Integer_Constant_Reference
(Element : not null access constant Integer) is null record
with Implicit_Dereference => Element;

not overriding function Get_Integer_Constant_Reference
(Self : aliased Integer_Vector;
Index : Positive)
return Integer_Constant_Reference
with Inline;

function Length (Self : notification_Vector) return Natural;

procedure Clear (Self : in out notification_Vector);

procedure Append
(Self : in out notification_Vector;
Value : notification);

type notification_Variable_Reference
(Element : not null access notification) is null record
with Implicit_Dereference => Element;

not overriding function Get_notification_Variable_Reference
(Self : aliased in out notification_Vector;
Index : Positive)
return notification_Variable_Reference
with Inline;

type notification_Constant_Reference
(Element : not null access constant notification) is null record
with Implicit_Dereference => Element;

not overriding function Get_notification_Constant_Reference
(Self : aliased notification_Vector;
Index : Positive)
return notification_Constant_Reference
with Inline;

function Length (Self : attachment_Vector) return Natural;

procedure Clear (Self : in out attachment_Vector);

procedure Append
(Self : in out attachment_Vector;
Value : attachment);

type attachment_Variable_Reference
(Element : not null access attachment) is null record
with Implicit_Dereference => Element;

not overriding function Get_attachment_Variable_Reference
(Self : aliased in out attachment_Vector;
Index : Positive)
return attachment_Variable_Reference
with Inline;

type attachment_Constant_Reference
(Element : not null access constant attachment) is null record
with Implicit_Dereference => Element;

not overriding function Get_attachment_Constant_Reference
(Self : aliased attachment_Vector;
Index : Positive)
return attachment_Constant_Reference
with Inline;

function Length (Self : suppression_Vector) return Natural;

procedure Clear (Self : in out suppression_Vector);

procedure Append
(Self : in out suppression_Vector;
Value : suppression);

type suppression_Variable_Reference
(Element : not null access suppression) is null record
with Implicit_Dereference => Element;

not overriding function Get_suppression_Variable_Reference
(Self : aliased in out suppression_Vector;
Index : Positive)
return suppression_Variable_Reference
with Inline;

type suppression_Constant_Reference
(Element : not null access constant suppression) is null record
with Implicit_Dereference => Element;

not overriding function Get_suppression_Constant_Reference
(Self : aliased suppression_Vector;
Index : Positive)
return suppression_Constant_Reference
with Inline;

function Length (Self : edgeTraversal_Vector) return Natural;

procedure Clear (Self : in out edgeTraversal_Vector);

procedure Append
(Self : in out edgeTraversal_Vector;
Value : edgeTraversal);

type edgeTraversal_Variable_Reference
(Element : not null access edgeTraversal) is null record
with Implicit_Dereference => Element;

not overriding function Get_edgeTraversal_Variable_Reference
(Self : aliased in out edgeTraversal_Vector;
Index : Positive)
return edgeTraversal_Variable_Reference
with Inline;

type edgeTraversal_Constant_Reference
(Element : not null access constant edgeTraversal) is null record
with Implicit_Dereference => Element;

not overriding function Get_edgeTraversal_Constant_Reference
(Self : aliased edgeTraversal_Vector;
Index : Positive)
return edgeTraversal_Constant_Reference
with Inline;

function Length (Self : graphTraversal_Vector) return Natural;

procedure Clear (Self : in out graphTraversal_Vector);

procedure Append
(Self : in out graphTraversal_Vector;
Value : graphTraversal);

type graphTraversal_Variable_Reference
(Element : not null access graphTraversal) is null record
with Implicit_Dereference => Element;

not overriding function Get_graphTraversal_Variable_Reference
(Self : aliased in out graphTraversal_Vector;
Index : Positive)
return graphTraversal_Variable_Reference
with Inline;

type graphTraversal_Constant_Reference
(Element : not null access constant graphTraversal) is null record
with Implicit_Dereference => Element;

not overriding function Get_graphTraversal_Constant_Reference
(Self : aliased graphTraversal_Vector;
Index : Positive)
return graphTraversal_Constant_Reference
with Inline;

function Length (Self : location_Vector) return Natural;

procedure Clear (Self : in out location_Vector);

procedure Append
(Self : in out location_Vector;
Value : location);

type location_Variable_Reference
(Element : not null access location) is null record
with Implicit_Dereference => Element;

not overriding function Get_location_Variable_Reference
(Self : aliased in out location_Vector;
Index : Positive)
return location_Variable_Reference
with Inline;

type location_Constant_Reference
(Element : not null access constant location) is null record
with Implicit_Dereference => Element;

not overriding function Get_location_Constant_Reference
(Self : aliased location_Vector;
Index : Positive)
return location_Constant_Reference
with Inline;

function Length (Self : graph_Vector) return Natural;

procedure Clear (Self : in out graph_Vector);

procedure Append
(Self : in out graph_Vector;
Value : graph);

type graph_Variable_Reference
(Element : not null access graph) is null record
with Implicit_Dereference => Element;

not overriding function Get_graph_Variable_Reference
(Self : aliased in out graph_Vector;
Index : Positive)
return graph_Variable_Reference
with Inline;

type graph_Constant_Reference
(Element : not null access constant graph) is null record
with Implicit_Dereference => Element;

not overriding function Get_graph_Constant_Reference
(Self : aliased graph_Vector;
Index : Positive)
return graph_Constant_Reference
with Inline;

function Length (Self : reportingDescriptorReference_Vector) return Natural;

procedure Clear (Self : in out reportingDescriptorReference_Vector);

procedure Append
(Self : in out reportingDescriptorReference_Vector;
Value : reportingDescriptorReference);

type reportingDescriptorReference_Variable_Reference
(Element : not null access reportingDescriptorReference) is null record
with Implicit_Dereference => Element;

not overriding function Get_reportingDescriptorReference_Variable_Reference
(Self : aliased in out reportingDescriptorReference_Vector;
Index : Positive)
return reportingDescriptorReference_Variable_Reference
with Inline;

type reportingDescriptorReference_Constant_Reference
(Element : not null access constant reportingDescriptorReference) is null record
with Implicit_Dereference => Element;

not overriding function Get_reportingDescriptorReference_Constant_Reference
(Self : aliased reportingDescriptorReference_Vector;
Index : Positive)
return reportingDescriptorReference_Constant_Reference
with Inline;

function Length (Self : reportingDescriptorRelationship_Vector) return Natural;

procedure Clear (Self : in out reportingDescriptorRelationship_Vector);

procedure Append
(Self : in out reportingDescriptorRelationship_Vector;
Value : reportingDescriptorRelationship);

type reportingDescriptorRelationship_Variable_Reference
(Element : not null access reportingDescriptorRelationship) is null record
with Implicit_Dereference => Element;

not overriding function Get_reportingDescriptorRelationship_Variable_Reference
(Self : aliased in out reportingDescriptorRelationship_Vector;
Index : Positive)
return reportingDescriptorRelationship_Variable_Reference
with Inline;

type reportingDescriptorRelationship_Constant_Reference
(Element : not null access constant reportingDescriptorRelationship) is null record
with Implicit_Dereference => Element;

not overriding function Get_reportingDescriptorRelationship_Constant_Reference
(Self : aliased reportingDescriptorRelationship_Vector;
Index : Positive)
return reportingDescriptorRelationship_Constant_Reference
with Inline;

function Length (Self : region_Vector) return Natural;

procedure Clear (Self : in out region_Vector);

procedure Append
(Self : in out region_Vector;
Value : region);

type region_Variable_Reference
(Element : not null access region) is null record
with Implicit_Dereference => Element;

not overriding function Get_region_Variable_Reference
(Self : aliased in out region_Vector;
Index : Positive)
return region_Variable_Reference
with Inline;

type region_Constant_Reference
(Element : not null access constant region) is null record
with Implicit_Dereference => Element;

not overriding function Get_region_Constant_Reference
(Self : aliased region_Vector;
Index : Positive)
return region_Constant_Reference
with Inline;

function Length (Self : versionControlDetails_Vector) return Natural;

procedure Clear (Self : in out versionControlDetails_Vector);

procedure Append
(Self : in out versionControlDetails_Vector;
Value : versionControlDetails);

type versionControlDetails_Variable_Reference
(Element : not null access versionControlDetails) is null record
with Implicit_Dereference => Element;

not overriding function Get_versionControlDetails_Variable_Reference
(Self : aliased in out versionControlDetails_Vector;
Index : Positive)
return versionControlDetails_Variable_Reference
with Inline;

type versionControlDetails_Constant_Reference
(Element : not null access constant versionControlDetails) is null record
with Implicit_Dereference => Element;

not overriding function Get_versionControlDetails_Constant_Reference
(Self : aliased versionControlDetails_Vector;
Index : Positive)
return versionControlDetails_Constant_Reference
with Inline;

function Length (Self : rectangle_Vector) return Natural;

procedure Clear (Self : in out rectangle_Vector);

procedure Append
(Self : in out rectangle_Vector;
Value : rectangle);

type rectangle_Variable_Reference
(Element : not null access rectangle) is null record
with Implicit_Dereference => Element;

not overriding function Get_rectangle_Variable_Reference
(Self : aliased in out rectangle_Vector;
Index : Positive)
return rectangle_Variable_Reference
with Inline;

type rectangle_Constant_Reference
(Element : not null access constant rectangle) is null record
with Implicit_Dereference => Element;

not overriding function Get_rectangle_Constant_Reference
(Self : aliased rectangle_Vector;
Index : Positive)
return rectangle_Constant_Reference
with Inline;

function Length (Self : codeFlow_Vector) return Natural;

procedure Clear (Self : in out codeFlow_Vector);

procedure Append
(Self : in out codeFlow_Vector;
Value : codeFlow);

type codeFlow_Variable_Reference
(Element : not null access codeFlow) is null record
with Implicit_Dereference => Element;

not overriding function Get_codeFlow_Variable_Reference
(Self : aliased in out codeFlow_Vector;
Index : Positive)
return codeFlow_Variable_Reference
with Inline;

type codeFlow_Constant_Reference
(Element : not null access constant codeFlow) is null record
with Implicit_Dereference => Element;

not overriding function Get_codeFlow_Constant_Reference
(Self : aliased codeFlow_Vector;
Index : Positive)
return codeFlow_Constant_Reference
with Inline;

function Length (Self : toolComponentReference_Vector) return Natural;

procedure Clear (Self : in out toolComponentReference_Vector);

procedure Append
(Self : in out toolComponentReference_Vector;
Value : toolComponentReference);

type toolComponentReference_Variable_Reference
(Element : not null access toolComponentReference) is null record
with Implicit_Dereference => Element;

not overriding function Get_toolComponentReference_Variable_Reference
(Self : aliased in out toolComponentReference_Vector;
Index : Positive)
return toolComponentReference_Variable_Reference
with Inline;

type toolComponentReference_Constant_Reference
(Element : not null access constant toolComponentReference) is null record
with Implicit_Dereference => Element;

not overriding function Get_toolComponentReference_Constant_Reference
(Self : aliased toolComponentReference_Vector;
Index : Positive)
return toolComponentReference_Constant_Reference
with Inline;

function Length (Self : edge_Vector) return Natural;

procedure Clear (Self : in out edge_Vector);

procedure Append
(Self : in out edge_Vector;
Value : edge);

type edge_Variable_Reference
(Element : not null access edge) is null record
with Implicit_Dereference => Element;

not overriding function Get_edge_Variable_Reference
(Self : aliased in out edge_Vector;
Index : Positive)
return edge_Variable_Reference
with Inline;

type edge_Constant_Reference
(Element : not null access constant edge) is null record
with Implicit_Dereference => Element;

not overriding function Get_edge_Constant_Reference
(Self : aliased edge_Vector;
Index : Positive)
return edge_Constant_Reference
with Inline;

function Length (Self : toolComponent_contents_Vector) return Natural;

procedure Clear (Self : in out toolComponent_contents_Vector);

procedure Append
(Self : in out toolComponent_contents_Vector;
Value : Enum.toolComponent_contents);

type toolComponent_contents_Variable_Reference
(Element : not null access Enum.toolComponent_contents) is null record
with Implicit_Dereference => Element;

not overriding function Get_toolComponent_contents_Variable_Reference
(Self : aliased in out toolComponent_contents_Vector;
Index : Positive)
return toolComponent_contents_Variable_Reference
with Inline;

type toolComponent_contents_Constant_Reference
(Element : not null access constant Enum.toolComponent_contents) is null record
with Implicit_Dereference => Element;

not overriding function Get_toolComponent_contents_Constant_Reference
(Self : aliased toolComponent_contents_Vector;
Index : Positive)
return toolComponent_contents_Constant_Reference
with Inline;

function Length (Self : node_Vector) return Natural;

procedure Clear (Self : in out node_Vector);

procedure Append
(Self : in out node_Vector;
Value : node);

type node_Variable_Reference
(Element : not null access node) is null record
with Implicit_Dereference => Element;

not overriding function Get_node_Variable_Reference
(Self : aliased in out node_Vector;
Index : Positive)
return node_Variable_Reference
with Inline;

type node_Constant_Reference
(Element : not null access constant node) is null record
with Implicit_Dereference => Element;

not overriding function Get_node_Constant_Reference
(Self : aliased node_Vector;
Index : Positive)
return node_Constant_Reference
with Inline;

function Length (Self : threadFlow_Vector) return Natural;

procedure Clear (Self : in out threadFlow_Vector);

procedure Append
(Self : in out threadFlow_Vector;
Value : threadFlow);

type threadFlow_Variable_Reference
(Element : not null access threadFlow) is null record
with Implicit_Dereference => Element;

not overriding function Get_threadFlow_Variable_Reference
(Self : aliased in out threadFlow_Vector;
Index : Positive)
return threadFlow_Variable_Reference
with Inline;

type threadFlow_Constant_Reference
(Element : not null access constant threadFlow) is null record
with Implicit_Dereference => Element;

not overriding function Get_threadFlow_Constant_Reference
(Self : aliased threadFlow_Vector;
Index : Positive)
return threadFlow_Constant_Reference
with Inline;

function Length (Self : fix_Vector) return Natural;

procedure Clear (Self : in out fix_Vector);

procedure Append
(Self : in out fix_Vector;
Value : fix);

type fix_Variable_Reference
(Element : not null access fix) is null record
with Implicit_Dereference => Element;

not overriding function Get_fix_Variable_Reference
(Self : aliased in out fix_Vector;
Index : Positive)
return fix_Variable_Reference
with Inline;

type fix_Constant_Reference
(Element : not null access constant fix) is null record
with Implicit_Dereference => Element;

not overriding function Get_fix_Constant_Reference
(Self : aliased fix_Vector;
Index : Positive)
return fix_Constant_Reference
with Inline;

function Length (Self : invocation_Vector) return Natural;

procedure Clear (Self : in out invocation_Vector);

procedure Append
(Self : in out invocation_Vector;
Value : invocation);

type invocation_Variable_Reference
(Element : not null access invocation) is null record
with Implicit_Dereference => Element;

not overriding function Get_invocation_Variable_Reference
(Self : aliased in out invocation_Vector;
Index : Positive)
return invocation_Variable_Reference
with Inline;

type invocation_Constant_Reference
(Element : not null access constant invocation) is null record
with Implicit_Dereference => Element;

not overriding function Get_invocation_Constant_Reference
(Self : aliased invocation_Vector;
Index : Positive)
return invocation_Constant_Reference
with Inline;

function Length (Self : artifactChange_Vector) return Natural;

procedure Clear (Self : in out artifactChange_Vector);

procedure Append
(Self : in out artifactChange_Vector;
Value : artifactChange);

type artifactChange_Variable_Reference
(Element : not null access artifactChange) is null record
with Implicit_Dereference => Element;

not overriding function Get_artifactChange_Variable_Reference
(Self : aliased in out artifactChange_Vector;
Index : Positive)
return artifactChange_Variable_Reference
with Inline;

type artifactChange_Constant_Reference
(Element : not null access constant artifactChange) is null record
with Implicit_Dereference => Element;

not overriding function Get_artifactChange_Constant_Reference
(Self : aliased artifactChange_Vector;
Index : Positive)
return artifactChange_Constant_Reference
with Inline;

function Length (Self : artifact_roles_Vector) return Natural;

procedure Clear (Self : in out artifact_roles_Vector);

procedure Append
(Self : in out artifact_roles_Vector;
Value : Enum.artifact_roles);

type artifact_roles_Variable_Reference
(Element : not null access Enum.artifact_roles) is null record
with Implicit_Dereference => Element;

not overriding function Get_artifact_roles_Variable_Reference
(Self : aliased in out artifact_roles_Vector;
Index : Positive)
return artifact_roles_Variable_Reference
with Inline;

type artifact_roles_Constant_Reference
(Element : not null access constant Enum.artifact_roles) is null record
with Implicit_Dereference => Element;

not overriding function Get_artifact_roles_Constant_Reference
(Self : aliased artifact_roles_Vector;
Index : Positive)
return artifact_roles_Constant_Reference
with Inline;

function Length (Self : artifact_Vector) return Natural;

procedure Clear (Self : in out artifact_Vector);

procedure Append
(Self : in out artifact_Vector;
Value : artifact);

type artifact_Variable_Reference
(Element : not null access artifact) is null record
with Implicit_Dereference => Element;

not overriding function Get_artifact_Variable_Reference
(Self : aliased in out artifact_Vector;
Index : Positive)
return artifact_Variable_Reference
with Inline;

type artifact_Constant_Reference
(Element : not null access constant artifact) is null record
with Implicit_Dereference => Element;

not overriding function Get_artifact_Constant_Reference
(Self : aliased artifact_Vector;
Index : Positive)
return artifact_Constant_Reference
with Inline;

function Length (Self : logicalLocation_Vector) return Natural;

procedure Clear (Self : in out logicalLocation_Vector);

procedure Append
(Self : in out logicalLocation_Vector;
Value : logicalLocation);

type logicalLocation_Variable_Reference
(Element : not null access logicalLocation) is null record
with Implicit_Dereference => Element;

not overriding function Get_logicalLocation_Variable_Reference
(Self : aliased in out logicalLocation_Vector;
Index : Positive)
return logicalLocation_Variable_Reference
with Inline;

type logicalLocation_Constant_Reference
(Element : not null access constant logicalLocation) is null record
with Implicit_Dereference => Element;

not overriding function Get_logicalLocation_Constant_Reference
(Self : aliased logicalLocation_Vector;
Index : Positive)
return logicalLocation_Constant_Reference
with Inline;

function Length (Self : webRequest_Vector) return Natural;

procedure Clear (Self : in out webRequest_Vector);

procedure Append
(Self : in out webRequest_Vector;
Value : webRequest);

type webRequest_Variable_Reference
(Element : not null access webRequest) is null record
with Implicit_Dereference => Element;

not overriding function Get_webRequest_Variable_Reference
(Self : aliased in out webRequest_Vector;
Index : Positive)
return webRequest_Variable_Reference
with Inline;

type webRequest_Constant_Reference
(Element : not null access constant webRequest) is null record
with Implicit_Dereference => Element;

not overriding function Get_webRequest_Constant_Reference
(Self : aliased webRequest_Vector;
Index : Positive)
return webRequest_Constant_Reference
with Inline;

function Length (Self : externalProperties_Vector) return Natural;

procedure Clear (Self : in out externalProperties_Vector);

procedure Append
(Self : in out externalProperties_Vector;
Value : externalProperties);

type externalProperties_Variable_Reference
(Element : not null access externalProperties) is null record
with Implicit_Dereference => Element;

not overriding function Get_externalProperties_Variable_Reference
(Self : aliased in out externalProperties_Vector;
Index : Positive)
return externalProperties_Variable_Reference
with Inline;

type externalProperties_Constant_Reference
(Element : not null access constant externalProperties) is null record
with Implicit_Dereference => Element;

not overriding function Get_externalProperties_Constant_Reference
(Self : aliased externalProperties_Vector;
Index : Positive)
return externalProperties_Constant_Reference
with Inline;

function Length (Self : run_Vector) return Natural;

procedure Clear (Self : in out run_Vector);

procedure Append
(Self : in out run_Vector;
Value : run);

type run_Variable_Reference
(Element : not null access run) is null record
with Implicit_Dereference => Element;

not overriding function Get_run_Variable_Reference
(Self : aliased in out run_Vector;
Index : Positive)
return run_Variable_Reference
with Inline;

type run_Constant_Reference
(Element : not null access constant run) is null record
with Implicit_Dereference => Element;

not overriding function Get_run_Constant_Reference
(Self : aliased run_Vector;
Index : Positive)
return run_Constant_Reference
with Inline;

function Length (Self : a_exception_Vector) return Natural;

procedure Clear (Self : in out a_exception_Vector);

procedure Append
(Self : in out a_exception_Vector;
Value : a_exception);

type a_exception_Variable_Reference
(Element : not null access a_exception) is null record
with Implicit_Dereference => Element;

not overriding function Get_a_exception_Variable_Reference
(Self : aliased in out a_exception_Vector;
Index : Positive)
return a_exception_Variable_Reference
with Inline;

type a_exception_Constant_Reference
(Element : not null access constant a_exception) is null record
with Implicit_Dereference => Element;

not overriding function Get_a_exception_Constant_Reference
(Self : aliased a_exception_Vector;
Index : Positive)
return a_exception_Constant_Reference
with Inline;

function Length (Self : reportingDescriptor_Vector) return Natural;

procedure Clear (Self : in out reportingDescriptor_Vector);

procedure Append
(Self : in out reportingDescriptor_Vector;
Value : reportingDescriptor);

type reportingDescriptor_Variable_Reference
(Element : not null access reportingDescriptor) is null record
with Implicit_Dereference => Element;

not overriding function Get_reportingDescriptor_Variable_Reference
(Self : aliased in out reportingDescriptor_Vector;
Index : Positive)
return reportingDescriptor_Variable_Reference
with Inline;

type reportingDescriptor_Constant_Reference
(Element : not null access constant reportingDescriptor) is null record
with Implicit_Dereference => Element;

not overriding function Get_reportingDescriptor_Constant_Reference
(Self : aliased reportingDescriptor_Vector;
Index : Positive)
return reportingDescriptor_Constant_Reference
with Inline;

function Length (Self : artifactLocation_Vector) return Natural;

procedure Clear (Self : in out artifactLocation_Vector);

procedure Append
(Self : in out artifactLocation_Vector;
Value : artifactLocation);

type artifactLocation_Variable_Reference
(Element : not null access artifactLocation) is null record
with Implicit_Dereference => Element;

not overriding function Get_artifactLocation_Variable_Reference
(Self : aliased in out artifactLocation_Vector;
Index : Positive)
return artifactLocation_Variable_Reference
with Inline;

type artifactLocation_Constant_Reference
(Element : not null access constant artifactLocation) is null record
with Implicit_Dereference => Element;

not overriding function Get_artifactLocation_Constant_Reference
(Self : aliased artifactLocation_Vector;
Index : Positive)
return artifactLocation_Constant_Reference
with Inline;

private
type configurationOverride_Array is array (Positive range <>) of aliased configurationOverride;
type configurationOverride_Array_Access is access configurationOverride_Array;
type configurationOverride_Vector is new Ada.Finalization.Controlled with record
Data   : configurationOverride_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out configurationOverride_Vector);

overriding procedure Finalize (Self : in out configurationOverride_Vector);

type locationRelationship_Array is array (Positive range <>) of aliased locationRelationship;
type locationRelationship_Array_Access is access locationRelationship_Array;
type locationRelationship_Vector is new Ada.Finalization.Controlled with record
Data   : locationRelationship_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out locationRelationship_Vector);

overriding procedure Finalize (Self : in out locationRelationship_Vector);

type threadFlowLocation_Array is array (Positive range <>) of aliased threadFlowLocation;
type threadFlowLocation_Array_Access is access threadFlowLocation_Array;
type threadFlowLocation_Vector is new Ada.Finalization.Controlled with record
Data   : threadFlowLocation_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out threadFlowLocation_Vector);

overriding procedure Finalize (Self : in out threadFlowLocation_Vector);

type result_Array is array (Positive range <>) of aliased result;
type result_Array_Access is access result_Array;
type result_Vector is new Ada.Finalization.Controlled with record
Data   : result_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out result_Vector);

overriding procedure Finalize (Self : in out result_Vector);

type runAutomationDetails_Array is array (Positive range <>) of aliased runAutomationDetails;
type runAutomationDetails_Array_Access is access runAutomationDetails_Array;
type runAutomationDetails_Vector is new Ada.Finalization.Controlled with record
Data   : runAutomationDetails_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out runAutomationDetails_Vector);

overriding procedure Finalize (Self : in out runAutomationDetails_Vector);

type replacement_Array is array (Positive range <>) of aliased replacement;
type replacement_Array_Access is access replacement_Array;
type replacement_Vector is new Ada.Finalization.Controlled with record
Data   : replacement_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out replacement_Vector);

overriding procedure Finalize (Self : in out replacement_Vector);

type webResponse_Array is array (Positive range <>) of aliased webResponse;
type webResponse_Array_Access is access webResponse_Array;
type webResponse_Vector is new Ada.Finalization.Controlled with record
Data   : webResponse_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out webResponse_Vector);

overriding procedure Finalize (Self : in out webResponse_Vector);

type address_Array is array (Positive range <>) of aliased address;
type address_Array_Access is access address_Array;
type address_Vector is new Ada.Finalization.Controlled with record
Data   : address_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out address_Vector);

overriding procedure Finalize (Self : in out address_Vector);

type physicalLocation_Array is array (Positive range <>) of aliased physicalLocation;
type physicalLocation_Array_Access is access physicalLocation_Array;
type physicalLocation_Vector is new Ada.Finalization.Controlled with record
Data   : physicalLocation_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out physicalLocation_Vector);

overriding procedure Finalize (Self : in out physicalLocation_Vector);

type stackFrame_Array is array (Positive range <>) of aliased stackFrame;
type stackFrame_Array_Access is access stackFrame_Array;
type stackFrame_Vector is new Ada.Finalization.Controlled with record
Data   : stackFrame_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out stackFrame_Vector);

overriding procedure Finalize (Self : in out stackFrame_Vector);

type toolComponent_Array is array (Positive range <>) of aliased toolComponent;
type toolComponent_Array_Access is access toolComponent_Array;
type toolComponent_Vector is new Ada.Finalization.Controlled with record
Data   : toolComponent_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out toolComponent_Vector);

overriding procedure Finalize (Self : in out toolComponent_Vector);

type externalPropertyFileReference_Array is array (Positive range <>) of aliased externalPropertyFileReference;
type externalPropertyFileReference_Array_Access is access externalPropertyFileReference_Array;
type externalPropertyFileReference_Vector is new Ada.Finalization.Controlled with record
Data   : externalPropertyFileReference_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out externalPropertyFileReference_Vector);

overriding procedure Finalize (Self : in out externalPropertyFileReference_Vector);

type stack_Array is array (Positive range <>) of aliased stack;
type stack_Array_Access is access stack_Array;
type stack_Vector is new Ada.Finalization.Controlled with record
Data   : stack_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out stack_Vector);

overriding procedure Finalize (Self : in out stack_Vector);

type Integer_Array is array (Positive range <>) of aliased Integer;
type Integer_Array_Access is access Integer_Array;
type Integer_Vector is new Ada.Finalization.Controlled with record
Data   : Integer_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out Integer_Vector);

overriding procedure Finalize (Self : in out Integer_Vector);

type notification_Array is array (Positive range <>) of aliased notification;
type notification_Array_Access is access notification_Array;
type notification_Vector is new Ada.Finalization.Controlled with record
Data   : notification_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out notification_Vector);

overriding procedure Finalize (Self : in out notification_Vector);

type attachment_Array is array (Positive range <>) of aliased attachment;
type attachment_Array_Access is access attachment_Array;
type attachment_Vector is new Ada.Finalization.Controlled with record
Data   : attachment_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out attachment_Vector);

overriding procedure Finalize (Self : in out attachment_Vector);

type suppression_Array is array (Positive range <>) of aliased suppression;
type suppression_Array_Access is access suppression_Array;
type suppression_Vector is new Ada.Finalization.Controlled with record
Data   : suppression_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out suppression_Vector);

overriding procedure Finalize (Self : in out suppression_Vector);

type edgeTraversal_Array is array (Positive range <>) of aliased edgeTraversal;
type edgeTraversal_Array_Access is access edgeTraversal_Array;
type edgeTraversal_Vector is new Ada.Finalization.Controlled with record
Data   : edgeTraversal_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out edgeTraversal_Vector);

overriding procedure Finalize (Self : in out edgeTraversal_Vector);

type graphTraversal_Array is array (Positive range <>) of aliased graphTraversal;
type graphTraversal_Array_Access is access graphTraversal_Array;
type graphTraversal_Vector is new Ada.Finalization.Controlled with record
Data   : graphTraversal_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out graphTraversal_Vector);

overriding procedure Finalize (Self : in out graphTraversal_Vector);

type location_Array is array (Positive range <>) of aliased location;
type location_Array_Access is access location_Array;
type location_Vector is new Ada.Finalization.Controlled with record
Data   : location_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out location_Vector);

overriding procedure Finalize (Self : in out location_Vector);

type graph_Array is array (Positive range <>) of aliased graph;
type graph_Array_Access is access graph_Array;
type graph_Vector is new Ada.Finalization.Controlled with record
Data   : graph_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out graph_Vector);

overriding procedure Finalize (Self : in out graph_Vector);

type reportingDescriptorReference_Array is array (Positive range <>) of aliased reportingDescriptorReference;
type reportingDescriptorReference_Array_Access is access reportingDescriptorReference_Array;
type reportingDescriptorReference_Vector is new Ada.Finalization.Controlled with record
Data   : reportingDescriptorReference_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out reportingDescriptorReference_Vector);

overriding procedure Finalize (Self : in out reportingDescriptorReference_Vector);

type reportingDescriptorRelationship_Array is array (Positive range <>) of aliased reportingDescriptorRelationship;
type reportingDescriptorRelationship_Array_Access is access reportingDescriptorRelationship_Array;
type reportingDescriptorRelationship_Vector is new Ada.Finalization.Controlled with record
Data   : reportingDescriptorRelationship_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out reportingDescriptorRelationship_Vector);

overriding procedure Finalize (Self : in out reportingDescriptorRelationship_Vector);

type region_Array is array (Positive range <>) of aliased region;
type region_Array_Access is access region_Array;
type region_Vector is new Ada.Finalization.Controlled with record
Data   : region_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out region_Vector);

overriding procedure Finalize (Self : in out region_Vector);

type versionControlDetails_Array is array (Positive range <>) of aliased versionControlDetails;
type versionControlDetails_Array_Access is access versionControlDetails_Array;
type versionControlDetails_Vector is new Ada.Finalization.Controlled with record
Data   : versionControlDetails_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out versionControlDetails_Vector);

overriding procedure Finalize (Self : in out versionControlDetails_Vector);

type rectangle_Array is array (Positive range <>) of aliased rectangle;
type rectangle_Array_Access is access rectangle_Array;
type rectangle_Vector is new Ada.Finalization.Controlled with record
Data   : rectangle_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out rectangle_Vector);

overriding procedure Finalize (Self : in out rectangle_Vector);

type codeFlow_Array is array (Positive range <>) of aliased codeFlow;
type codeFlow_Array_Access is access codeFlow_Array;
type codeFlow_Vector is new Ada.Finalization.Controlled with record
Data   : codeFlow_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out codeFlow_Vector);

overriding procedure Finalize (Self : in out codeFlow_Vector);

type toolComponentReference_Array is array (Positive range <>) of aliased toolComponentReference;
type toolComponentReference_Array_Access is access toolComponentReference_Array;
type toolComponentReference_Vector is new Ada.Finalization.Controlled with record
Data   : toolComponentReference_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out toolComponentReference_Vector);

overriding procedure Finalize (Self : in out toolComponentReference_Vector);

type edge_Array is array (Positive range <>) of aliased edge;
type edge_Array_Access is access edge_Array;
type edge_Vector is new Ada.Finalization.Controlled with record
Data   : edge_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out edge_Vector);

overriding procedure Finalize (Self : in out edge_Vector);

type toolComponent_contents_Array is array (Positive range <>) of aliased Enum.toolComponent_contents;
type toolComponent_contents_Array_Access is access toolComponent_contents_Array;
type toolComponent_contents_Vector is new Ada.Finalization.Controlled with record
Data   : toolComponent_contents_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out toolComponent_contents_Vector);

overriding procedure Finalize (Self : in out toolComponent_contents_Vector);

type node_Array is array (Positive range <>) of aliased node;
type node_Array_Access is access node_Array;
type node_Vector is new Ada.Finalization.Controlled with record
Data   : node_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out node_Vector);

overriding procedure Finalize (Self : in out node_Vector);

type threadFlow_Array is array (Positive range <>) of aliased threadFlow;
type threadFlow_Array_Access is access threadFlow_Array;
type threadFlow_Vector is new Ada.Finalization.Controlled with record
Data   : threadFlow_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out threadFlow_Vector);

overriding procedure Finalize (Self : in out threadFlow_Vector);

type fix_Array is array (Positive range <>) of aliased fix;
type fix_Array_Access is access fix_Array;
type fix_Vector is new Ada.Finalization.Controlled with record
Data   : fix_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out fix_Vector);

overriding procedure Finalize (Self : in out fix_Vector);

type invocation_Array is array (Positive range <>) of aliased invocation;
type invocation_Array_Access is access invocation_Array;
type invocation_Vector is new Ada.Finalization.Controlled with record
Data   : invocation_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out invocation_Vector);

overriding procedure Finalize (Self : in out invocation_Vector);

type artifactChange_Array is array (Positive range <>) of aliased artifactChange;
type artifactChange_Array_Access is access artifactChange_Array;
type artifactChange_Vector is new Ada.Finalization.Controlled with record
Data   : artifactChange_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out artifactChange_Vector);

overriding procedure Finalize (Self : in out artifactChange_Vector);

type artifact_roles_Array is array (Positive range <>) of aliased Enum.artifact_roles;
type artifact_roles_Array_Access is access artifact_roles_Array;
type artifact_roles_Vector is new Ada.Finalization.Controlled with record
Data   : artifact_roles_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out artifact_roles_Vector);

overriding procedure Finalize (Self : in out artifact_roles_Vector);

type artifact_Array is array (Positive range <>) of aliased artifact;
type artifact_Array_Access is access artifact_Array;
type artifact_Vector is new Ada.Finalization.Controlled with record
Data   : artifact_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out artifact_Vector);

overriding procedure Finalize (Self : in out artifact_Vector);

type logicalLocation_Array is array (Positive range <>) of aliased logicalLocation;
type logicalLocation_Array_Access is access logicalLocation_Array;
type logicalLocation_Vector is new Ada.Finalization.Controlled with record
Data   : logicalLocation_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out logicalLocation_Vector);

overriding procedure Finalize (Self : in out logicalLocation_Vector);

type webRequest_Array is array (Positive range <>) of aliased webRequest;
type webRequest_Array_Access is access webRequest_Array;
type webRequest_Vector is new Ada.Finalization.Controlled with record
Data   : webRequest_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out webRequest_Vector);

overriding procedure Finalize (Self : in out webRequest_Vector);

type externalProperties_Array is array (Positive range <>) of aliased externalProperties;
type externalProperties_Array_Access is access externalProperties_Array;
type externalProperties_Vector is new Ada.Finalization.Controlled with record
Data   : externalProperties_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out externalProperties_Vector);

overriding procedure Finalize (Self : in out externalProperties_Vector);

type run_Array is array (Positive range <>) of aliased run;
type run_Array_Access is access run_Array;
type run_Vector is new Ada.Finalization.Controlled with record
Data   : run_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out run_Vector);

overriding procedure Finalize (Self : in out run_Vector);

type a_exception_Array is array (Positive range <>) of aliased a_exception;
type a_exception_Array_Access is access a_exception_Array;
type a_exception_Vector is new Ada.Finalization.Controlled with record
Data   : a_exception_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out a_exception_Vector);

overriding procedure Finalize (Self : in out a_exception_Vector);

type reportingDescriptor_Array is array (Positive range <>) of aliased reportingDescriptor;
type reportingDescriptor_Array_Access is access reportingDescriptor_Array;
type reportingDescriptor_Vector is new Ada.Finalization.Controlled with record
Data   : reportingDescriptor_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out reportingDescriptor_Vector);

overriding procedure Finalize (Self : in out reportingDescriptor_Vector);

type artifactLocation_Array is array (Positive range <>) of aliased artifactLocation;
type artifactLocation_Array_Access is access artifactLocation_Array;
type artifactLocation_Vector is new Ada.Finalization.Controlled with record
Data   : artifactLocation_Array_Access;
Length : Natural := 0;
end record;

overriding procedure Adjust (Self : in out artifactLocation_Vector);

overriding procedure Finalize (Self : in out artifactLocation_Vector);

end SARIF.Types;
--
--  Copyright (C) 2024, AdaCore
--
--  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-

pragma Style_Checks ("M99");  --  suppress style warning unitl gnatpp is fixed
with Ada.Unchecked_Deallocation;

package body SARIF.Types is
procedure Free is new Ada.Unchecked_Deallocation
(configurationOverride_Array, configurationOverride_Array_Access);

overriding procedure Adjust (Self : in out configurationOverride_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new configurationOverride_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out configurationOverride_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : configurationOverride_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out configurationOverride_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out configurationOverride_Vector;
Value : configurationOverride) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / configurationOverride'Size);
Self_Data_Saved : configurationOverride_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new configurationOverride_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new configurationOverride_Array'(Self.Data.all
 & configurationOverride_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_configurationOverride_Variable_Reference
(Self : aliased in out configurationOverride_Vector;
Index : Positive)
return configurationOverride_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_configurationOverride_Constant_Reference
(Self : aliased configurationOverride_Vector;
Index : Positive)
return configurationOverride_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(locationRelationship_Array, locationRelationship_Array_Access);

overriding procedure Adjust (Self : in out locationRelationship_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new locationRelationship_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out locationRelationship_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : locationRelationship_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out locationRelationship_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out locationRelationship_Vector;
Value : locationRelationship) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / locationRelationship'Size);
Self_Data_Saved : locationRelationship_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new locationRelationship_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new locationRelationship_Array'(Self.Data.all
 & locationRelationship_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_locationRelationship_Variable_Reference
(Self : aliased in out locationRelationship_Vector;
Index : Positive)
return locationRelationship_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_locationRelationship_Constant_Reference
(Self : aliased locationRelationship_Vector;
Index : Positive)
return locationRelationship_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(threadFlowLocation_Array, threadFlowLocation_Array_Access);

overriding procedure Adjust (Self : in out threadFlowLocation_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new threadFlowLocation_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out threadFlowLocation_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : threadFlowLocation_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out threadFlowLocation_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out threadFlowLocation_Vector;
Value : threadFlowLocation) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / threadFlowLocation'Size);
Self_Data_Saved : threadFlowLocation_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new threadFlowLocation_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new threadFlowLocation_Array'(Self.Data.all
 & threadFlowLocation_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_threadFlowLocation_Variable_Reference
(Self : aliased in out threadFlowLocation_Vector;
Index : Positive)
return threadFlowLocation_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_threadFlowLocation_Constant_Reference
(Self : aliased threadFlowLocation_Vector;
Index : Positive)
return threadFlowLocation_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(result_Array, result_Array_Access);

overriding procedure Adjust (Self : in out result_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new result_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out result_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : result_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out result_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out result_Vector;
Value : result) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / result'Size);
Self_Data_Saved : result_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new result_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new result_Array'(Self.Data.all
 & result_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_result_Variable_Reference
(Self : aliased in out result_Vector;
Index : Positive)
return result_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_result_Constant_Reference
(Self : aliased result_Vector;
Index : Positive)
return result_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(runAutomationDetails_Array, runAutomationDetails_Array_Access);

overriding procedure Adjust (Self : in out runAutomationDetails_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new runAutomationDetails_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out runAutomationDetails_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : runAutomationDetails_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out runAutomationDetails_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out runAutomationDetails_Vector;
Value : runAutomationDetails) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / runAutomationDetails'Size);
Self_Data_Saved : runAutomationDetails_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new runAutomationDetails_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new runAutomationDetails_Array'(Self.Data.all
 & runAutomationDetails_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_runAutomationDetails_Variable_Reference
(Self : aliased in out runAutomationDetails_Vector;
Index : Positive)
return runAutomationDetails_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_runAutomationDetails_Constant_Reference
(Self : aliased runAutomationDetails_Vector;
Index : Positive)
return runAutomationDetails_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(replacement_Array, replacement_Array_Access);

overriding procedure Adjust (Self : in out replacement_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new replacement_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out replacement_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : replacement_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out replacement_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out replacement_Vector;
Value : replacement) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / replacement'Size);
Self_Data_Saved : replacement_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new replacement_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new replacement_Array'(Self.Data.all
 & replacement_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_replacement_Variable_Reference
(Self : aliased in out replacement_Vector;
Index : Positive)
return replacement_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_replacement_Constant_Reference
(Self : aliased replacement_Vector;
Index : Positive)
return replacement_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(webResponse_Array, webResponse_Array_Access);

overriding procedure Adjust (Self : in out webResponse_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new webResponse_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out webResponse_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : webResponse_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out webResponse_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out webResponse_Vector;
Value : webResponse) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / webResponse'Size);
Self_Data_Saved : webResponse_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new webResponse_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new webResponse_Array'(Self.Data.all
 & webResponse_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_webResponse_Variable_Reference
(Self : aliased in out webResponse_Vector;
Index : Positive)
return webResponse_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_webResponse_Constant_Reference
(Self : aliased webResponse_Vector;
Index : Positive)
return webResponse_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(address_Array, address_Array_Access);

overriding procedure Adjust (Self : in out address_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new address_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out address_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : address_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out address_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out address_Vector;
Value : address) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / address'Size);
Self_Data_Saved : address_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new address_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new address_Array'(Self.Data.all
 & address_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_address_Variable_Reference
(Self : aliased in out address_Vector;
Index : Positive)
return address_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_address_Constant_Reference
(Self : aliased address_Vector;
Index : Positive)
return address_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(physicalLocation_Array, physicalLocation_Array_Access);

overriding procedure Adjust (Self : in out physicalLocation_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new physicalLocation_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out physicalLocation_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : physicalLocation_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out physicalLocation_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out physicalLocation_Vector;
Value : physicalLocation) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / physicalLocation'Size);
Self_Data_Saved : physicalLocation_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new physicalLocation_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new physicalLocation_Array'(Self.Data.all
 & physicalLocation_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_physicalLocation_Variable_Reference
(Self : aliased in out physicalLocation_Vector;
Index : Positive)
return physicalLocation_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_physicalLocation_Constant_Reference
(Self : aliased physicalLocation_Vector;
Index : Positive)
return physicalLocation_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(stackFrame_Array, stackFrame_Array_Access);

overriding procedure Adjust (Self : in out stackFrame_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new stackFrame_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out stackFrame_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : stackFrame_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out stackFrame_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out stackFrame_Vector;
Value : stackFrame) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / stackFrame'Size);
Self_Data_Saved : stackFrame_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new stackFrame_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new stackFrame_Array'(Self.Data.all
 & stackFrame_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_stackFrame_Variable_Reference
(Self : aliased in out stackFrame_Vector;
Index : Positive)
return stackFrame_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_stackFrame_Constant_Reference
(Self : aliased stackFrame_Vector;
Index : Positive)
return stackFrame_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(toolComponent_Array, toolComponent_Array_Access);

overriding procedure Adjust (Self : in out toolComponent_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new toolComponent_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out toolComponent_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : toolComponent_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out toolComponent_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out toolComponent_Vector;
Value : toolComponent) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / toolComponent'Size);
Self_Data_Saved : toolComponent_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new toolComponent_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new toolComponent_Array'(Self.Data.all
 & toolComponent_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_toolComponent_Variable_Reference
(Self : aliased in out toolComponent_Vector;
Index : Positive)
return toolComponent_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_toolComponent_Constant_Reference
(Self : aliased toolComponent_Vector;
Index : Positive)
return toolComponent_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(externalPropertyFileReference_Array, externalPropertyFileReference_Array_Access);

overriding procedure Adjust (Self : in out externalPropertyFileReference_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new externalPropertyFileReference_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out externalPropertyFileReference_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : externalPropertyFileReference_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out externalPropertyFileReference_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out externalPropertyFileReference_Vector;
Value : externalPropertyFileReference) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / externalPropertyFileReference'Size);
Self_Data_Saved : externalPropertyFileReference_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new externalPropertyFileReference_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new externalPropertyFileReference_Array'(Self.Data.all
 & externalPropertyFileReference_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_externalPropertyFileReference_Variable_Reference
(Self : aliased in out externalPropertyFileReference_Vector;
Index : Positive)
return externalPropertyFileReference_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_externalPropertyFileReference_Constant_Reference
(Self : aliased externalPropertyFileReference_Vector;
Index : Positive)
return externalPropertyFileReference_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(stack_Array, stack_Array_Access);

overriding procedure Adjust (Self : in out stack_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new stack_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out stack_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : stack_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out stack_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out stack_Vector;
Value : stack) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / stack'Size);
Self_Data_Saved : stack_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new stack_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new stack_Array'(Self.Data.all
 & stack_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_stack_Variable_Reference
(Self : aliased in out stack_Vector;
Index : Positive)
return stack_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_stack_Constant_Reference
(Self : aliased stack_Vector;
Index : Positive)
return stack_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(Integer_Array, Integer_Array_Access);

overriding procedure Adjust (Self : in out Integer_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new Integer_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out Integer_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : Integer_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out Integer_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out Integer_Vector;
Value : Integer) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / Integer'Size);
Self_Data_Saved : Integer_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new Integer_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new Integer_Array'(Self.Data.all
 & Integer_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_Integer_Variable_Reference
(Self : aliased in out Integer_Vector;
Index : Positive)
return Integer_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_Integer_Constant_Reference
(Self : aliased Integer_Vector;
Index : Positive)
return Integer_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(notification_Array, notification_Array_Access);

overriding procedure Adjust (Self : in out notification_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new notification_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out notification_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : notification_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out notification_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out notification_Vector;
Value : notification) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / notification'Size);
Self_Data_Saved : notification_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new notification_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new notification_Array'(Self.Data.all
 & notification_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_notification_Variable_Reference
(Self : aliased in out notification_Vector;
Index : Positive)
return notification_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_notification_Constant_Reference
(Self : aliased notification_Vector;
Index : Positive)
return notification_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(attachment_Array, attachment_Array_Access);

overriding procedure Adjust (Self : in out attachment_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new attachment_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out attachment_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : attachment_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out attachment_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out attachment_Vector;
Value : attachment) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / attachment'Size);
Self_Data_Saved : attachment_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new attachment_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new attachment_Array'(Self.Data.all
 & attachment_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_attachment_Variable_Reference
(Self : aliased in out attachment_Vector;
Index : Positive)
return attachment_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_attachment_Constant_Reference
(Self : aliased attachment_Vector;
Index : Positive)
return attachment_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(suppression_Array, suppression_Array_Access);

overriding procedure Adjust (Self : in out suppression_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new suppression_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out suppression_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : suppression_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out suppression_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out suppression_Vector;
Value : suppression) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / suppression'Size);
Self_Data_Saved : suppression_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new suppression_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new suppression_Array'(Self.Data.all
 & suppression_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_suppression_Variable_Reference
(Self : aliased in out suppression_Vector;
Index : Positive)
return suppression_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_suppression_Constant_Reference
(Self : aliased suppression_Vector;
Index : Positive)
return suppression_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(edgeTraversal_Array, edgeTraversal_Array_Access);

overriding procedure Adjust (Self : in out edgeTraversal_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new edgeTraversal_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out edgeTraversal_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : edgeTraversal_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out edgeTraversal_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out edgeTraversal_Vector;
Value : edgeTraversal) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / edgeTraversal'Size);
Self_Data_Saved : edgeTraversal_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new edgeTraversal_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new edgeTraversal_Array'(Self.Data.all
 & edgeTraversal_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_edgeTraversal_Variable_Reference
(Self : aliased in out edgeTraversal_Vector;
Index : Positive)
return edgeTraversal_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_edgeTraversal_Constant_Reference
(Self : aliased edgeTraversal_Vector;
Index : Positive)
return edgeTraversal_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(graphTraversal_Array, graphTraversal_Array_Access);

overriding procedure Adjust (Self : in out graphTraversal_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new graphTraversal_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out graphTraversal_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : graphTraversal_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out graphTraversal_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out graphTraversal_Vector;
Value : graphTraversal) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / graphTraversal'Size);
Self_Data_Saved : graphTraversal_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new graphTraversal_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new graphTraversal_Array'(Self.Data.all
 & graphTraversal_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_graphTraversal_Variable_Reference
(Self : aliased in out graphTraversal_Vector;
Index : Positive)
return graphTraversal_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_graphTraversal_Constant_Reference
(Self : aliased graphTraversal_Vector;
Index : Positive)
return graphTraversal_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(location_Array, location_Array_Access);

overriding procedure Adjust (Self : in out location_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new location_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out location_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : location_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out location_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out location_Vector;
Value : location) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / location'Size);
Self_Data_Saved : location_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new location_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new location_Array'(Self.Data.all
 & location_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_location_Variable_Reference
(Self : aliased in out location_Vector;
Index : Positive)
return location_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_location_Constant_Reference
(Self : aliased location_Vector;
Index : Positive)
return location_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(graph_Array, graph_Array_Access);

overriding procedure Adjust (Self : in out graph_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new graph_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out graph_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : graph_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out graph_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out graph_Vector;
Value : graph) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / graph'Size);
Self_Data_Saved : graph_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new graph_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new graph_Array'(Self.Data.all
 & graph_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_graph_Variable_Reference
(Self : aliased in out graph_Vector;
Index : Positive)
return graph_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_graph_Constant_Reference
(Self : aliased graph_Vector;
Index : Positive)
return graph_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(reportingDescriptorReference_Array, reportingDescriptorReference_Array_Access);

overriding procedure Adjust (Self : in out reportingDescriptorReference_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new reportingDescriptorReference_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out reportingDescriptorReference_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : reportingDescriptorReference_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out reportingDescriptorReference_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out reportingDescriptorReference_Vector;
Value : reportingDescriptorReference) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / reportingDescriptorReference'Size);
Self_Data_Saved : reportingDescriptorReference_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new reportingDescriptorReference_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new reportingDescriptorReference_Array'(Self.Data.all
 & reportingDescriptorReference_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_reportingDescriptorReference_Variable_Reference
(Self : aliased in out reportingDescriptorReference_Vector;
Index : Positive)
return reportingDescriptorReference_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_reportingDescriptorReference_Constant_Reference
(Self : aliased reportingDescriptorReference_Vector;
Index : Positive)
return reportingDescriptorReference_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(reportingDescriptorRelationship_Array, reportingDescriptorRelationship_Array_Access);

overriding procedure Adjust (Self : in out reportingDescriptorRelationship_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new reportingDescriptorRelationship_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out reportingDescriptorRelationship_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : reportingDescriptorRelationship_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out reportingDescriptorRelationship_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out reportingDescriptorRelationship_Vector;
Value : reportingDescriptorRelationship) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / reportingDescriptorRelationship'Size);
Self_Data_Saved : reportingDescriptorRelationship_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new reportingDescriptorRelationship_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new reportingDescriptorRelationship_Array'(Self.Data.all
 & reportingDescriptorRelationship_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_reportingDescriptorRelationship_Variable_Reference
(Self : aliased in out reportingDescriptorRelationship_Vector;
Index : Positive)
return reportingDescriptorRelationship_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_reportingDescriptorRelationship_Constant_Reference
(Self : aliased reportingDescriptorRelationship_Vector;
Index : Positive)
return reportingDescriptorRelationship_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(region_Array, region_Array_Access);

overriding procedure Adjust (Self : in out region_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new region_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out region_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : region_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out region_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out region_Vector;
Value : region) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / region'Size);
Self_Data_Saved : region_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new region_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new region_Array'(Self.Data.all
 & region_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_region_Variable_Reference
(Self : aliased in out region_Vector;
Index : Positive)
return region_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_region_Constant_Reference
(Self : aliased region_Vector;
Index : Positive)
return region_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(versionControlDetails_Array, versionControlDetails_Array_Access);

overriding procedure Adjust (Self : in out versionControlDetails_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new versionControlDetails_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out versionControlDetails_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : versionControlDetails_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out versionControlDetails_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out versionControlDetails_Vector;
Value : versionControlDetails) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / versionControlDetails'Size);
Self_Data_Saved : versionControlDetails_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new versionControlDetails_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new versionControlDetails_Array'(Self.Data.all
 & versionControlDetails_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_versionControlDetails_Variable_Reference
(Self : aliased in out versionControlDetails_Vector;
Index : Positive)
return versionControlDetails_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_versionControlDetails_Constant_Reference
(Self : aliased versionControlDetails_Vector;
Index : Positive)
return versionControlDetails_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(rectangle_Array, rectangle_Array_Access);

overriding procedure Adjust (Self : in out rectangle_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new rectangle_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out rectangle_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : rectangle_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out rectangle_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out rectangle_Vector;
Value : rectangle) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / rectangle'Size);
Self_Data_Saved : rectangle_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new rectangle_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new rectangle_Array'(Self.Data.all
 & rectangle_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_rectangle_Variable_Reference
(Self : aliased in out rectangle_Vector;
Index : Positive)
return rectangle_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_rectangle_Constant_Reference
(Self : aliased rectangle_Vector;
Index : Positive)
return rectangle_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(codeFlow_Array, codeFlow_Array_Access);

overriding procedure Adjust (Self : in out codeFlow_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new codeFlow_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out codeFlow_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : codeFlow_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out codeFlow_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out codeFlow_Vector;
Value : codeFlow) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / codeFlow'Size);
Self_Data_Saved : codeFlow_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new codeFlow_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new codeFlow_Array'(Self.Data.all
 & codeFlow_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_codeFlow_Variable_Reference
(Self : aliased in out codeFlow_Vector;
Index : Positive)
return codeFlow_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_codeFlow_Constant_Reference
(Self : aliased codeFlow_Vector;
Index : Positive)
return codeFlow_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(toolComponentReference_Array, toolComponentReference_Array_Access);

overriding procedure Adjust (Self : in out toolComponentReference_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new toolComponentReference_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out toolComponentReference_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : toolComponentReference_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out toolComponentReference_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out toolComponentReference_Vector;
Value : toolComponentReference) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / toolComponentReference'Size);
Self_Data_Saved : toolComponentReference_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new toolComponentReference_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new toolComponentReference_Array'(Self.Data.all
 & toolComponentReference_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_toolComponentReference_Variable_Reference
(Self : aliased in out toolComponentReference_Vector;
Index : Positive)
return toolComponentReference_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_toolComponentReference_Constant_Reference
(Self : aliased toolComponentReference_Vector;
Index : Positive)
return toolComponentReference_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(edge_Array, edge_Array_Access);

overriding procedure Adjust (Self : in out edge_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new edge_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out edge_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : edge_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out edge_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out edge_Vector;
Value : edge) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / edge'Size);
Self_Data_Saved : edge_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new edge_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new edge_Array'(Self.Data.all
 & edge_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_edge_Variable_Reference
(Self : aliased in out edge_Vector;
Index : Positive)
return edge_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_edge_Constant_Reference
(Self : aliased edge_Vector;
Index : Positive)
return edge_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(toolComponent_contents_Array, toolComponent_contents_Array_Access);

overriding procedure Adjust (Self : in out toolComponent_contents_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new toolComponent_contents_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out toolComponent_contents_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : toolComponent_contents_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out toolComponent_contents_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out toolComponent_contents_Vector;
Value : Enum.toolComponent_contents) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / Enum.toolComponent_contents'Size);
Self_Data_Saved : toolComponent_contents_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new toolComponent_contents_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new toolComponent_contents_Array'(Self.Data.all
 & toolComponent_contents_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_toolComponent_contents_Variable_Reference
(Self : aliased in out toolComponent_contents_Vector;
Index : Positive)
return toolComponent_contents_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_toolComponent_contents_Constant_Reference
(Self : aliased toolComponent_contents_Vector;
Index : Positive)
return toolComponent_contents_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(node_Array, node_Array_Access);

overriding procedure Adjust (Self : in out node_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new node_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out node_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : node_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out node_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out node_Vector;
Value : node) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / node'Size);
Self_Data_Saved : node_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new node_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new node_Array'(Self.Data.all
 & node_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_node_Variable_Reference
(Self : aliased in out node_Vector;
Index : Positive)
return node_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_node_Constant_Reference
(Self : aliased node_Vector;
Index : Positive)
return node_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(threadFlow_Array, threadFlow_Array_Access);

overriding procedure Adjust (Self : in out threadFlow_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new threadFlow_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out threadFlow_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : threadFlow_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out threadFlow_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out threadFlow_Vector;
Value : threadFlow) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / threadFlow'Size);
Self_Data_Saved : threadFlow_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new threadFlow_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new threadFlow_Array'(Self.Data.all
 & threadFlow_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_threadFlow_Variable_Reference
(Self : aliased in out threadFlow_Vector;
Index : Positive)
return threadFlow_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_threadFlow_Constant_Reference
(Self : aliased threadFlow_Vector;
Index : Positive)
return threadFlow_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(fix_Array, fix_Array_Access);

overriding procedure Adjust (Self : in out fix_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new fix_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out fix_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : fix_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out fix_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out fix_Vector;
Value : fix) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / fix'Size);
Self_Data_Saved : fix_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new fix_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new fix_Array'(Self.Data.all
 & fix_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_fix_Variable_Reference
(Self : aliased in out fix_Vector;
Index : Positive)
return fix_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_fix_Constant_Reference
(Self : aliased fix_Vector;
Index : Positive)
return fix_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(invocation_Array, invocation_Array_Access);

overriding procedure Adjust (Self : in out invocation_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new invocation_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out invocation_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : invocation_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out invocation_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out invocation_Vector;
Value : invocation) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / invocation'Size);
Self_Data_Saved : invocation_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new invocation_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new invocation_Array'(Self.Data.all
 & invocation_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_invocation_Variable_Reference
(Self : aliased in out invocation_Vector;
Index : Positive)
return invocation_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_invocation_Constant_Reference
(Self : aliased invocation_Vector;
Index : Positive)
return invocation_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(artifactChange_Array, artifactChange_Array_Access);

overriding procedure Adjust (Self : in out artifactChange_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new artifactChange_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out artifactChange_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : artifactChange_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out artifactChange_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out artifactChange_Vector;
Value : artifactChange) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / artifactChange'Size);
Self_Data_Saved : artifactChange_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new artifactChange_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new artifactChange_Array'(Self.Data.all
 & artifactChange_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_artifactChange_Variable_Reference
(Self : aliased in out artifactChange_Vector;
Index : Positive)
return artifactChange_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_artifactChange_Constant_Reference
(Self : aliased artifactChange_Vector;
Index : Positive)
return artifactChange_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(artifact_roles_Array, artifact_roles_Array_Access);

overriding procedure Adjust (Self : in out artifact_roles_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new artifact_roles_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out artifact_roles_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : artifact_roles_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out artifact_roles_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out artifact_roles_Vector;
Value : Enum.artifact_roles) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / Enum.artifact_roles'Size);
Self_Data_Saved : artifact_roles_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new artifact_roles_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new artifact_roles_Array'(Self.Data.all
 & artifact_roles_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_artifact_roles_Variable_Reference
(Self : aliased in out artifact_roles_Vector;
Index : Positive)
return artifact_roles_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_artifact_roles_Constant_Reference
(Self : aliased artifact_roles_Vector;
Index : Positive)
return artifact_roles_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(artifact_Array, artifact_Array_Access);

overriding procedure Adjust (Self : in out artifact_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new artifact_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out artifact_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : artifact_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out artifact_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out artifact_Vector;
Value : artifact) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / artifact'Size);
Self_Data_Saved : artifact_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new artifact_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new artifact_Array'(Self.Data.all
 & artifact_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_artifact_Variable_Reference
(Self : aliased in out artifact_Vector;
Index : Positive)
return artifact_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_artifact_Constant_Reference
(Self : aliased artifact_Vector;
Index : Positive)
return artifact_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(logicalLocation_Array, logicalLocation_Array_Access);

overriding procedure Adjust (Self : in out logicalLocation_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new logicalLocation_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out logicalLocation_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : logicalLocation_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out logicalLocation_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out logicalLocation_Vector;
Value : logicalLocation) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / logicalLocation'Size);
Self_Data_Saved : logicalLocation_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new logicalLocation_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new logicalLocation_Array'(Self.Data.all
 & logicalLocation_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_logicalLocation_Variable_Reference
(Self : aliased in out logicalLocation_Vector;
Index : Positive)
return logicalLocation_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_logicalLocation_Constant_Reference
(Self : aliased logicalLocation_Vector;
Index : Positive)
return logicalLocation_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(webRequest_Array, webRequest_Array_Access);

overriding procedure Adjust (Self : in out webRequest_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new webRequest_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out webRequest_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : webRequest_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out webRequest_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out webRequest_Vector;
Value : webRequest) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / webRequest'Size);
Self_Data_Saved : webRequest_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new webRequest_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new webRequest_Array'(Self.Data.all
 & webRequest_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_webRequest_Variable_Reference
(Self : aliased in out webRequest_Vector;
Index : Positive)
return webRequest_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_webRequest_Constant_Reference
(Self : aliased webRequest_Vector;
Index : Positive)
return webRequest_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(externalProperties_Array, externalProperties_Array_Access);

overriding procedure Adjust (Self : in out externalProperties_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new externalProperties_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out externalProperties_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : externalProperties_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out externalProperties_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out externalProperties_Vector;
Value : externalProperties) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / externalProperties'Size);
Self_Data_Saved : externalProperties_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new externalProperties_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new externalProperties_Array'(Self.Data.all
 & externalProperties_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_externalProperties_Variable_Reference
(Self : aliased in out externalProperties_Vector;
Index : Positive)
return externalProperties_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_externalProperties_Constant_Reference
(Self : aliased externalProperties_Vector;
Index : Positive)
return externalProperties_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(run_Array, run_Array_Access);

overriding procedure Adjust (Self : in out run_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new run_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out run_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : run_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out run_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out run_Vector;
Value : run) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / run'Size);
Self_Data_Saved : run_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new run_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new run_Array'(Self.Data.all
 & run_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_run_Variable_Reference
(Self : aliased in out run_Vector;
Index : Positive)
return run_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_run_Constant_Reference
(Self : aliased run_Vector;
Index : Positive)
return run_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(a_exception_Array, a_exception_Array_Access);

overriding procedure Adjust (Self : in out a_exception_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new a_exception_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out a_exception_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : a_exception_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out a_exception_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out a_exception_Vector;
Value : a_exception) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / a_exception'Size);
Self_Data_Saved : a_exception_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new a_exception_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new a_exception_Array'(Self.Data.all
 & a_exception_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_a_exception_Variable_Reference
(Self : aliased in out a_exception_Vector;
Index : Positive)
return a_exception_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_a_exception_Constant_Reference
(Self : aliased a_exception_Vector;
Index : Positive)
return a_exception_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(reportingDescriptor_Array, reportingDescriptor_Array_Access);

overriding procedure Adjust (Self : in out reportingDescriptor_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new reportingDescriptor_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out reportingDescriptor_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : reportingDescriptor_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out reportingDescriptor_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out reportingDescriptor_Vector;
Value : reportingDescriptor) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / reportingDescriptor'Size);
Self_Data_Saved : reportingDescriptor_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new reportingDescriptor_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new reportingDescriptor_Array'(Self.Data.all
 & reportingDescriptor_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_reportingDescriptor_Variable_Reference
(Self : aliased in out reportingDescriptor_Vector;
Index : Positive)
return reportingDescriptor_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_reportingDescriptor_Constant_Reference
(Self : aliased reportingDescriptor_Vector;
Index : Positive)
return reportingDescriptor_Constant_Reference
is (Element => Self.Data (Index)'Access);

procedure Free is new Ada.Unchecked_Deallocation
(artifactLocation_Array, artifactLocation_Array_Access);

overriding procedure Adjust (Self : in out artifactLocation_Vector) is
begin
if Self.Length > 0 then
Self.Data :=
new artifactLocation_Array'(Self.Data (1 .. Self.Length));
end if;
end Adjust;

overriding procedure Finalize (Self : in out artifactLocation_Vector) is
begin
Free (Self.Data);
Self.Length := 0;
end Finalize;

function Length (Self : artifactLocation_Vector) return Natural is (Self.Length);

procedure Clear (Self : in out artifactLocation_Vector) is
begin
   Self.Length := 0;
end Clear;

procedure Append
(Self : in out artifactLocation_Vector;
Value : artifactLocation) is
Init_Length : constant Positive :=
Positive'Max (1, 256 / artifactLocation'Size);
Self_Data_Saved : artifactLocation_Array_Access := Self.Data;
begin
if Self.Length = 0 then
Self.Data := new artifactLocation_Array (1 .. Init_Length);
elsif Self.Length = Self.Data'Last then
Self.Data :=
new artifactLocation_Array'(Self.Data.all
 & artifactLocation_Array'(1 .. Self.Length => <>));
Free (Self_Data_Saved);
end if;
Self.Length := Self.Length + 1;
Self.Data (Self.Length) := Value;
end Append;

not overriding function Get_artifactLocation_Variable_Reference
(Self : aliased in out artifactLocation_Vector;
Index : Positive)
return artifactLocation_Variable_Reference
is (Element => Self.Data (Index)'Access);

not overriding function Get_artifactLocation_Constant_Reference
(Self : aliased artifactLocation_Vector;
Index : Positive)
return artifactLocation_Constant_Reference
is (Element => Self.Data (Index)'Access);

end SARIF.Types;

--
--  Copyright (C) 2024, AdaCore
--
--  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-

with VSS.JSON.Content_Handlers;

package SARIF.Types.Outputs is

procedure Output_notification_level
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.notification_level);

procedure Output_suppression_kind
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.suppression_kind);

procedure Output_suppression_status
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.suppression_status);

procedure Output_toolComponent_contents
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.toolComponent_contents);

procedure Output_artifact_roles
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.artifact_roles);

procedure Output_reportingConfiguration_level
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.reportingConfiguration_level);

procedure Output_result_kind
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.result_kind);

procedure Output_result_level
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.result_level);

procedure Output_result_baselineState
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.result_baselineState);

procedure Output_run_columnKind
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.run_columnKind);

procedure Output_threadFlowLocation_importance
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.threadFlowLocation_importance);

procedure Output_node
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : node);

procedure Output_edgeTraversal
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : edgeTraversal);

procedure Output_stackFrame
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : stackFrame);

procedure Output_reportingDescriptorRelationship
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : reportingDescriptorRelationship);

procedure Output_propertyBag
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : propertyBag);

procedure Output_logicalLocation
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : logicalLocation);

procedure Output_resultProvenance
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : resultProvenance);

procedure Output_message
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : message);

procedure Output_artifactChange
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : artifactChange);

procedure Output_address
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : address);

procedure Output_reportingDescriptorReference
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : reportingDescriptorReference);

procedure Output_translationMetadata
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : translationMetadata);

procedure Output_notification
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : notification);

procedure Output_physicalLocation
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : physicalLocation);

procedure Output_versionControlDetails
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : versionControlDetails);

procedure Output_location
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : location);

procedure Output_suppression
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : suppression);

procedure Output_externalPropertyFileReference
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : externalPropertyFileReference);

procedure Output_locationRelationship
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : locationRelationship);

procedure Output_edge
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : edge);

procedure Output_Root
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Root);

procedure Output_specialLocations
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : specialLocations);

procedure Output_toolComponent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : toolComponent);

procedure Output_invocation
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : invocation);

procedure Output_conversion
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : conversion);

procedure Output_runAutomationDetails
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : runAutomationDetails);

procedure Output_graph
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : graph);

procedure Output_externalProperties
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : externalProperties);

procedure Output_rectangle
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : rectangle);

procedure Output_reportingDescriptor
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : reportingDescriptor);

procedure Output_artifact
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : artifact);

procedure Output_reportingConfiguration
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : reportingConfiguration);

procedure Output_toolComponentReference
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : toolComponentReference);

procedure Output_tool
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : tool);

procedure Output_webRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : webRequest);

procedure Output_fix
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : fix);

procedure Output_result
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : result);

procedure Output_region
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : region);

procedure Output_artifactLocation
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : artifactLocation);

procedure Output_graphTraversal
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : graphTraversal);

procedure Output_attachment
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : attachment);

procedure Output_stack
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : stack);

procedure Output_replacement
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : replacement);

procedure Output_run
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : run);

procedure Output_externalPropertyFileReferences
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : externalPropertyFileReferences);

procedure Output_a_exception
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : a_exception);

procedure Output_threadFlowLocation
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : threadFlowLocation);

procedure Output_codeFlow
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : codeFlow);

procedure Output_multiformatMessageString
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : multiformatMessageString);

procedure Output_artifactContent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : artifactContent);

procedure Output_webResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : webResponse);

procedure Output_threadFlow
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : threadFlow);

procedure Output_configurationOverride
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : configurationOverride);

end SARIF.Types.Outputs;
--
--  Copyright (C) 2024, AdaCore
--
--  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-

with Interfaces;
package body SARIF.Types.Outputs is
pragma Style_Checks (Off);
procedure Output_Any_Value
  (Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
   Value   : Any_Value'Class) is
begin
   for Item of Value loop
      case Item.Kind is
         when VSS.JSON.Streams.Start_Array =>
            Handler.Start_Array;
         when VSS.JSON.Streams.End_Array =>
            Handler.End_Array;
         when VSS.JSON.Streams.Start_Object =>
            Handler.Start_Object;
         when VSS.JSON.Streams.End_Object =>
            Handler.End_Object;
         when VSS.JSON.Streams.Key_Name =>
            Handler.Key_Name (Item.Key_Name);
         when VSS.JSON.Streams.String_Value =>
            Handler.String_Value (Item.String_Value);
         when VSS.JSON.Streams.Number_Value =>
            Handler.Number_Value (Item.Number_Value);
         when VSS.JSON.Streams.Boolean_Value =>
            Handler.Boolean_Value (Item.Boolean_Value);
         when VSS.JSON.Streams.Null_Value =>
            Handler.Null_Value;
         when VSS.JSON.Streams.None =>
            null;
         when VSS.JSON.Streams.Invalid =>
            raise Program_Error;
         when VSS.JSON.Streams.Start_Document =>
            raise Program_Error;
         when VSS.JSON.Streams.End_Document =>
            raise Program_Error;
         when VSS.JSON.Streams.Comment =>
            raise Program_Error;
      end case;
   end loop;
end Output_Any_Value;

procedure Output_notification_level
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.notification_level) is
begin
case Value is
when Enum.none =>
Handler.String_Value ("none");
when Enum.note =>
Handler.String_Value ("note");
when Enum.warning =>
Handler.String_Value ("warning");
when Enum.error =>
Handler.String_Value ("error");
end case;
end Output_notification_level;

procedure Output_suppression_kind
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.suppression_kind) is
begin
case Value is
when Enum.inSource =>
Handler.String_Value ("inSource");
when Enum.external =>
Handler.String_Value ("external");
end case;
end Output_suppression_kind;

procedure Output_suppression_status
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.suppression_status) is
begin
case Value is
when Enum.accepted =>
Handler.String_Value ("accepted");
when Enum.underReview =>
Handler.String_Value ("underReview");
when Enum.rejected =>
Handler.String_Value ("rejected");
end case;
end Output_suppression_status;

procedure Output_toolComponent_contents
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.toolComponent_contents) is
begin
case Value is
when Enum.localizedData =>
Handler.String_Value ("localizedData");
when Enum.nonLocalizedData =>
Handler.String_Value ("nonLocalizedData");
end case;
end Output_toolComponent_contents;

procedure Output_artifact_roles
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.artifact_roles) is
begin
case Value is
when Enum.analysisTarget =>
Handler.String_Value ("analysisTarget");
when Enum.attachment =>
Handler.String_Value ("attachment");
when Enum.responseFile =>
Handler.String_Value ("responseFile");
when Enum.resultFile =>
Handler.String_Value ("resultFile");
when Enum.standardStream =>
Handler.String_Value ("standardStream");
when Enum.tracedFile =>
Handler.String_Value ("tracedFile");
when Enum.unmodified =>
Handler.String_Value ("unmodified");
when Enum.modified =>
Handler.String_Value ("modified");
when Enum.added =>
Handler.String_Value ("added");
when Enum.deleted =>
Handler.String_Value ("deleted");
when Enum.renamed =>
Handler.String_Value ("renamed");
when Enum.uncontrolled =>
Handler.String_Value ("uncontrolled");
when Enum.driver =>
Handler.String_Value ("driver");
when Enum.extension =>
Handler.String_Value ("extension");
when Enum.translation =>
Handler.String_Value ("translation");
when Enum.taxonomy =>
Handler.String_Value ("taxonomy");
when Enum.policy =>
Handler.String_Value ("policy");
when Enum.referencedOnCommandLine =>
Handler.String_Value ("referencedOnCommandLine");
when Enum.memoryContents =>
Handler.String_Value ("memoryContents");
when Enum.directory =>
Handler.String_Value ("directory");
when Enum.userSpecifiedConfiguration =>
Handler.String_Value ("userSpecifiedConfiguration");
when Enum.toolSpecifiedConfiguration =>
Handler.String_Value ("toolSpecifiedConfiguration");
when Enum.debugOutputFile =>
Handler.String_Value ("debugOutputFile");
end case;
end Output_artifact_roles;

procedure Output_reportingConfiguration_level
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.reportingConfiguration_level) is
begin
case Value is
when Enum.none =>
Handler.String_Value ("none");
when Enum.note =>
Handler.String_Value ("note");
when Enum.warning =>
Handler.String_Value ("warning");
when Enum.error =>
Handler.String_Value ("error");
end case;
end Output_reportingConfiguration_level;

procedure Output_result_kind
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.result_kind) is
begin
case Value is
when Enum.notApplicable =>
Handler.String_Value ("notApplicable");
when Enum.pass =>
Handler.String_Value ("pass");
when Enum.fail =>
Handler.String_Value ("fail");
when Enum.review =>
Handler.String_Value ("review");
when Enum.open =>
Handler.String_Value ("open");
when Enum.informational =>
Handler.String_Value ("informational");
end case;
end Output_result_kind;

procedure Output_result_level
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.result_level) is
begin
case Value is
when Enum.none =>
Handler.String_Value ("none");
when Enum.note =>
Handler.String_Value ("note");
when Enum.warning =>
Handler.String_Value ("warning");
when Enum.error =>
Handler.String_Value ("error");
end case;
end Output_result_level;

procedure Output_result_baselineState
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.result_baselineState) is
begin
case Value is
when Enum.a_new =>
Handler.String_Value ("new");
when Enum.unchanged =>
Handler.String_Value ("unchanged");
when Enum.updated =>
Handler.String_Value ("updated");
when Enum.absent =>
Handler.String_Value ("absent");
end case;
end Output_result_baselineState;

procedure Output_run_columnKind
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.run_columnKind) is
begin
case Value is
when Enum.utf16CodeUnits =>
Handler.String_Value ("utf16CodeUnits");
when Enum.unicodeCodePoints =>
Handler.String_Value ("unicodeCodePoints");
end case;
end Output_run_columnKind;

procedure Output_threadFlowLocation_importance
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Enum.threadFlowLocation_importance) is
begin
case Value is
when Enum.important =>
Handler.String_Value ("important");
when Enum.essential =>
Handler.String_Value ("essential");
when Enum.unimportant =>
Handler.String_Value ("unimportant");
end case;
end Output_threadFlowLocation_importance;

procedure Output_node
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : node) is
begin
Handler.Start_Object;
Handler.Key_Name ("id");
Handler.String_Value (Value.id);
if Value.label.Is_Set then
Handler.Key_Name ("label");
Output_message (Handler, Value.label.Value);
end if;
if Value.location.Is_Set then
Handler.Key_Name ("location");
Output_location (Handler, Value.location.Value);
end if;
if Value.children.Length > 0 then
Handler.Key_Name ("children");
Handler.Start_Array;
for J in 1 .. Value.children.Length loop
Output_node (Handler, Value.children (J));
end loop;
Handler.End_Array;
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_node;

procedure Output_edgeTraversal
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : edgeTraversal) is
begin
Handler.Start_Object;
Handler.Key_Name ("edgeId");
Handler.String_Value (Value.edgeId);
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_message (Handler, Value.message.Value);
end if;
if not Value.finalState.Is_Empty then
Handler.Key_Name ("finalState");
Output_Any_Value (Handler, Value.finalState);
end if;
if Value.stepOverEdgeCount.Is_Set then
Handler.Key_Name ("stepOverEdgeCount");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.stepOverEdgeCount.Value)));
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_edgeTraversal;

procedure Output_stackFrame
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : stackFrame) is
begin
Handler.Start_Object;
if Value.location.Is_Set then
Handler.Key_Name ("location");
Output_location (Handler, Value.location.Value);
end if;
if not Value.module.Is_Null then
Handler.Key_Name ("module");
Handler.String_Value (Value.module);
end if;
if Value.threadId.Is_Set then
Handler.Key_Name ("threadId");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.threadId.Value)));
end if;
if not Value.parameters.Is_Empty then
Handler.Key_Name ("parameters");
Handler.Start_Array;
for J in 1 .. Value.parameters.Length loop
Handler.String_Value (Value.parameters (J));
end loop;
Handler.End_Array;
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_stackFrame;

procedure Output_reportingDescriptorRelationship
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : reportingDescriptorRelationship) is
begin
Handler.Start_Object;
Handler.Key_Name ("target");
Output_reportingDescriptorReference (Handler, Value.target);
if not Value.kinds.Is_Empty then
Handler.Key_Name ("kinds");
Handler.Start_Array;
for J in 1 .. Value.kinds.Length loop
Handler.String_Value (Value.kinds (J));
end loop;
Handler.End_Array;
end if;
if Value.description.Is_Set then
Handler.Key_Name ("description");
Output_message (Handler, Value.description.Value);
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_reportingDescriptorRelationship;

procedure Output_propertyBag
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : propertyBag) is
begin
Handler.Start_Object;
if not Value.tags.Is_Empty then
Handler.Key_Name ("tags");
Handler.Start_Array;
for J in 1 .. Value.tags.Length loop
Handler.String_Value (Value.tags (J));
end loop;
Handler.End_Array;
end if;
Handler.End_Object;
end Output_propertyBag;

procedure Output_logicalLocation
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : logicalLocation) is
begin
Handler.Start_Object;
if not Value.name.Is_Null then
Handler.Key_Name ("name");
Handler.String_Value (Value.name);
end if;
if Value.index.Is_Set then
Handler.Key_Name ("index");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.index.Value)));
end if;
if not Value.fullyQualifiedName.Is_Null then
Handler.Key_Name ("fullyQualifiedName");
Handler.String_Value (Value.fullyQualifiedName);
end if;
if not Value.decoratedName.Is_Null then
Handler.Key_Name ("decoratedName");
Handler.String_Value (Value.decoratedName);
end if;
if Value.parentIndex.Is_Set then
Handler.Key_Name ("parentIndex");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.parentIndex.Value)));
end if;
if not Value.kind.Is_Null then
Handler.Key_Name ("kind");
Handler.String_Value (Value.kind);
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_logicalLocation;

procedure Output_resultProvenance
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : resultProvenance) is
begin
Handler.Start_Object;
if not Value.firstDetectionTimeUtc.Is_Null then
Handler.Key_Name ("firstDetectionTimeUtc");
Handler.String_Value (Value.firstDetectionTimeUtc);
end if;
if not Value.lastDetectionTimeUtc.Is_Null then
Handler.Key_Name ("lastDetectionTimeUtc");
Handler.String_Value (Value.lastDetectionTimeUtc);
end if;
if not Value.firstDetectionRunGuid.Is_Null then
Handler.Key_Name ("firstDetectionRunGuid");
Handler.String_Value (Value.firstDetectionRunGuid);
end if;
if not Value.lastDetectionRunGuid.Is_Null then
Handler.Key_Name ("lastDetectionRunGuid");
Handler.String_Value (Value.lastDetectionRunGuid);
end if;
if Value.invocationIndex.Is_Set then
Handler.Key_Name ("invocationIndex");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.invocationIndex.Value)));
end if;
if Value.conversionSources.Length > 0 then
Handler.Key_Name ("conversionSources");
Handler.Start_Array;
for J in 1 .. Value.conversionSources.Length loop
Output_physicalLocation (Handler, Value.conversionSources (J));
end loop;
Handler.End_Array;
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_resultProvenance;

procedure Output_message
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : message) is
begin
Handler.Start_Object;
if not Value.text.Is_Null then
Handler.Key_Name ("text");
Handler.String_Value (Value.text);
end if;
if not Value.markdown.Is_Null then
Handler.Key_Name ("markdown");
Handler.String_Value (Value.markdown);
end if;
if not Value.id.Is_Null then
Handler.Key_Name ("id");
Handler.String_Value (Value.id);
end if;
if not Value.arguments.Is_Empty then
Handler.Key_Name ("arguments");
Handler.Start_Array;
for J in 1 .. Value.arguments.Length loop
Handler.String_Value (Value.arguments (J));
end loop;
Handler.End_Array;
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_message;

procedure Output_artifactChange
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : artifactChange) is
begin
Handler.Start_Object;
Handler.Key_Name ("artifactLocation");
Output_artifactLocation (Handler, Value.artifactLocation);
Handler.Key_Name ("replacements");
Handler.Start_Array;
for J in 1 .. Value.replacements.Length loop
Output_replacement (Handler, Value.replacements (J));
end loop;
Handler.End_Array;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_artifactChange;

procedure Output_address
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : address) is
begin
Handler.Start_Object;
if Value.absoluteAddress.Is_Set then
Handler.Key_Name ("absoluteAddress");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.absoluteAddress.Value)));
end if;
if Value.relativeAddress.Is_Set then
Handler.Key_Name ("relativeAddress");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.relativeAddress.Value)));
end if;
if Value.length.Is_Set then
Handler.Key_Name ("length");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.length.Value)));
end if;
if not Value.kind.Is_Null then
Handler.Key_Name ("kind");
Handler.String_Value (Value.kind);
end if;
if not Value.name.Is_Null then
Handler.Key_Name ("name");
Handler.String_Value (Value.name);
end if;
if not Value.fullyQualifiedName.Is_Null then
Handler.Key_Name ("fullyQualifiedName");
Handler.String_Value (Value.fullyQualifiedName);
end if;
if Value.offsetFromParent.Is_Set then
Handler.Key_Name ("offsetFromParent");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.offsetFromParent.Value)));
end if;
if Value.index.Is_Set then
Handler.Key_Name ("index");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.index.Value)));
end if;
if Value.parentIndex.Is_Set then
Handler.Key_Name ("parentIndex");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.parentIndex.Value)));
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_address;

procedure Output_reportingDescriptorReference
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : reportingDescriptorReference) is
begin
Handler.Start_Object;
if not Value.id.Is_Null then
Handler.Key_Name ("id");
Handler.String_Value (Value.id);
end if;
if Value.index.Is_Set then
Handler.Key_Name ("index");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.index.Value)));
end if;
if not Value.guid.Is_Null then
Handler.Key_Name ("guid");
Handler.String_Value (Value.guid);
end if;
if Value.toolComponent.Is_Set then
Handler.Key_Name ("toolComponent");
Output_toolComponentReference (Handler, Value.toolComponent.Value);
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_reportingDescriptorReference;

procedure Output_translationMetadata
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : translationMetadata) is
begin
Handler.Start_Object;
Handler.Key_Name ("name");
Handler.String_Value (Value.name);
if not Value.fullName.Is_Null then
Handler.Key_Name ("fullName");
Handler.String_Value (Value.fullName);
end if;
if Value.shortDescription.Is_Set then
Handler.Key_Name ("shortDescription");
Output_multiformatMessageString (Handler, Value.shortDescription.Value);
end if;
if Value.fullDescription.Is_Set then
Handler.Key_Name ("fullDescription");
Output_multiformatMessageString (Handler, Value.fullDescription.Value);
end if;
if not Value.downloadUri.Is_Null then
Handler.Key_Name ("downloadUri");
Handler.String_Value (Value.downloadUri);
end if;
if not Value.informationUri.Is_Null then
Handler.Key_Name ("informationUri");
Handler.String_Value (Value.informationUri);
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_translationMetadata;

procedure Output_notification
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : notification) is
begin
Handler.Start_Object;
if Value.locations.Length > 0 then
Handler.Key_Name ("locations");
Handler.Start_Array;
for J in 1 .. Value.locations.Length loop
Output_location (Handler, Value.locations (J));
end loop;
Handler.End_Array;
end if;
Handler.Key_Name ("message");
Output_message (Handler, Value.message);
if Value.level.Is_Set then
Handler.Key_Name ("level");
Output_notification_level (Handler, Value.level.Value);
end if;
if Value.threadId.Is_Set then
Handler.Key_Name ("threadId");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.threadId.Value)));
end if;
if not Value.timeUtc.Is_Null then
Handler.Key_Name ("timeUtc");
Handler.String_Value (Value.timeUtc);
end if;
if Value.a_exception.Is_Set then
Handler.Key_Name ("exception");
Output_a_exception (Handler, Value.a_exception.Value);
end if;
if Value.descriptor.Is_Set then
Handler.Key_Name ("descriptor");
Output_reportingDescriptorReference (Handler, Value.descriptor.Value);
end if;
if Value.associatedRule.Is_Set then
Handler.Key_Name ("associatedRule");
Output_reportingDescriptorReference (Handler, Value.associatedRule.Value);
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_notification;

procedure Output_physicalLocation
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : physicalLocation) is
begin
Handler.Start_Object;
if Value.address.Is_Set then
Handler.Key_Name ("address");
Output_address (Handler, Value.address.Value);
end if;
if Value.artifactLocation.Is_Set then
Handler.Key_Name ("artifactLocation");
Output_artifactLocation (Handler, Value.artifactLocation.Value);
end if;
if Value.region.Is_Set then
Handler.Key_Name ("region");
Output_region (Handler, Value.region.Value);
end if;
if Value.contextRegion.Is_Set then
Handler.Key_Name ("contextRegion");
Output_region (Handler, Value.contextRegion.Value);
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_physicalLocation;

procedure Output_versionControlDetails
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : versionControlDetails) is
begin
Handler.Start_Object;
Handler.Key_Name ("repositoryUri");
Handler.String_Value (Value.repositoryUri);
if not Value.revisionId.Is_Null then
Handler.Key_Name ("revisionId");
Handler.String_Value (Value.revisionId);
end if;
if not Value.branch.Is_Null then
Handler.Key_Name ("branch");
Handler.String_Value (Value.branch);
end if;
if not Value.revisionTag.Is_Null then
Handler.Key_Name ("revisionTag");
Handler.String_Value (Value.revisionTag);
end if;
if not Value.asOfTimeUtc.Is_Null then
Handler.Key_Name ("asOfTimeUtc");
Handler.String_Value (Value.asOfTimeUtc);
end if;
if Value.mappedTo.Is_Set then
Handler.Key_Name ("mappedTo");
Output_artifactLocation (Handler, Value.mappedTo.Value);
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_versionControlDetails;

procedure Output_location
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : location) is
begin
Handler.Start_Object;
if Value.id.Is_Set then
Handler.Key_Name ("id");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.id.Value)));
end if;
if Value.physicalLocation.Is_Set then
Handler.Key_Name ("physicalLocation");
Output_physicalLocation (Handler, Value.physicalLocation.Value);
end if;
if Value.logicalLocations.Length > 0 then
Handler.Key_Name ("logicalLocations");
Handler.Start_Array;
for J in 1 .. Value.logicalLocations.Length loop
Output_logicalLocation (Handler, Value.logicalLocations (J));
end loop;
Handler.End_Array;
end if;
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_message (Handler, Value.message.Value);
end if;
if Value.annotations.Length > 0 then
Handler.Key_Name ("annotations");
Handler.Start_Array;
for J in 1 .. Value.annotations.Length loop
Output_region (Handler, Value.annotations (J));
end loop;
Handler.End_Array;
end if;
if Value.relationships.Length > 0 then
Handler.Key_Name ("relationships");
Handler.Start_Array;
for J in 1 .. Value.relationships.Length loop
Output_locationRelationship (Handler, Value.relationships (J));
end loop;
Handler.End_Array;
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_location;

procedure Output_suppression
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : suppression) is
begin
Handler.Start_Object;
if not Value.guid.Is_Null then
Handler.Key_Name ("guid");
Handler.String_Value (Value.guid);
end if;
Handler.Key_Name ("kind");
Output_suppression_kind (Handler, Value.kind);
if Value.status.Is_Set then
Handler.Key_Name ("status");
Output_suppression_status (Handler, Value.status.Value);
end if;
if not Value.justification.Is_Null then
Handler.Key_Name ("justification");
Handler.String_Value (Value.justification);
end if;
if Value.location.Is_Set then
Handler.Key_Name ("location");
Output_location (Handler, Value.location.Value);
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_suppression;

procedure Output_externalPropertyFileReference
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : externalPropertyFileReference) is
begin
Handler.Start_Object;
if Value.location.Is_Set then
Handler.Key_Name ("location");
Output_artifactLocation (Handler, Value.location.Value);
end if;
if not Value.guid.Is_Null then
Handler.Key_Name ("guid");
Handler.String_Value (Value.guid);
end if;
if Value.itemCount.Is_Set then
Handler.Key_Name ("itemCount");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.itemCount.Value)));
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_externalPropertyFileReference;

procedure Output_locationRelationship
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : locationRelationship) is
begin
Handler.Start_Object;
Handler.Key_Name ("target");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.target)));
if not Value.kinds.Is_Empty then
Handler.Key_Name ("kinds");
Handler.Start_Array;
for J in 1 .. Value.kinds.Length loop
Handler.String_Value (Value.kinds (J));
end loop;
Handler.End_Array;
end if;
if Value.description.Is_Set then
Handler.Key_Name ("description");
Output_message (Handler, Value.description.Value);
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_locationRelationship;

procedure Output_edge
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : edge) is
begin
Handler.Start_Object;
Handler.Key_Name ("id");
Handler.String_Value (Value.id);
if Value.label.Is_Set then
Handler.Key_Name ("label");
Output_message (Handler, Value.label.Value);
end if;
Handler.Key_Name ("sourceNodeId");
Handler.String_Value (Value.sourceNodeId);
Handler.Key_Name ("targetNodeId");
Handler.String_Value (Value.targetNodeId);
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_edge;

procedure Output_Root
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : Root) is
begin
Handler.Start_Object;
if not Value.schema.Is_Null then
Handler.Key_Name ("$schema");
Handler.String_Value (Value.schema);
end if;
Handler.Key_Name ("version");Handler.String_Value ("2.1.0");
Handler.Key_Name ("runs");
Handler.Start_Array;
for J in 1 .. Value.runs.Length loop
Output_run (Handler, Value.runs (J));
end loop;
Handler.End_Array;
if Value.inlineExternalProperties.Length > 0 then
Handler.Key_Name ("inlineExternalProperties");
Handler.Start_Array;
for J in 1 .. Value.inlineExternalProperties.Length loop
Output_externalProperties (Handler, Value.inlineExternalProperties (J));
end loop;
Handler.End_Array;
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_Root;

procedure Output_specialLocations
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : specialLocations) is
begin
Handler.Start_Object;
if Value.displayBase.Is_Set then
Handler.Key_Name ("displayBase");
Output_artifactLocation (Handler, Value.displayBase.Value);
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_specialLocations;

procedure Output_toolComponent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : toolComponent) is
begin
Handler.Start_Object;
if not Value.guid.Is_Null then
Handler.Key_Name ("guid");
Handler.String_Value (Value.guid);
end if;
Handler.Key_Name ("name");
Handler.String_Value (Value.name);
if not Value.organization.Is_Null then
Handler.Key_Name ("organization");
Handler.String_Value (Value.organization);
end if;
if not Value.product.Is_Null then
Handler.Key_Name ("product");
Handler.String_Value (Value.product);
end if;
if not Value.productSuite.Is_Null then
Handler.Key_Name ("productSuite");
Handler.String_Value (Value.productSuite);
end if;
if Value.shortDescription.Is_Set then
Handler.Key_Name ("shortDescription");
Output_multiformatMessageString (Handler, Value.shortDescription.Value);
end if;
if Value.fullDescription.Is_Set then
Handler.Key_Name ("fullDescription");
Output_multiformatMessageString (Handler, Value.fullDescription.Value);
end if;
if not Value.fullName.Is_Null then
Handler.Key_Name ("fullName");
Handler.String_Value (Value.fullName);
end if;
if not Value.version.Is_Null then
Handler.Key_Name ("version");
Handler.String_Value (Value.version);
end if;
if not Value.semanticVersion.Is_Null then
Handler.Key_Name ("semanticVersion");
Handler.String_Value (Value.semanticVersion);
end if;
if not Value.dottedQuadFileVersion.Is_Null then
Handler.Key_Name ("dottedQuadFileVersion");
Handler.String_Value (Value.dottedQuadFileVersion);
end if;
if not Value.releaseDateUtc.Is_Null then
Handler.Key_Name ("releaseDateUtc");
Handler.String_Value (Value.releaseDateUtc);
end if;
if not Value.downloadUri.Is_Null then
Handler.Key_Name ("downloadUri");
Handler.String_Value (Value.downloadUri);
end if;
if not Value.informationUri.Is_Null then
Handler.Key_Name ("informationUri");
Handler.String_Value (Value.informationUri);
end if;
if not Value.globalMessageStrings.Is_Empty then
Handler.Key_Name ("globalMessageStrings");
Output_Any_Value (Handler, Value.globalMessageStrings);
end if;
if Value.notifications.Length > 0 then
Handler.Key_Name ("notifications");
Handler.Start_Array;
for J in 1 .. Value.notifications.Length loop
Output_reportingDescriptor (Handler, Value.notifications (J));
end loop;
Handler.End_Array;
end if;
if Value.rules.Length > 0 then
Handler.Key_Name ("rules");
Handler.Start_Array;
for J in 1 .. Value.rules.Length loop
Output_reportingDescriptor (Handler, Value.rules (J));
end loop;
Handler.End_Array;
end if;
if Value.taxa.Length > 0 then
Handler.Key_Name ("taxa");
Handler.Start_Array;
for J in 1 .. Value.taxa.Length loop
Output_reportingDescriptor (Handler, Value.taxa (J));
end loop;
Handler.End_Array;
end if;
if Value.locations.Length > 0 then
Handler.Key_Name ("locations");
Handler.Start_Array;
for J in 1 .. Value.locations.Length loop
Output_artifactLocation (Handler, Value.locations (J));
end loop;
Handler.End_Array;
end if;
if not Value.language.Is_Null then
Handler.Key_Name ("language");
Handler.String_Value (Value.language);
end if;
if Value.contents.Length > 0 then
Handler.Key_Name ("contents");
Handler.Start_Array;
for J in 1 .. Value.contents.Length loop
Output_toolComponent_contents (Handler, Value.contents (J));
end loop;
Handler.End_Array;
end if;
if Value.isComprehensive then
Handler.Key_Name ("isComprehensive");
Handler.Boolean_Value (Value.isComprehensive);
end if;
if not Value.localizedDataSemanticVersion.Is_Null then
Handler.Key_Name ("localizedDataSemanticVersion");
Handler.String_Value (Value.localizedDataSemanticVersion);
end if;
if not Value.minimumRequiredLocalizedDataSemanticVersion.Is_Null then
Handler.Key_Name ("minimumRequiredLocalizedDataSemanticVersion");
Handler.String_Value (Value.minimumRequiredLocalizedDataSemanticVersion);
end if;
if Value.associatedComponent.Is_Set then
Handler.Key_Name ("associatedComponent");
Output_toolComponentReference (Handler, Value.associatedComponent.Value);
end if;
if Value.translationMetadata.Is_Set then
Handler.Key_Name ("translationMetadata");
Output_translationMetadata (Handler, Value.translationMetadata.Value);
end if;
if Value.supportedTaxonomies.Length > 0 then
Handler.Key_Name ("supportedTaxonomies");
Handler.Start_Array;
for J in 1 .. Value.supportedTaxonomies.Length loop
Output_toolComponentReference (Handler, Value.supportedTaxonomies (J));
end loop;
Handler.End_Array;
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_toolComponent;

procedure Output_invocation
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : invocation) is
begin
Handler.Start_Object;
if not Value.commandLine.Is_Null then
Handler.Key_Name ("commandLine");
Handler.String_Value (Value.commandLine);
end if;
if not Value.arguments.Is_Empty then
Handler.Key_Name ("arguments");
Handler.Start_Array;
for J in 1 .. Value.arguments.Length loop
Handler.String_Value (Value.arguments (J));
end loop;
Handler.End_Array;
end if;
if Value.responseFiles.Length > 0 then
Handler.Key_Name ("responseFiles");
Handler.Start_Array;
for J in 1 .. Value.responseFiles.Length loop
Output_artifactLocation (Handler, Value.responseFiles (J));
end loop;
Handler.End_Array;
end if;
if not Value.startTimeUtc.Is_Null then
Handler.Key_Name ("startTimeUtc");
Handler.String_Value (Value.startTimeUtc);
end if;
if not Value.endTimeUtc.Is_Null then
Handler.Key_Name ("endTimeUtc");
Handler.String_Value (Value.endTimeUtc);
end if;
if Value.exitCode.Is_Set then
Handler.Key_Name ("exitCode");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.exitCode.Value)));
end if;
if Value.ruleConfigurationOverrides.Length > 0 then
Handler.Key_Name ("ruleConfigurationOverrides");
Handler.Start_Array;
for J in 1 .. Value.ruleConfigurationOverrides.Length loop
Output_configurationOverride (Handler, Value.ruleConfigurationOverrides (J));
end loop;
Handler.End_Array;
end if;
if Value.notificationConfigurationOverrides.Length > 0 then
Handler.Key_Name ("notificationConfigurationOverrides");
Handler.Start_Array;
for J in 1 .. Value.notificationConfigurationOverrides.Length loop
Output_configurationOverride (Handler, Value.notificationConfigurationOverrides (J));
end loop;
Handler.End_Array;
end if;
if Value.toolExecutionNotifications.Length > 0 then
Handler.Key_Name ("toolExecutionNotifications");
Handler.Start_Array;
for J in 1 .. Value.toolExecutionNotifications.Length loop
Output_notification (Handler, Value.toolExecutionNotifications (J));
end loop;
Handler.End_Array;
end if;
if Value.toolConfigurationNotifications.Length > 0 then
Handler.Key_Name ("toolConfigurationNotifications");
Handler.Start_Array;
for J in 1 .. Value.toolConfigurationNotifications.Length loop
Output_notification (Handler, Value.toolConfigurationNotifications (J));
end loop;
Handler.End_Array;
end if;
if not Value.exitCodeDescription.Is_Null then
Handler.Key_Name ("exitCodeDescription");
Handler.String_Value (Value.exitCodeDescription);
end if;
if not Value.exitSignalName.Is_Null then
Handler.Key_Name ("exitSignalName");
Handler.String_Value (Value.exitSignalName);
end if;
if Value.exitSignalNumber.Is_Set then
Handler.Key_Name ("exitSignalNumber");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.exitSignalNumber.Value)));
end if;
if not Value.processStartFailureMessage.Is_Null then
Handler.Key_Name ("processStartFailureMessage");
Handler.String_Value (Value.processStartFailureMessage);
end if;
Handler.Key_Name ("executionSuccessful");
Handler.Boolean_Value (Value.executionSuccessful);
if not Value.machine.Is_Null then
Handler.Key_Name ("machine");
Handler.String_Value (Value.machine);
end if;
if not Value.account.Is_Null then
Handler.Key_Name ("account");
Handler.String_Value (Value.account);
end if;
if Value.processId.Is_Set then
Handler.Key_Name ("processId");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.processId.Value)));
end if;
if Value.executableLocation.Is_Set then
Handler.Key_Name ("executableLocation");
Output_artifactLocation (Handler, Value.executableLocation.Value);
end if;
if Value.workingDirectory.Is_Set then
Handler.Key_Name ("workingDirectory");
Output_artifactLocation (Handler, Value.workingDirectory.Value);
end if;
if not Value.environmentVariables.Is_Empty then
Handler.Key_Name ("environmentVariables");
Output_Any_Value (Handler, Value.environmentVariables);
end if;
if Value.stdin.Is_Set then
Handler.Key_Name ("stdin");
Output_artifactLocation (Handler, Value.stdin.Value);
end if;
if Value.stdout.Is_Set then
Handler.Key_Name ("stdout");
Output_artifactLocation (Handler, Value.stdout.Value);
end if;
if Value.stderr.Is_Set then
Handler.Key_Name ("stderr");
Output_artifactLocation (Handler, Value.stderr.Value);
end if;
if Value.stdoutStderr.Is_Set then
Handler.Key_Name ("stdoutStderr");
Output_artifactLocation (Handler, Value.stdoutStderr.Value);
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_invocation;

procedure Output_conversion
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : conversion) is
begin
Handler.Start_Object;
Handler.Key_Name ("tool");
Output_tool (Handler, Value.tool);
if Value.invocation.Is_Set then
Handler.Key_Name ("invocation");
Output_invocation (Handler, Value.invocation.Value);
end if;
if Value.analysisToolLogFiles.Length > 0 then
Handler.Key_Name ("analysisToolLogFiles");
Handler.Start_Array;
for J in 1 .. Value.analysisToolLogFiles.Length loop
Output_artifactLocation (Handler, Value.analysisToolLogFiles (J));
end loop;
Handler.End_Array;
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_conversion;

procedure Output_runAutomationDetails
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : runAutomationDetails) is
begin
Handler.Start_Object;
if Value.description.Is_Set then
Handler.Key_Name ("description");
Output_message (Handler, Value.description.Value);
end if;
if not Value.id.Is_Null then
Handler.Key_Name ("id");
Handler.String_Value (Value.id);
end if;
if not Value.guid.Is_Null then
Handler.Key_Name ("guid");
Handler.String_Value (Value.guid);
end if;
if not Value.correlationGuid.Is_Null then
Handler.Key_Name ("correlationGuid");
Handler.String_Value (Value.correlationGuid);
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_runAutomationDetails;

procedure Output_graph
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : graph) is
begin
Handler.Start_Object;
if Value.description.Is_Set then
Handler.Key_Name ("description");
Output_message (Handler, Value.description.Value);
end if;
if Value.nodes.Length > 0 then
Handler.Key_Name ("nodes");
Handler.Start_Array;
for J in 1 .. Value.nodes.Length loop
Output_node (Handler, Value.nodes (J));
end loop;
Handler.End_Array;
end if;
if Value.edges.Length > 0 then
Handler.Key_Name ("edges");
Handler.Start_Array;
for J in 1 .. Value.edges.Length loop
Output_edge (Handler, Value.edges (J));
end loop;
Handler.End_Array;
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_graph;

procedure Output_externalProperties
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : externalProperties) is
begin
Handler.Start_Object;
if not Value.schema.Is_Null then
Handler.Key_Name ("schema");
Handler.String_Value (Value.schema);
end if;
Handler.Key_Name ("version");Handler.String_Value ("2.1.0");
if not Value.guid.Is_Null then
Handler.Key_Name ("guid");
Handler.String_Value (Value.guid);
end if;
if not Value.runGuid.Is_Null then
Handler.Key_Name ("runGuid");
Handler.String_Value (Value.runGuid);
end if;
if Value.conversion.Is_Set then
Handler.Key_Name ("conversion");
Output_conversion (Handler, Value.conversion.Value);
end if;
if Value.graphs.Length > 0 then
Handler.Key_Name ("graphs");
Handler.Start_Array;
for J in 1 .. Value.graphs.Length loop
Output_graph (Handler, Value.graphs (J));
end loop;
Handler.End_Array;
end if;
if Value.externalizedProperties.Is_Set then
Handler.Key_Name ("externalizedProperties");
Output_propertyBag (Handler, Value.externalizedProperties.Value);
end if;
if Value.artifacts.Length > 0 then
Handler.Key_Name ("artifacts");
Handler.Start_Array;
for J in 1 .. Value.artifacts.Length loop
Output_artifact (Handler, Value.artifacts (J));
end loop;
Handler.End_Array;
end if;
if Value.invocations.Length > 0 then
Handler.Key_Name ("invocations");
Handler.Start_Array;
for J in 1 .. Value.invocations.Length loop
Output_invocation (Handler, Value.invocations (J));
end loop;
Handler.End_Array;
end if;
if Value.logicalLocations.Length > 0 then
Handler.Key_Name ("logicalLocations");
Handler.Start_Array;
for J in 1 .. Value.logicalLocations.Length loop
Output_logicalLocation (Handler, Value.logicalLocations (J));
end loop;
Handler.End_Array;
end if;
if Value.threadFlowLocations.Length > 0 then
Handler.Key_Name ("threadFlowLocations");
Handler.Start_Array;
for J in 1 .. Value.threadFlowLocations.Length loop
Output_threadFlowLocation (Handler, Value.threadFlowLocations (J));
end loop;
Handler.End_Array;
end if;
if Value.results.Length > 0 then
Handler.Key_Name ("results");
Handler.Start_Array;
for J in 1 .. Value.results.Length loop
Output_result (Handler, Value.results (J));
end loop;
Handler.End_Array;
end if;
if Value.taxonomies.Length > 0 then
Handler.Key_Name ("taxonomies");
Handler.Start_Array;
for J in 1 .. Value.taxonomies.Length loop
Output_toolComponent (Handler, Value.taxonomies (J));
end loop;
Handler.End_Array;
end if;
if Value.driver.Is_Set then
Handler.Key_Name ("driver");
Output_toolComponent (Handler, Value.driver.Value);
end if;
if Value.extensions.Length > 0 then
Handler.Key_Name ("extensions");
Handler.Start_Array;
for J in 1 .. Value.extensions.Length loop
Output_toolComponent (Handler, Value.extensions (J));
end loop;
Handler.End_Array;
end if;
if Value.policies.Length > 0 then
Handler.Key_Name ("policies");
Handler.Start_Array;
for J in 1 .. Value.policies.Length loop
Output_toolComponent (Handler, Value.policies (J));
end loop;
Handler.End_Array;
end if;
if Value.translations.Length > 0 then
Handler.Key_Name ("translations");
Handler.Start_Array;
for J in 1 .. Value.translations.Length loop
Output_toolComponent (Handler, Value.translations (J));
end loop;
Handler.End_Array;
end if;
if Value.addresses.Length > 0 then
Handler.Key_Name ("addresses");
Handler.Start_Array;
for J in 1 .. Value.addresses.Length loop
Output_address (Handler, Value.addresses (J));
end loop;
Handler.End_Array;
end if;
if Value.webRequests.Length > 0 then
Handler.Key_Name ("webRequests");
Handler.Start_Array;
for J in 1 .. Value.webRequests.Length loop
Output_webRequest (Handler, Value.webRequests (J));
end loop;
Handler.End_Array;
end if;
if Value.webResponses.Length > 0 then
Handler.Key_Name ("webResponses");
Handler.Start_Array;
for J in 1 .. Value.webResponses.Length loop
Output_webResponse (Handler, Value.webResponses (J));
end loop;
Handler.End_Array;
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_externalProperties;

procedure Output_rectangle
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : rectangle) is
begin
Handler.Start_Object;
if Value.top.Is_Set then
Handler.Key_Name ("top");
Handler.Float_Value(Interfaces.IEEE_Float_64 (Value.top.Value));
end if;
if Value.left.Is_Set then
Handler.Key_Name ("left");
Handler.Float_Value(Interfaces.IEEE_Float_64 (Value.left.Value));
end if;
if Value.bottom.Is_Set then
Handler.Key_Name ("bottom");
Handler.Float_Value(Interfaces.IEEE_Float_64 (Value.bottom.Value));
end if;
if Value.right.Is_Set then
Handler.Key_Name ("right");
Handler.Float_Value(Interfaces.IEEE_Float_64 (Value.right.Value));
end if;
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_message (Handler, Value.message.Value);
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_rectangle;

procedure Output_reportingDescriptor
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : reportingDescriptor) is
begin
Handler.Start_Object;
Handler.Key_Name ("id");
Handler.String_Value (Value.id);
if not Value.deprecatedIds.Is_Empty then
Handler.Key_Name ("deprecatedIds");
Handler.Start_Array;
for J in 1 .. Value.deprecatedIds.Length loop
Handler.String_Value (Value.deprecatedIds (J));
end loop;
Handler.End_Array;
end if;
if not Value.guid.Is_Null then
Handler.Key_Name ("guid");
Handler.String_Value (Value.guid);
end if;
if not Value.deprecatedGuids.Is_Empty then
Handler.Key_Name ("deprecatedGuids");
Handler.Start_Array;
for J in 1 .. Value.deprecatedGuids.Length loop
Handler.String_Value (Value.deprecatedGuids (J));
end loop;
Handler.End_Array;
end if;
if not Value.name.Is_Null then
Handler.Key_Name ("name");
Handler.String_Value (Value.name);
end if;
if not Value.deprecatedNames.Is_Empty then
Handler.Key_Name ("deprecatedNames");
Handler.Start_Array;
for J in 1 .. Value.deprecatedNames.Length loop
Handler.String_Value (Value.deprecatedNames (J));
end loop;
Handler.End_Array;
end if;
if Value.shortDescription.Is_Set then
Handler.Key_Name ("shortDescription");
Output_multiformatMessageString (Handler, Value.shortDescription.Value);
end if;
if Value.fullDescription.Is_Set then
Handler.Key_Name ("fullDescription");
Output_multiformatMessageString (Handler, Value.fullDescription.Value);
end if;
if not Value.messageStrings.Is_Empty then
Handler.Key_Name ("messageStrings");
Output_Any_Value (Handler, Value.messageStrings);
end if;
if Value.defaultConfiguration.Is_Set then
Handler.Key_Name ("defaultConfiguration");
Output_reportingConfiguration (Handler, Value.defaultConfiguration.Value);
end if;
if not Value.helpUri.Is_Null then
Handler.Key_Name ("helpUri");
Handler.String_Value (Value.helpUri);
end if;
if Value.help.Is_Set then
Handler.Key_Name ("help");
Output_multiformatMessageString (Handler, Value.help.Value);
end if;
if Value.relationships.Length > 0 then
Handler.Key_Name ("relationships");
Handler.Start_Array;
for J in 1 .. Value.relationships.Length loop
Output_reportingDescriptorRelationship (Handler, Value.relationships (J));
end loop;
Handler.End_Array;
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_reportingDescriptor;

procedure Output_artifact
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : artifact) is
begin
Handler.Start_Object;
if Value.description.Is_Set then
Handler.Key_Name ("description");
Output_message (Handler, Value.description.Value);
end if;
if Value.location.Is_Set then
Handler.Key_Name ("location");
Output_artifactLocation (Handler, Value.location.Value);
end if;
if Value.parentIndex.Is_Set then
Handler.Key_Name ("parentIndex");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.parentIndex.Value)));
end if;
if Value.offset.Is_Set then
Handler.Key_Name ("offset");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.offset.Value)));
end if;
if Value.length.Is_Set then
Handler.Key_Name ("length");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.length.Value)));
end if;
if Value.roles.Length > 0 then
Handler.Key_Name ("roles");
Handler.Start_Array;
for J in 1 .. Value.roles.Length loop
Output_artifact_roles (Handler, Value.roles (J));
end loop;
Handler.End_Array;
end if;
if not Value.mimeType.Is_Null then
Handler.Key_Name ("mimeType");
Handler.String_Value (Value.mimeType);
end if;
if Value.contents.Is_Set then
Handler.Key_Name ("contents");
Output_artifactContent (Handler, Value.contents.Value);
end if;
if not Value.encoding.Is_Null then
Handler.Key_Name ("encoding");
Handler.String_Value (Value.encoding);
end if;
if not Value.sourceLanguage.Is_Null then
Handler.Key_Name ("sourceLanguage");
Handler.String_Value (Value.sourceLanguage);
end if;
if not Value.hashes.Is_Empty then
Handler.Key_Name ("hashes");
Output_Any_Value (Handler, Value.hashes);
end if;
if not Value.lastModifiedTimeUtc.Is_Null then
Handler.Key_Name ("lastModifiedTimeUtc");
Handler.String_Value (Value.lastModifiedTimeUtc);
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_artifact;

procedure Output_reportingConfiguration
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : reportingConfiguration) is
begin
Handler.Start_Object;
if Value.enabled then
Handler.Key_Name ("enabled");
Handler.Boolean_Value (Value.enabled);
end if;
if Value.level.Is_Set then
Handler.Key_Name ("level");
Output_reportingConfiguration_level (Handler, Value.level.Value);
end if;
if Value.rank.Is_Set then
Handler.Key_Name ("rank");
Handler.Float_Value(Interfaces.IEEE_Float_64 (Value.rank.Value));
end if;
if Value.parameters.Is_Set then
Handler.Key_Name ("parameters");
Output_propertyBag (Handler, Value.parameters.Value);
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_reportingConfiguration;

procedure Output_toolComponentReference
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : toolComponentReference) is
begin
Handler.Start_Object;
if not Value.name.Is_Null then
Handler.Key_Name ("name");
Handler.String_Value (Value.name);
end if;
if Value.index.Is_Set then
Handler.Key_Name ("index");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.index.Value)));
end if;
if not Value.guid.Is_Null then
Handler.Key_Name ("guid");
Handler.String_Value (Value.guid);
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_toolComponentReference;

procedure Output_tool
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : tool) is
begin
Handler.Start_Object;
Handler.Key_Name ("driver");
Output_toolComponent (Handler, Value.driver);
if Value.extensions.Length > 0 then
Handler.Key_Name ("extensions");
Handler.Start_Array;
for J in 1 .. Value.extensions.Length loop
Output_toolComponent (Handler, Value.extensions (J));
end loop;
Handler.End_Array;
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_tool;

procedure Output_webRequest
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : webRequest) is
begin
Handler.Start_Object;
if Value.index.Is_Set then
Handler.Key_Name ("index");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.index.Value)));
end if;
if not Value.protocol.Is_Null then
Handler.Key_Name ("protocol");
Handler.String_Value (Value.protocol);
end if;
if not Value.version.Is_Null then
Handler.Key_Name ("version");
Handler.String_Value (Value.version);
end if;
if not Value.target.Is_Null then
Handler.Key_Name ("target");
Handler.String_Value (Value.target);
end if;
if not Value.method.Is_Null then
Handler.Key_Name ("method");
Handler.String_Value (Value.method);
end if;
if not Value.headers.Is_Empty then
Handler.Key_Name ("headers");
Output_Any_Value (Handler, Value.headers);
end if;
if not Value.parameters.Is_Empty then
Handler.Key_Name ("parameters");
Output_Any_Value (Handler, Value.parameters);
end if;
if Value.a_body.Is_Set then
Handler.Key_Name ("body");
Output_artifactContent (Handler, Value.a_body.Value);
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_webRequest;

procedure Output_fix
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : fix) is
begin
Handler.Start_Object;
if Value.description.Is_Set then
Handler.Key_Name ("description");
Output_message (Handler, Value.description.Value);
end if;
Handler.Key_Name ("artifactChanges");
Handler.Start_Array;
for J in 1 .. Value.artifactChanges.Length loop
Output_artifactChange (Handler, Value.artifactChanges (J));
end loop;
Handler.End_Array;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_fix;

procedure Output_result
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : result) is
begin
Handler.Start_Object;
if not Value.ruleId.Is_Null then
Handler.Key_Name ("ruleId");
Handler.String_Value (Value.ruleId);
end if;
if Value.ruleIndex.Is_Set then
Handler.Key_Name ("ruleIndex");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.ruleIndex.Value)));
end if;
if Value.rule.Is_Set then
Handler.Key_Name ("rule");
Output_reportingDescriptorReference (Handler, Value.rule.Value);
end if;
if Value.kind.Is_Set then
Handler.Key_Name ("kind");
Output_result_kind (Handler, Value.kind.Value);
end if;
if Value.level.Is_Set then
Handler.Key_Name ("level");
Output_result_level (Handler, Value.level.Value);
end if;
Handler.Key_Name ("message");
Output_message (Handler, Value.message);
if Value.analysisTarget.Is_Set then
Handler.Key_Name ("analysisTarget");
Output_artifactLocation (Handler, Value.analysisTarget.Value);
end if;
if Value.locations.Length > 0 then
Handler.Key_Name ("locations");
Handler.Start_Array;
for J in 1 .. Value.locations.Length loop
Output_location (Handler, Value.locations (J));
end loop;
Handler.End_Array;
end if;
if not Value.guid.Is_Null then
Handler.Key_Name ("guid");
Handler.String_Value (Value.guid);
end if;
if not Value.correlationGuid.Is_Null then
Handler.Key_Name ("correlationGuid");
Handler.String_Value (Value.correlationGuid);
end if;
if Value.occurrenceCount.Is_Set then
Handler.Key_Name ("occurrenceCount");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.occurrenceCount.Value)));
end if;
if not Value.partialFingerprints.Is_Empty then
Handler.Key_Name ("partialFingerprints");
Output_Any_Value (Handler, Value.partialFingerprints);
end if;
if not Value.fingerprints.Is_Empty then
Handler.Key_Name ("fingerprints");
Output_Any_Value (Handler, Value.fingerprints);
end if;
if Value.stacks.Length > 0 then
Handler.Key_Name ("stacks");
Handler.Start_Array;
for J in 1 .. Value.stacks.Length loop
Output_stack (Handler, Value.stacks (J));
end loop;
Handler.End_Array;
end if;
if Value.codeFlows.Length > 0 then
Handler.Key_Name ("codeFlows");
Handler.Start_Array;
for J in 1 .. Value.codeFlows.Length loop
Output_codeFlow (Handler, Value.codeFlows (J));
end loop;
Handler.End_Array;
end if;
if Value.graphs.Length > 0 then
Handler.Key_Name ("graphs");
Handler.Start_Array;
for J in 1 .. Value.graphs.Length loop
Output_graph (Handler, Value.graphs (J));
end loop;
Handler.End_Array;
end if;
if Value.graphTraversals.Length > 0 then
Handler.Key_Name ("graphTraversals");
Handler.Start_Array;
for J in 1 .. Value.graphTraversals.Length loop
Output_graphTraversal (Handler, Value.graphTraversals (J));
end loop;
Handler.End_Array;
end if;
if Value.relatedLocations.Length > 0 then
Handler.Key_Name ("relatedLocations");
Handler.Start_Array;
for J in 1 .. Value.relatedLocations.Length loop
Output_location (Handler, Value.relatedLocations (J));
end loop;
Handler.End_Array;
end if;
if Value.suppressions.Length > 0 then
Handler.Key_Name ("suppressions");
Handler.Start_Array;
for J in 1 .. Value.suppressions.Length loop
Output_suppression (Handler, Value.suppressions (J));
end loop;
Handler.End_Array;
end if;
if Value.baselineState.Is_Set then
Handler.Key_Name ("baselineState");
Output_result_baselineState (Handler, Value.baselineState.Value);
end if;
if Value.rank.Is_Set then
Handler.Key_Name ("rank");
Handler.Float_Value(Interfaces.IEEE_Float_64 (Value.rank.Value));
end if;
if Value.attachments.Length > 0 then
Handler.Key_Name ("attachments");
Handler.Start_Array;
for J in 1 .. Value.attachments.Length loop
Output_attachment (Handler, Value.attachments (J));
end loop;
Handler.End_Array;
end if;
if not Value.hostedViewerUri.Is_Null then
Handler.Key_Name ("hostedViewerUri");
Handler.String_Value (Value.hostedViewerUri);
end if;
if not Value.workItemUris.Is_Empty then
Handler.Key_Name ("workItemUris");
Handler.Start_Array;
for J in 1 .. Value.workItemUris.Length loop
Handler.String_Value (Value.workItemUris (J));
end loop;
Handler.End_Array;
end if;
if Value.provenance.Is_Set then
Handler.Key_Name ("provenance");
Output_resultProvenance (Handler, Value.provenance.Value);
end if;
if Value.fixes.Length > 0 then
Handler.Key_Name ("fixes");
Handler.Start_Array;
for J in 1 .. Value.fixes.Length loop
Output_fix (Handler, Value.fixes (J));
end loop;
Handler.End_Array;
end if;
if Value.taxa.Length > 0 then
Handler.Key_Name ("taxa");
Handler.Start_Array;
for J in 1 .. Value.taxa.Length loop
Output_reportingDescriptorReference (Handler, Value.taxa (J));
end loop;
Handler.End_Array;
end if;
if Value.webRequest.Is_Set then
Handler.Key_Name ("webRequest");
Output_webRequest (Handler, Value.webRequest.Value);
end if;
if Value.webResponse.Is_Set then
Handler.Key_Name ("webResponse");
Output_webResponse (Handler, Value.webResponse.Value);
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_result;

procedure Output_region
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : region) is
begin
Handler.Start_Object;
if Value.startLine.Is_Set then
Handler.Key_Name ("startLine");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.startLine.Value)));
end if;
if Value.startColumn.Is_Set then
Handler.Key_Name ("startColumn");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.startColumn.Value)));
end if;
if Value.endLine.Is_Set then
Handler.Key_Name ("endLine");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.endLine.Value)));
end if;
if Value.endColumn.Is_Set then
Handler.Key_Name ("endColumn");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.endColumn.Value)));
end if;
if Value.charOffset.Is_Set then
Handler.Key_Name ("charOffset");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.charOffset.Value)));
end if;
if Value.charLength.Is_Set then
Handler.Key_Name ("charLength");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.charLength.Value)));
end if;
if Value.byteOffset.Is_Set then
Handler.Key_Name ("byteOffset");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.byteOffset.Value)));
end if;
if Value.byteLength.Is_Set then
Handler.Key_Name ("byteLength");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.byteLength.Value)));
end if;
if Value.snippet.Is_Set then
Handler.Key_Name ("snippet");
Output_artifactContent (Handler, Value.snippet.Value);
end if;
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_message (Handler, Value.message.Value);
end if;
if not Value.sourceLanguage.Is_Null then
Handler.Key_Name ("sourceLanguage");
Handler.String_Value (Value.sourceLanguage);
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_region;

procedure Output_artifactLocation
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : artifactLocation) is
begin
Handler.Start_Object;
if not Value.uri.Is_Null then
Handler.Key_Name ("uri");
Handler.String_Value (Value.uri);
end if;
if not Value.uriBaseId.Is_Null then
Handler.Key_Name ("uriBaseId");
Handler.String_Value (Value.uriBaseId);
end if;
if Value.index.Is_Set then
Handler.Key_Name ("index");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.index.Value)));
end if;
if Value.description.Is_Set then
Handler.Key_Name ("description");
Output_message (Handler, Value.description.Value);
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_artifactLocation;

procedure Output_graphTraversal
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : graphTraversal) is
begin
Handler.Start_Object;
if Value.runGraphIndex.Is_Set then
Handler.Key_Name ("runGraphIndex");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.runGraphIndex.Value)));
end if;
if Value.resultGraphIndex.Is_Set then
Handler.Key_Name ("resultGraphIndex");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.resultGraphIndex.Value)));
end if;
if Value.description.Is_Set then
Handler.Key_Name ("description");
Output_message (Handler, Value.description.Value);
end if;
if not Value.initialState.Is_Empty then
Handler.Key_Name ("initialState");
Output_Any_Value (Handler, Value.initialState);
end if;
if not Value.immutableState.Is_Empty then
Handler.Key_Name ("immutableState");
Output_Any_Value (Handler, Value.immutableState);
end if;
if Value.edgeTraversals.Length > 0 then
Handler.Key_Name ("edgeTraversals");
Handler.Start_Array;
for J in 1 .. Value.edgeTraversals.Length loop
Output_edgeTraversal (Handler, Value.edgeTraversals (J));
end loop;
Handler.End_Array;
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_graphTraversal;

procedure Output_attachment
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : attachment) is
begin
Handler.Start_Object;
if Value.description.Is_Set then
Handler.Key_Name ("description");
Output_message (Handler, Value.description.Value);
end if;
Handler.Key_Name ("artifactLocation");
Output_artifactLocation (Handler, Value.artifactLocation);
if Value.regions.Length > 0 then
Handler.Key_Name ("regions");
Handler.Start_Array;
for J in 1 .. Value.regions.Length loop
Output_region (Handler, Value.regions (J));
end loop;
Handler.End_Array;
end if;
if Value.rectangles.Length > 0 then
Handler.Key_Name ("rectangles");
Handler.Start_Array;
for J in 1 .. Value.rectangles.Length loop
Output_rectangle (Handler, Value.rectangles (J));
end loop;
Handler.End_Array;
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_attachment;

procedure Output_stack
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : stack) is
begin
Handler.Start_Object;
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_message (Handler, Value.message.Value);
end if;
Handler.Key_Name ("frames");
Handler.Start_Array;
for J in 1 .. Value.frames.Length loop
Output_stackFrame (Handler, Value.frames (J));
end loop;
Handler.End_Array;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_stack;

procedure Output_replacement
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : replacement) is
begin
Handler.Start_Object;
Handler.Key_Name ("deletedRegion");
Output_region (Handler, Value.deletedRegion);
if Value.insertedContent.Is_Set then
Handler.Key_Name ("insertedContent");
Output_artifactContent (Handler, Value.insertedContent.Value);
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_replacement;

procedure Output_run
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : run) is
begin
Handler.Start_Object;
Handler.Key_Name ("tool");
Output_tool (Handler, Value.tool);
if Value.invocations.Length > 0 then
Handler.Key_Name ("invocations");
Handler.Start_Array;
for J in 1 .. Value.invocations.Length loop
Output_invocation (Handler, Value.invocations (J));
end loop;
Handler.End_Array;
end if;
if Value.conversion.Is_Set then
Handler.Key_Name ("conversion");
Output_conversion (Handler, Value.conversion.Value);
end if;
if not Value.language.Is_Null then
Handler.Key_Name ("language");
Handler.String_Value (Value.language);
end if;
if Value.versionControlProvenance.Length > 0 then
Handler.Key_Name ("versionControlProvenance");
Handler.Start_Array;
for J in 1 .. Value.versionControlProvenance.Length loop
Output_versionControlDetails (Handler, Value.versionControlProvenance (J));
end loop;
Handler.End_Array;
end if;
if not Value.originalUriBaseIds.Is_Empty then
Handler.Key_Name ("originalUriBaseIds");
Output_Any_Value (Handler, Value.originalUriBaseIds);
end if;
if Value.artifacts.Length > 0 then
Handler.Key_Name ("artifacts");
Handler.Start_Array;
for J in 1 .. Value.artifacts.Length loop
Output_artifact (Handler, Value.artifacts (J));
end loop;
Handler.End_Array;
end if;
if Value.logicalLocations.Length > 0 then
Handler.Key_Name ("logicalLocations");
Handler.Start_Array;
for J in 1 .. Value.logicalLocations.Length loop
Output_logicalLocation (Handler, Value.logicalLocations (J));
end loop;
Handler.End_Array;
end if;
if Value.graphs.Length > 0 then
Handler.Key_Name ("graphs");
Handler.Start_Array;
for J in 1 .. Value.graphs.Length loop
Output_graph (Handler, Value.graphs (J));
end loop;
Handler.End_Array;
end if;
if Value.results.Length > 0 then
Handler.Key_Name ("results");
Handler.Start_Array;
for J in 1 .. Value.results.Length loop
Output_result (Handler, Value.results (J));
end loop;
Handler.End_Array;
end if;
if Value.automationDetails.Is_Set then
Handler.Key_Name ("automationDetails");
Output_runAutomationDetails (Handler, Value.automationDetails.Value);
end if;
if Value.runAggregates.Length > 0 then
Handler.Key_Name ("runAggregates");
Handler.Start_Array;
for J in 1 .. Value.runAggregates.Length loop
Output_runAutomationDetails (Handler, Value.runAggregates (J));
end loop;
Handler.End_Array;
end if;
if not Value.baselineGuid.Is_Null then
Handler.Key_Name ("baselineGuid");
Handler.String_Value (Value.baselineGuid);
end if;
if not Value.redactionTokens.Is_Empty then
Handler.Key_Name ("redactionTokens");
Handler.Start_Array;
for J in 1 .. Value.redactionTokens.Length loop
Handler.String_Value (Value.redactionTokens (J));
end loop;
Handler.End_Array;
end if;
if not Value.defaultEncoding.Is_Null then
Handler.Key_Name ("defaultEncoding");
Handler.String_Value (Value.defaultEncoding);
end if;
if not Value.defaultSourceLanguage.Is_Null then
Handler.Key_Name ("defaultSourceLanguage");
Handler.String_Value (Value.defaultSourceLanguage);
end if;
if not Value.newlineSequences.Is_Empty then
Handler.Key_Name ("newlineSequences");
Handler.Start_Array;
for J in 1 .. Value.newlineSequences.Length loop
Handler.String_Value (Value.newlineSequences (J));
end loop;
Handler.End_Array;
end if;
if Value.columnKind.Is_Set then
Handler.Key_Name ("columnKind");
Output_run_columnKind (Handler, Value.columnKind.Value);
end if;
if Value.externalPropertyFileReferences.Is_Set then
Handler.Key_Name ("externalPropertyFileReferences");
Output_externalPropertyFileReferences (Handler, Value.externalPropertyFileReferences.Value);
end if;
if Value.threadFlowLocations.Length > 0 then
Handler.Key_Name ("threadFlowLocations");
Handler.Start_Array;
for J in 1 .. Value.threadFlowLocations.Length loop
Output_threadFlowLocation (Handler, Value.threadFlowLocations (J));
end loop;
Handler.End_Array;
end if;
if Value.taxonomies.Length > 0 then
Handler.Key_Name ("taxonomies");
Handler.Start_Array;
for J in 1 .. Value.taxonomies.Length loop
Output_toolComponent (Handler, Value.taxonomies (J));
end loop;
Handler.End_Array;
end if;
if Value.addresses.Length > 0 then
Handler.Key_Name ("addresses");
Handler.Start_Array;
for J in 1 .. Value.addresses.Length loop
Output_address (Handler, Value.addresses (J));
end loop;
Handler.End_Array;
end if;
if Value.translations.Length > 0 then
Handler.Key_Name ("translations");
Handler.Start_Array;
for J in 1 .. Value.translations.Length loop
Output_toolComponent (Handler, Value.translations (J));
end loop;
Handler.End_Array;
end if;
if Value.policies.Length > 0 then
Handler.Key_Name ("policies");
Handler.Start_Array;
for J in 1 .. Value.policies.Length loop
Output_toolComponent (Handler, Value.policies (J));
end loop;
Handler.End_Array;
end if;
if Value.webRequests.Length > 0 then
Handler.Key_Name ("webRequests");
Handler.Start_Array;
for J in 1 .. Value.webRequests.Length loop
Output_webRequest (Handler, Value.webRequests (J));
end loop;
Handler.End_Array;
end if;
if Value.webResponses.Length > 0 then
Handler.Key_Name ("webResponses");
Handler.Start_Array;
for J in 1 .. Value.webResponses.Length loop
Output_webResponse (Handler, Value.webResponses (J));
end loop;
Handler.End_Array;
end if;
if Value.specialLocations.Is_Set then
Handler.Key_Name ("specialLocations");
Output_specialLocations (Handler, Value.specialLocations.Value);
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_run;

procedure Output_externalPropertyFileReferences
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : externalPropertyFileReferences) is
begin
Handler.Start_Object;
if Value.conversion.Is_Set then
Handler.Key_Name ("conversion");
Output_externalPropertyFileReference (Handler, Value.conversion.Value);
end if;
if Value.graphs.Length > 0 then
Handler.Key_Name ("graphs");
Handler.Start_Array;
for J in 1 .. Value.graphs.Length loop
Output_externalPropertyFileReference (Handler, Value.graphs (J));
end loop;
Handler.End_Array;
end if;
if Value.externalizedProperties.Is_Set then
Handler.Key_Name ("externalizedProperties");
Output_externalPropertyFileReference (Handler, Value.externalizedProperties.Value);
end if;
if Value.artifacts.Length > 0 then
Handler.Key_Name ("artifacts");
Handler.Start_Array;
for J in 1 .. Value.artifacts.Length loop
Output_externalPropertyFileReference (Handler, Value.artifacts (J));
end loop;
Handler.End_Array;
end if;
if Value.invocations.Length > 0 then
Handler.Key_Name ("invocations");
Handler.Start_Array;
for J in 1 .. Value.invocations.Length loop
Output_externalPropertyFileReference (Handler, Value.invocations (J));
end loop;
Handler.End_Array;
end if;
if Value.logicalLocations.Length > 0 then
Handler.Key_Name ("logicalLocations");
Handler.Start_Array;
for J in 1 .. Value.logicalLocations.Length loop
Output_externalPropertyFileReference (Handler, Value.logicalLocations (J));
end loop;
Handler.End_Array;
end if;
if Value.threadFlowLocations.Length > 0 then
Handler.Key_Name ("threadFlowLocations");
Handler.Start_Array;
for J in 1 .. Value.threadFlowLocations.Length loop
Output_externalPropertyFileReference (Handler, Value.threadFlowLocations (J));
end loop;
Handler.End_Array;
end if;
if Value.results.Length > 0 then
Handler.Key_Name ("results");
Handler.Start_Array;
for J in 1 .. Value.results.Length loop
Output_externalPropertyFileReference (Handler, Value.results (J));
end loop;
Handler.End_Array;
end if;
if Value.taxonomies.Length > 0 then
Handler.Key_Name ("taxonomies");
Handler.Start_Array;
for J in 1 .. Value.taxonomies.Length loop
Output_externalPropertyFileReference (Handler, Value.taxonomies (J));
end loop;
Handler.End_Array;
end if;
if Value.addresses.Length > 0 then
Handler.Key_Name ("addresses");
Handler.Start_Array;
for J in 1 .. Value.addresses.Length loop
Output_externalPropertyFileReference (Handler, Value.addresses (J));
end loop;
Handler.End_Array;
end if;
if Value.driver.Is_Set then
Handler.Key_Name ("driver");
Output_externalPropertyFileReference (Handler, Value.driver.Value);
end if;
if Value.extensions.Length > 0 then
Handler.Key_Name ("extensions");
Handler.Start_Array;
for J in 1 .. Value.extensions.Length loop
Output_externalPropertyFileReference (Handler, Value.extensions (J));
end loop;
Handler.End_Array;
end if;
if Value.policies.Length > 0 then
Handler.Key_Name ("policies");
Handler.Start_Array;
for J in 1 .. Value.policies.Length loop
Output_externalPropertyFileReference (Handler, Value.policies (J));
end loop;
Handler.End_Array;
end if;
if Value.translations.Length > 0 then
Handler.Key_Name ("translations");
Handler.Start_Array;
for J in 1 .. Value.translations.Length loop
Output_externalPropertyFileReference (Handler, Value.translations (J));
end loop;
Handler.End_Array;
end if;
if Value.webRequests.Length > 0 then
Handler.Key_Name ("webRequests");
Handler.Start_Array;
for J in 1 .. Value.webRequests.Length loop
Output_externalPropertyFileReference (Handler, Value.webRequests (J));
end loop;
Handler.End_Array;
end if;
if Value.webResponses.Length > 0 then
Handler.Key_Name ("webResponses");
Handler.Start_Array;
for J in 1 .. Value.webResponses.Length loop
Output_externalPropertyFileReference (Handler, Value.webResponses (J));
end loop;
Handler.End_Array;
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_externalPropertyFileReferences;

procedure Output_a_exception
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : a_exception) is
begin
Handler.Start_Object;
if not Value.kind.Is_Null then
Handler.Key_Name ("kind");
Handler.String_Value (Value.kind);
end if;
if not Value.message.Is_Null then
Handler.Key_Name ("message");
Handler.String_Value (Value.message);
end if;
if Value.stack.Is_Set then
Handler.Key_Name ("stack");
Output_stack (Handler, Value.stack.Value);
end if;
if Value.innerExceptions.Length > 0 then
Handler.Key_Name ("innerExceptions");
Handler.Start_Array;
for J in 1 .. Value.innerExceptions.Length loop
Output_a_exception (Handler, Value.innerExceptions (J));
end loop;
Handler.End_Array;
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_a_exception;

procedure Output_threadFlowLocation
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : threadFlowLocation) is
begin
Handler.Start_Object;
if Value.index.Is_Set then
Handler.Key_Name ("index");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.index.Value)));
end if;
if Value.location.Is_Set then
Handler.Key_Name ("location");
Output_location (Handler, Value.location.Value);
end if;
if Value.stack.Is_Set then
Handler.Key_Name ("stack");
Output_stack (Handler, Value.stack.Value);
end if;
if not Value.kinds.Is_Empty then
Handler.Key_Name ("kinds");
Handler.Start_Array;
for J in 1 .. Value.kinds.Length loop
Handler.String_Value (Value.kinds (J));
end loop;
Handler.End_Array;
end if;
if Value.taxa.Length > 0 then
Handler.Key_Name ("taxa");
Handler.Start_Array;
for J in 1 .. Value.taxa.Length loop
Output_reportingDescriptorReference (Handler, Value.taxa (J));
end loop;
Handler.End_Array;
end if;
if not Value.module.Is_Null then
Handler.Key_Name ("module");
Handler.String_Value (Value.module);
end if;
if not Value.state.Is_Empty then
Handler.Key_Name ("state");
Output_Any_Value (Handler, Value.state);
end if;
if Value.nestingLevel.Is_Set then
Handler.Key_Name ("nestingLevel");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.nestingLevel.Value)));
end if;
if Value.executionOrder.Is_Set then
Handler.Key_Name ("executionOrder");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.executionOrder.Value)));
end if;
if not Value.executionTimeUtc.Is_Null then
Handler.Key_Name ("executionTimeUtc");
Handler.String_Value (Value.executionTimeUtc);
end if;
if Value.importance.Is_Set then
Handler.Key_Name ("importance");
Output_threadFlowLocation_importance (Handler, Value.importance.Value);
end if;
if Value.webRequest.Is_Set then
Handler.Key_Name ("webRequest");
Output_webRequest (Handler, Value.webRequest.Value);
end if;
if Value.webResponse.Is_Set then
Handler.Key_Name ("webResponse");
Output_webResponse (Handler, Value.webResponse.Value);
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_threadFlowLocation;

procedure Output_codeFlow
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : codeFlow) is
begin
Handler.Start_Object;
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_message (Handler, Value.message.Value);
end if;
Handler.Key_Name ("threadFlows");
Handler.Start_Array;
for J in 1 .. Value.threadFlows.Length loop
Output_threadFlow (Handler, Value.threadFlows (J));
end loop;
Handler.End_Array;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_codeFlow;

procedure Output_multiformatMessageString
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : multiformatMessageString) is
begin
Handler.Start_Object;
Handler.Key_Name ("text");
Handler.String_Value (Value.text);
if not Value.markdown.Is_Null then
Handler.Key_Name ("markdown");
Handler.String_Value (Value.markdown);
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_multiformatMessageString;

procedure Output_artifactContent
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : artifactContent) is
begin
Handler.Start_Object;
if not Value.text.Is_Null then
Handler.Key_Name ("text");
Handler.String_Value (Value.text);
end if;
if not Value.binary.Is_Null then
Handler.Key_Name ("binary");
Handler.String_Value (Value.binary);
end if;
if Value.rendered.Is_Set then
Handler.Key_Name ("rendered");
Output_multiformatMessageString (Handler, Value.rendered.Value);
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_artifactContent;

procedure Output_webResponse
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : webResponse) is
begin
Handler.Start_Object;
if Value.index.Is_Set then
Handler.Key_Name ("index");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.index.Value)));
end if;
if not Value.protocol.Is_Null then
Handler.Key_Name ("protocol");
Handler.String_Value (Value.protocol);
end if;
if not Value.version.Is_Null then
Handler.Key_Name ("version");
Handler.String_Value (Value.version);
end if;
if Value.statusCode.Is_Set then
Handler.Key_Name ("statusCode");
Handler.Integer_Value(Interfaces.Integer_64 (Integer'(Value.statusCode.Value)));
end if;
if not Value.reasonPhrase.Is_Null then
Handler.Key_Name ("reasonPhrase");
Handler.String_Value (Value.reasonPhrase);
end if;
if not Value.headers.Is_Empty then
Handler.Key_Name ("headers");
Output_Any_Value (Handler, Value.headers);
end if;
if Value.a_body.Is_Set then
Handler.Key_Name ("body");
Output_artifactContent (Handler, Value.a_body.Value);
end if;
if Value.noResponseReceived then
Handler.Key_Name ("noResponseReceived");
Handler.Boolean_Value (Value.noResponseReceived);
end if;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_webResponse;

procedure Output_threadFlow
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : threadFlow) is
begin
Handler.Start_Object;
if not Value.id.Is_Null then
Handler.Key_Name ("id");
Handler.String_Value (Value.id);
end if;
if Value.message.Is_Set then
Handler.Key_Name ("message");
Output_message (Handler, Value.message.Value);
end if;
if not Value.initialState.Is_Empty then
Handler.Key_Name ("initialState");
Output_Any_Value (Handler, Value.initialState);
end if;
if not Value.immutableState.Is_Empty then
Handler.Key_Name ("immutableState");
Output_Any_Value (Handler, Value.immutableState);
end if;
Handler.Key_Name ("locations");
Handler.Start_Array;
for J in 1 .. Value.locations.Length loop
Output_threadFlowLocation (Handler, Value.locations (J));
end loop;
Handler.End_Array;
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_threadFlow;

procedure Output_configurationOverride
(Handler : in out VSS.JSON.Content_Handlers.JSON_Content_Handler'Class;
Value : configurationOverride) is
begin
Handler.Start_Object;
Handler.Key_Name ("configuration");
Output_reportingConfiguration (Handler, Value.configuration);
Handler.Key_Name ("descriptor");
Output_reportingDescriptorReference (Handler, Value.descriptor);
if Value.properties.Is_Set then
Handler.Key_Name ("properties");
Output_propertyBag (Handler, Value.properties.Value);
end if;
Handler.End_Object;
end Output_configurationOverride;

end SARIF.Types.Outputs;
--
--  Copyright (C) 2024, AdaCore
--
--  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-

with VSS.JSON.Pull_Readers;

package SARIF.Types.Inputs is

procedure Input_notification_level
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.notification_level;
Success : in out Boolean);

procedure Input_suppression_kind
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.suppression_kind;
Success : in out Boolean);

procedure Input_suppression_status
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.suppression_status;
Success : in out Boolean);

procedure Input_toolComponent_contents
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.toolComponent_contents;
Success : in out Boolean);

procedure Input_artifact_roles
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.artifact_roles;
Success : in out Boolean);

procedure Input_reportingConfiguration_level
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.reportingConfiguration_level;
Success : in out Boolean);

procedure Input_result_kind
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.result_kind;
Success : in out Boolean);

procedure Input_result_level
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.result_level;
Success : in out Boolean);

procedure Input_result_baselineState
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.result_baselineState;
Success : in out Boolean);

procedure Input_run_columnKind
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.run_columnKind;
Success : in out Boolean);

procedure Input_threadFlowLocation_importance
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.threadFlowLocation_importance;
Success : in out Boolean);

procedure Input_node
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out node;
Success : in out Boolean);

procedure Input_edgeTraversal
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out edgeTraversal;
Success : in out Boolean);

procedure Input_stackFrame
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out stackFrame;
Success : in out Boolean);

procedure Input_reportingDescriptorRelationship
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out reportingDescriptorRelationship;
Success : in out Boolean);

procedure Input_propertyBag
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out propertyBag;
Success : in out Boolean);

procedure Input_logicalLocation
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out logicalLocation;
Success : in out Boolean);

procedure Input_resultProvenance
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out resultProvenance;
Success : in out Boolean);

procedure Input_message
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out message;
Success : in out Boolean);

procedure Input_artifactChange
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out artifactChange;
Success : in out Boolean);

procedure Input_address
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out address;
Success : in out Boolean);

procedure Input_reportingDescriptorReference
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out reportingDescriptorReference;
Success : in out Boolean);

procedure Input_translationMetadata
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out translationMetadata;
Success : in out Boolean);

procedure Input_notification
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out notification;
Success : in out Boolean);

procedure Input_physicalLocation
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out physicalLocation;
Success : in out Boolean);

procedure Input_versionControlDetails
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out versionControlDetails;
Success : in out Boolean);

procedure Input_location
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out location;
Success : in out Boolean);

procedure Input_suppression
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out suppression;
Success : in out Boolean);

procedure Input_externalPropertyFileReference
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out externalPropertyFileReference;
Success : in out Boolean);

procedure Input_locationRelationship
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out locationRelationship;
Success : in out Boolean);

procedure Input_edge
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out edge;
Success : in out Boolean);

procedure Input_Root
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Root;
Success : in out Boolean);

procedure Input_specialLocations
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out specialLocations;
Success : in out Boolean);

procedure Input_toolComponent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out toolComponent;
Success : in out Boolean);

procedure Input_invocation
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out invocation;
Success : in out Boolean);

procedure Input_conversion
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out conversion;
Success : in out Boolean);

procedure Input_runAutomationDetails
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out runAutomationDetails;
Success : in out Boolean);

procedure Input_graph
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out graph;
Success : in out Boolean);

procedure Input_externalProperties
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out externalProperties;
Success : in out Boolean);

procedure Input_rectangle
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out rectangle;
Success : in out Boolean);

procedure Input_reportingDescriptor
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out reportingDescriptor;
Success : in out Boolean);

procedure Input_artifact
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out artifact;
Success : in out Boolean);

procedure Input_reportingConfiguration
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out reportingConfiguration;
Success : in out Boolean);

procedure Input_toolComponentReference
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out toolComponentReference;
Success : in out Boolean);

procedure Input_tool
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out tool;
Success : in out Boolean);

procedure Input_webRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out webRequest;
Success : in out Boolean);

procedure Input_fix
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out fix;
Success : in out Boolean);

procedure Input_result
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out result;
Success : in out Boolean);

procedure Input_region
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out region;
Success : in out Boolean);

procedure Input_artifactLocation
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out artifactLocation;
Success : in out Boolean);

procedure Input_graphTraversal
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out graphTraversal;
Success : in out Boolean);

procedure Input_attachment
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out attachment;
Success : in out Boolean);

procedure Input_stack
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out stack;
Success : in out Boolean);

procedure Input_replacement
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out replacement;
Success : in out Boolean);

procedure Input_run
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out run;
Success : in out Boolean);

procedure Input_externalPropertyFileReferences
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out externalPropertyFileReferences;
Success : in out Boolean);

procedure Input_a_exception
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out a_exception;
Success : in out Boolean);

procedure Input_threadFlowLocation
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out threadFlowLocation;
Success : in out Boolean);

procedure Input_codeFlow
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out codeFlow;
Success : in out Boolean);

procedure Input_multiformatMessageString
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out multiformatMessageString;
Success : in out Boolean);

procedure Input_artifactContent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out artifactContent;
Success : in out Boolean);

procedure Input_webResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out webResponse;
Success : in out Boolean);

procedure Input_threadFlow
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out threadFlow;
Success : in out Boolean);

procedure Input_configurationOverride
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out configurationOverride;
Success : in out Boolean);

end SARIF.Types.Inputs;
--
--  Copyright (C) 2024, AdaCore
--
--  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-

pragma Ada_2022;
with Minimal_Perfect_Hash;

package body SARIF.Types.Inputs is
pragma Style_Checks (Off);
use type VSS.JSON.JSON_Number_Kind;
use type VSS.Strings.Virtual_String;

procedure Input_Any_Value
  (Reader  : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
   Value   : out Any_Value'Class;
   Success : in out Boolean) is
use type VSS.JSON.Streams.JSON_Stream_Element_Kind;
begin
case Reader.Element_Kind is
when VSS.JSON.Streams.Start_Array =>
Value.Append ((Kind => VSS.JSON.Streams.Start_Array));
Reader.Read_Next;
while Success and Reader.Element_Kind /= VSS.JSON.Streams.End_Array loop
Input_Any_Value (Reader, Value, Success);
end loop;
Value.Append ((Kind => VSS.JSON.Streams.End_Array));
when VSS.JSON.Streams.Start_Object =>
Value.Append ((Kind => VSS.JSON.Streams.Start_Object));
Reader.Read_Next;
while Success and Reader.Element_Kind = VSS.JSON.Streams.Key_Name loop
Value.Append (Reader.Element);
Reader.Read_Next;
Input_Any_Value (Reader, Value, Success);
end loop;
Value.Append ((Kind => VSS.JSON.Streams.End_Object));
when VSS.JSON.Streams.String_Value
   | VSS.JSON.Streams.Number_Value
   | VSS.JSON.Streams.Boolean_Value
   | VSS.JSON.Streams.Null_Value
=>
Value.Append (Reader.Element);
when others =>
Success := False;
end case;
if Success then
Reader.Read_Next;
end if;
end Input_Any_Value;

package notification_level_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["none", "note", "warning", "error"]);

procedure Input_notification_level
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.notification_level;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
notification_level_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
Value := Enum.notification_level'Val (Index - 1);
Reader.Read_Next;
else
Success := False;
end if;
end Input_notification_level;

package suppression_kind_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["inSource", "external"]);

procedure Input_suppression_kind
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.suppression_kind;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
suppression_kind_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
Value := Enum.suppression_kind'Val (Index - 1);
Reader.Read_Next;
else
Success := False;
end if;
end Input_suppression_kind;

package suppression_status_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["accepted", "underReview", "rejected"]);

procedure Input_suppression_status
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.suppression_status;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
suppression_status_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
Value := Enum.suppression_status'Val (Index - 1);
Reader.Read_Next;
else
Success := False;
end if;
end Input_suppression_status;

package toolComponent_contents_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["localizedData", "nonLocalizedData"]);

procedure Input_toolComponent_contents
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.toolComponent_contents;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
toolComponent_contents_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
Value := Enum.toolComponent_contents'Val (Index - 1);
Reader.Read_Next;
else
Success := False;
end if;
end Input_toolComponent_contents;

package artifact_roles_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["analysisTarget", "attachment", "responseFile", "resultFile", "standardStream", "tracedFile", "unmodified", "modified", "added", "deleted", "renamed", "uncontrolled", "driver", "extension", "translation", "taxonomy", "policy", "referencedOnCommandLine", "memoryContents", "directory", "userSpecifiedConfiguration", "toolSpecifiedConfiguration", "debugOutputFile"]);

procedure Input_artifact_roles
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.artifact_roles;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
artifact_roles_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
Value := Enum.artifact_roles'Val (Index - 1);
Reader.Read_Next;
else
Success := False;
end if;
end Input_artifact_roles;

package reportingConfiguration_level_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["none", "note", "warning", "error"]);

procedure Input_reportingConfiguration_level
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.reportingConfiguration_level;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
reportingConfiguration_level_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
Value := Enum.reportingConfiguration_level'Val (Index - 1);
Reader.Read_Next;
else
Success := False;
end if;
end Input_reportingConfiguration_level;

package result_kind_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["notApplicable", "pass", "fail", "review", "open", "informational"]);

procedure Input_result_kind
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.result_kind;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
result_kind_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
Value := Enum.result_kind'Val (Index - 1);
Reader.Read_Next;
else
Success := False;
end if;
end Input_result_kind;

package result_level_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["none", "note", "warning", "error"]);

procedure Input_result_level
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.result_level;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
result_level_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
Value := Enum.result_level'Val (Index - 1);
Reader.Read_Next;
else
Success := False;
end if;
end Input_result_level;

package result_baselineState_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["new", "unchanged", "updated", "absent"]);

procedure Input_result_baselineState
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.result_baselineState;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
result_baselineState_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
Value := Enum.result_baselineState'Val (Index - 1);
Reader.Read_Next;
else
Success := False;
end if;
end Input_result_baselineState;

package run_columnKind_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["utf16CodeUnits", "unicodeCodePoints"]);

procedure Input_run_columnKind
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.run_columnKind;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
run_columnKind_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
Value := Enum.run_columnKind'Val (Index - 1);
Reader.Read_Next;
else
Success := False;
end if;
end Input_run_columnKind;

package threadFlowLocation_importance_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["important", "essential", "unimportant"]);

procedure Input_threadFlowLocation_importance
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Enum.threadFlowLocation_importance;
Success : in out Boolean) is
Index : constant Integer := (if Reader.Is_String_Value then
threadFlowLocation_importance_Minimal_Perfect_Hash.Get_Index (Reader.String_Value)else -1);
begin
if Index > 0 then
Value := Enum.threadFlowLocation_importance'Val (Index - 1);
Reader.Read_Next;
else
Success := False;
end if;
end Input_threadFlowLocation_importance;

package node_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["id", "label", "location", "children", "properties"]);

procedure Input_node
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out node;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
node_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  id
if Reader.Is_String_Value then
Value.id := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  label
Value.label := (Is_Set => True, Value => <>);
Input_message (Reader, Value.label.Value, Success);
   when 3 =>  --  location
Value.location := (Is_Set => True, Value => <>);
Input_location (Reader, Value.location.Value, Success);
   when 4 =>  --  children
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : node;
begin
Input_node (Reader, Item, Success);
Value.children.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 5 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_node;

package edgeTraversal_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["edgeId", "message", "finalState", "stepOverEdgeCount", "properties"]);

procedure Input_edgeTraversal
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out edgeTraversal;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
edgeTraversal_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  edgeId
if Reader.Is_String_Value then
Value.edgeId := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_message (Reader, Value.message.Value, Success);
   when 3 =>  --  finalState
Input_Any_Value (Reader, Value.finalState, Success);
   when 4 =>  --  stepOverEdgeCount
Value.stepOverEdgeCount := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.stepOverEdgeCount.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_edgeTraversal;

package stackFrame_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["location", "module", "threadId", "parameters", "properties"]);

procedure Input_stackFrame
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out stackFrame;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
stackFrame_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  location
Value.location := (Is_Set => True, Value => <>);
Input_location (Reader, Value.location.Value, Success);
   when 2 =>  --  module
if Reader.Is_String_Value then
Value.module := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  threadId
Value.threadId := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.threadId.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  parameters
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : VSS.Strings.Virtual_String;
begin
if Reader.Is_String_Value then
Item := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
Value.parameters.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 5 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_stackFrame;

package reportingDescriptorRelationship_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["target", "kinds", "description", "properties"]);

procedure Input_reportingDescriptorRelationship
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out reportingDescriptorRelationship;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
reportingDescriptorRelationship_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  target
Input_reportingDescriptorReference (Reader, Value.target, Success);
   when 2 =>  --  kinds
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : VSS.Strings.Virtual_String;
begin
if Reader.Is_String_Value then
Item := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
Value.kinds.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 3 =>  --  description
Value.description := (Is_Set => True, Value => <>);
Input_message (Reader, Value.description.Value, Success);
   when 4 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_reportingDescriptorRelationship;

package propertyBag_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["tags"]);

procedure Input_propertyBag
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out propertyBag;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
propertyBag_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  tags
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : VSS.Strings.Virtual_String;
begin
if Reader.Is_String_Value then
Item := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
Value.tags.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_propertyBag;

package logicalLocation_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["name", "index", "fullyQualifiedName", "decoratedName", "parentIndex", "kind", "properties"]);

procedure Input_logicalLocation
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out logicalLocation;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
logicalLocation_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  name
if Reader.Is_String_Value then
Value.name := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  index
Value.index := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.index.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  fullyQualifiedName
if Reader.Is_String_Value then
Value.fullyQualifiedName := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  decoratedName
if Reader.Is_String_Value then
Value.decoratedName := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  parentIndex
Value.parentIndex := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.parentIndex.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  kind
if Reader.Is_String_Value then
Value.kind := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 7 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_logicalLocation;

package resultProvenance_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["firstDetectionTimeUtc", "lastDetectionTimeUtc", "firstDetectionRunGuid", "lastDetectionRunGuid", "invocationIndex", "conversionSources", "properties"]);

procedure Input_resultProvenance
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out resultProvenance;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
resultProvenance_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  firstDetectionTimeUtc
if Reader.Is_String_Value then
Value.firstDetectionTimeUtc := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  lastDetectionTimeUtc
if Reader.Is_String_Value then
Value.lastDetectionTimeUtc := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  firstDetectionRunGuid
if Reader.Is_String_Value then
Value.firstDetectionRunGuid := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  lastDetectionRunGuid
if Reader.Is_String_Value then
Value.lastDetectionRunGuid := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  invocationIndex
Value.invocationIndex := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.invocationIndex.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  conversionSources
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : physicalLocation;
begin
Input_physicalLocation (Reader, Item, Success);
Value.conversionSources.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 7 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_resultProvenance;

package message_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["text", "markdown", "id", "arguments", "properties"]);

procedure Input_message
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out message;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
message_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  text
if Reader.Is_String_Value then
Value.text := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  markdown
if Reader.Is_String_Value then
Value.markdown := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  id
if Reader.Is_String_Value then
Value.id := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  arguments
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : VSS.Strings.Virtual_String;
begin
if Reader.Is_String_Value then
Item := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
Value.arguments.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 5 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_message;

package artifactChange_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["artifactLocation", "replacements", "properties"]);

procedure Input_artifactChange
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out artifactChange;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
artifactChange_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  artifactLocation
Input_artifactLocation (Reader, Value.artifactLocation, Success);
   when 2 =>  --  replacements
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : replacement;
begin
Input_replacement (Reader, Item, Success);
Value.replacements.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 3 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_artifactChange;

package address_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["absoluteAddress", "relativeAddress", "length", "kind", "name", "fullyQualifiedName", "offsetFromParent", "index", "parentIndex", "properties"]);

procedure Input_address
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out address;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
address_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  absoluteAddress
Value.absoluteAddress := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.absoluteAddress.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  relativeAddress
Value.relativeAddress := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.relativeAddress.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  length
Value.length := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.length.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  kind
if Reader.Is_String_Value then
Value.kind := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  name
if Reader.Is_String_Value then
Value.name := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  fullyQualifiedName
if Reader.Is_String_Value then
Value.fullyQualifiedName := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 7 =>  --  offsetFromParent
Value.offsetFromParent := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.offsetFromParent.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 8 =>  --  index
Value.index := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.index.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 9 =>  --  parentIndex
Value.parentIndex := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.parentIndex.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 10 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_address;

package reportingDescriptorReference_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["id", "index", "guid", "toolComponent", "properties"]);

procedure Input_reportingDescriptorReference
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out reportingDescriptorReference;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
reportingDescriptorReference_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  id
if Reader.Is_String_Value then
Value.id := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  index
Value.index := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.index.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  guid
if Reader.Is_String_Value then
Value.guid := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  toolComponent
Value.toolComponent := (Is_Set => True, Value => <>);
Input_toolComponentReference (Reader, Value.toolComponent.Value, Success);
   when 5 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_reportingDescriptorReference;

package translationMetadata_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["name", "fullName", "shortDescription", "fullDescription", "downloadUri", "informationUri", "properties"]);

procedure Input_translationMetadata
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out translationMetadata;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
translationMetadata_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  name
if Reader.Is_String_Value then
Value.name := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  fullName
if Reader.Is_String_Value then
Value.fullName := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  shortDescription
Value.shortDescription := (Is_Set => True, Value => <>);
Input_multiformatMessageString (Reader, Value.shortDescription.Value, Success);
   when 4 =>  --  fullDescription
Value.fullDescription := (Is_Set => True, Value => <>);
Input_multiformatMessageString (Reader, Value.fullDescription.Value, Success);
   when 5 =>  --  downloadUri
if Reader.Is_String_Value then
Value.downloadUri := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  informationUri
if Reader.Is_String_Value then
Value.informationUri := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 7 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_translationMetadata;

package notification_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["locations", "message", "level", "threadId", "timeUtc", "exception", "descriptor", "associatedRule", "properties"]);

procedure Input_notification
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out notification;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
notification_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  locations
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : location;
begin
Input_location (Reader, Item, Success);
Value.locations.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 2 =>  --  message
Input_message (Reader, Value.message, Success);
   when 3 =>  --  level
Value.level := (Is_Set => True, Value => <>);
Input_notification_level (Reader, Value.level.Value, Success);
   when 4 =>  --  threadId
Value.threadId := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.threadId.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  timeUtc
if Reader.Is_String_Value then
Value.timeUtc := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  exception
Value.a_exception := (Is_Set => True, Value => <>);
Input_a_exception (Reader, Value.a_exception.Value, Success);
   when 7 =>  --  descriptor
Value.descriptor := (Is_Set => True, Value => <>);
Input_reportingDescriptorReference (Reader, Value.descriptor.Value, Success);
   when 8 =>  --  associatedRule
Value.associatedRule := (Is_Set => True, Value => <>);
Input_reportingDescriptorReference (Reader, Value.associatedRule.Value, Success);
   when 9 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_notification;

package physicalLocation_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["address", "artifactLocation", "region", "contextRegion", "properties"]);

procedure Input_physicalLocation
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out physicalLocation;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
physicalLocation_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  address
Value.address := (Is_Set => True, Value => <>);
Input_address (Reader, Value.address.Value, Success);
   when 2 =>  --  artifactLocation
Value.artifactLocation := (Is_Set => True, Value => <>);
Input_artifactLocation (Reader, Value.artifactLocation.Value, Success);
   when 3 =>  --  region
Value.region := (Is_Set => True, Value => <>);
Input_region (Reader, Value.region.Value, Success);
   when 4 =>  --  contextRegion
Value.contextRegion := (Is_Set => True, Value => <>);
Input_region (Reader, Value.contextRegion.Value, Success);
   when 5 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_physicalLocation;

package versionControlDetails_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["repositoryUri", "revisionId", "branch", "revisionTag", "asOfTimeUtc", "mappedTo", "properties"]);

procedure Input_versionControlDetails
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out versionControlDetails;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
versionControlDetails_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  repositoryUri
if Reader.Is_String_Value then
Value.repositoryUri := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  revisionId
if Reader.Is_String_Value then
Value.revisionId := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  branch
if Reader.Is_String_Value then
Value.branch := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  revisionTag
if Reader.Is_String_Value then
Value.revisionTag := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  asOfTimeUtc
if Reader.Is_String_Value then
Value.asOfTimeUtc := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  mappedTo
Value.mappedTo := (Is_Set => True, Value => <>);
Input_artifactLocation (Reader, Value.mappedTo.Value, Success);
   when 7 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_versionControlDetails;

package location_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["id", "physicalLocation", "logicalLocations", "message", "annotations", "relationships", "properties"]);

procedure Input_location
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out location;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
location_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  id
Value.id := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.id.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  physicalLocation
Value.physicalLocation := (Is_Set => True, Value => <>);
Input_physicalLocation (Reader, Value.physicalLocation.Value, Success);
   when 3 =>  --  logicalLocations
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : logicalLocation;
begin
Input_logicalLocation (Reader, Item, Success);
Value.logicalLocations.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 4 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_message (Reader, Value.message.Value, Success);
   when 5 =>  --  annotations
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : region;
begin
Input_region (Reader, Item, Success);
Value.annotations.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 6 =>  --  relationships
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : locationRelationship;
begin
Input_locationRelationship (Reader, Item, Success);
Value.relationships.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 7 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_location;

package suppression_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["guid", "kind", "status", "justification", "location", "properties"]);

procedure Input_suppression
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out suppression;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
suppression_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  guid
if Reader.Is_String_Value then
Value.guid := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  kind
Input_suppression_kind (Reader, Value.kind, Success);
   when 3 =>  --  status
Value.status := (Is_Set => True, Value => <>);
Input_suppression_status (Reader, Value.status.Value, Success);
   when 4 =>  --  justification
if Reader.Is_String_Value then
Value.justification := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  location
Value.location := (Is_Set => True, Value => <>);
Input_location (Reader, Value.location.Value, Success);
   when 6 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_suppression;

package externalPropertyFileReference_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["location", "guid", "itemCount", "properties"]);

procedure Input_externalPropertyFileReference
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out externalPropertyFileReference;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
externalPropertyFileReference_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  location
Value.location := (Is_Set => True, Value => <>);
Input_artifactLocation (Reader, Value.location.Value, Success);
   when 2 =>  --  guid
if Reader.Is_String_Value then
Value.guid := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  itemCount
Value.itemCount := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.itemCount.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_externalPropertyFileReference;

package locationRelationship_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["target", "kinds", "description", "properties"]);

procedure Input_locationRelationship
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out locationRelationship;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
locationRelationship_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  target
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.target := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  kinds
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : VSS.Strings.Virtual_String;
begin
if Reader.Is_String_Value then
Item := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
Value.kinds.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 3 =>  --  description
Value.description := (Is_Set => True, Value => <>);
Input_message (Reader, Value.description.Value, Success);
   when 4 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_locationRelationship;

package edge_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["id", "label", "sourceNodeId", "targetNodeId", "properties"]);

procedure Input_edge
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out edge;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
edge_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  id
if Reader.Is_String_Value then
Value.id := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  label
Value.label := (Is_Set => True, Value => <>);
Input_message (Reader, Value.label.Value, Success);
   when 3 =>  --  sourceNodeId
if Reader.Is_String_Value then
Value.sourceNodeId := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  targetNodeId
if Reader.Is_String_Value then
Value.targetNodeId := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_edge;

package Root_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["$schema", "version", "runs", "inlineExternalProperties", "properties"]);

procedure Input_Root
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out Root;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
Root_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  $schema
if Reader.Is_String_Value then
Value.schema := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  version
if Reader.Is_String_Value and then Reader.String_Value = "2.1.0" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  runs
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : run;
begin
Input_run (Reader, Item, Success);
Value.runs.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 4 =>  --  inlineExternalProperties
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : externalProperties;
begin
Input_externalProperties (Reader, Item, Success);
Value.inlineExternalProperties.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 5 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_Root;

package specialLocations_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["displayBase", "properties"]);

procedure Input_specialLocations
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out specialLocations;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
specialLocations_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  displayBase
Value.displayBase := (Is_Set => True, Value => <>);
Input_artifactLocation (Reader, Value.displayBase.Value, Success);
   when 2 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_specialLocations;

package toolComponent_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["guid", "name", "organization", "product", "productSuite", "shortDescription", "fullDescription", "fullName", "version", "semanticVersion", "dottedQuadFileVersion", "releaseDateUtc", "downloadUri", "informationUri", "globalMessageStrings", "notifications", "rules", "taxa", "locations", "language", "contents", "isComprehensive", "localizedDataSemanticVersion", "minimumRequiredLocalizedDataSemanticVersion", "associatedComponent", "translationMetadata", "supportedTaxonomies", "properties"]);

procedure Input_toolComponent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out toolComponent;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
toolComponent_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  guid
if Reader.Is_String_Value then
Value.guid := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  name
if Reader.Is_String_Value then
Value.name := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  organization
if Reader.Is_String_Value then
Value.organization := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  product
if Reader.Is_String_Value then
Value.product := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  productSuite
if Reader.Is_String_Value then
Value.productSuite := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  shortDescription
Value.shortDescription := (Is_Set => True, Value => <>);
Input_multiformatMessageString (Reader, Value.shortDescription.Value, Success);
   when 7 =>  --  fullDescription
Value.fullDescription := (Is_Set => True, Value => <>);
Input_multiformatMessageString (Reader, Value.fullDescription.Value, Success);
   when 8 =>  --  fullName
if Reader.Is_String_Value then
Value.fullName := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 9 =>  --  version
if Reader.Is_String_Value then
Value.version := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 10 =>  --  semanticVersion
if Reader.Is_String_Value then
Value.semanticVersion := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 11 =>  --  dottedQuadFileVersion
if Reader.Is_String_Value then
Value.dottedQuadFileVersion := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 12 =>  --  releaseDateUtc
if Reader.Is_String_Value then
Value.releaseDateUtc := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 13 =>  --  downloadUri
if Reader.Is_String_Value then
Value.downloadUri := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 14 =>  --  informationUri
if Reader.Is_String_Value then
Value.informationUri := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 15 =>  --  globalMessageStrings
Input_Any_Value (Reader, Value.globalMessageStrings, Success);
   when 16 =>  --  notifications
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : reportingDescriptor;
begin
Input_reportingDescriptor (Reader, Item, Success);
Value.notifications.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 17 =>  --  rules
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : reportingDescriptor;
begin
Input_reportingDescriptor (Reader, Item, Success);
Value.rules.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 18 =>  --  taxa
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : reportingDescriptor;
begin
Input_reportingDescriptor (Reader, Item, Success);
Value.taxa.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 19 =>  --  locations
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : artifactLocation;
begin
Input_artifactLocation (Reader, Item, Success);
Value.locations.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 20 =>  --  language
if Reader.Is_String_Value then
Value.language := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 21 =>  --  contents
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : Enum.toolComponent_contents;
begin
Input_toolComponent_contents (Reader, Item, Success);
Value.contents.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 22 =>  --  isComprehensive
if Reader.Is_Boolean_Value then
Value.isComprehensive := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 23 =>  --  localizedDataSemanticVersion
if Reader.Is_String_Value then
Value.localizedDataSemanticVersion := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 24 =>  --  minimumRequiredLocalizedDataSemanticVersion
if Reader.Is_String_Value then
Value.minimumRequiredLocalizedDataSemanticVersion := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 25 =>  --  associatedComponent
Value.associatedComponent := (Is_Set => True, Value => <>);
Input_toolComponentReference (Reader, Value.associatedComponent.Value, Success);
   when 26 =>  --  translationMetadata
Value.translationMetadata := (Is_Set => True, Value => <>);
Input_translationMetadata (Reader, Value.translationMetadata.Value, Success);
   when 27 =>  --  supportedTaxonomies
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : toolComponentReference;
begin
Input_toolComponentReference (Reader, Item, Success);
Value.supportedTaxonomies.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 28 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_toolComponent;

package invocation_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["commandLine", "arguments", "responseFiles", "startTimeUtc", "endTimeUtc", "exitCode", "ruleConfigurationOverrides", "notificationConfigurationOverrides", "toolExecutionNotifications", "toolConfigurationNotifications", "exitCodeDescription", "exitSignalName", "exitSignalNumber", "processStartFailureMessage", "executionSuccessful", "machine", "account", "processId", "executableLocation", "workingDirectory", "environmentVariables", "stdin", "stdout", "stderr", "stdoutStderr", "properties"]);

procedure Input_invocation
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out invocation;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
invocation_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  commandLine
if Reader.Is_String_Value then
Value.commandLine := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  arguments
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : VSS.Strings.Virtual_String;
begin
if Reader.Is_String_Value then
Item := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
Value.arguments.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 3 =>  --  responseFiles
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : artifactLocation;
begin
Input_artifactLocation (Reader, Item, Success);
Value.responseFiles.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 4 =>  --  startTimeUtc
if Reader.Is_String_Value then
Value.startTimeUtc := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  endTimeUtc
if Reader.Is_String_Value then
Value.endTimeUtc := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  exitCode
Value.exitCode := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.exitCode.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 7 =>  --  ruleConfigurationOverrides
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : configurationOverride;
begin
Input_configurationOverride (Reader, Item, Success);
Value.ruleConfigurationOverrides.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 8 =>  --  notificationConfigurationOverrides
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : configurationOverride;
begin
Input_configurationOverride (Reader, Item, Success);
Value.notificationConfigurationOverrides.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 9 =>  --  toolExecutionNotifications
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : notification;
begin
Input_notification (Reader, Item, Success);
Value.toolExecutionNotifications.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 10 =>  --  toolConfigurationNotifications
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : notification;
begin
Input_notification (Reader, Item, Success);
Value.toolConfigurationNotifications.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 11 =>  --  exitCodeDescription
if Reader.Is_String_Value then
Value.exitCodeDescription := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 12 =>  --  exitSignalName
if Reader.Is_String_Value then
Value.exitSignalName := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 13 =>  --  exitSignalNumber
Value.exitSignalNumber := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.exitSignalNumber.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 14 =>  --  processStartFailureMessage
if Reader.Is_String_Value then
Value.processStartFailureMessage := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 15 =>  --  executionSuccessful
if Reader.Is_Boolean_Value then
Value.executionSuccessful := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 16 =>  --  machine
if Reader.Is_String_Value then
Value.machine := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 17 =>  --  account
if Reader.Is_String_Value then
Value.account := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 18 =>  --  processId
Value.processId := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.processId.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 19 =>  --  executableLocation
Value.executableLocation := (Is_Set => True, Value => <>);
Input_artifactLocation (Reader, Value.executableLocation.Value, Success);
   when 20 =>  --  workingDirectory
Value.workingDirectory := (Is_Set => True, Value => <>);
Input_artifactLocation (Reader, Value.workingDirectory.Value, Success);
   when 21 =>  --  environmentVariables
Input_Any_Value (Reader, Value.environmentVariables, Success);
   when 22 =>  --  stdin
Value.stdin := (Is_Set => True, Value => <>);
Input_artifactLocation (Reader, Value.stdin.Value, Success);
   when 23 =>  --  stdout
Value.stdout := (Is_Set => True, Value => <>);
Input_artifactLocation (Reader, Value.stdout.Value, Success);
   when 24 =>  --  stderr
Value.stderr := (Is_Set => True, Value => <>);
Input_artifactLocation (Reader, Value.stderr.Value, Success);
   when 25 =>  --  stdoutStderr
Value.stdoutStderr := (Is_Set => True, Value => <>);
Input_artifactLocation (Reader, Value.stdoutStderr.Value, Success);
   when 26 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_invocation;

package conversion_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["tool", "invocation", "analysisToolLogFiles", "properties"]);

procedure Input_conversion
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out conversion;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
conversion_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  tool
Input_tool (Reader, Value.tool, Success);
   when 2 =>  --  invocation
Value.invocation := (Is_Set => True, Value => <>);
Input_invocation (Reader, Value.invocation.Value, Success);
   when 3 =>  --  analysisToolLogFiles
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : artifactLocation;
begin
Input_artifactLocation (Reader, Item, Success);
Value.analysisToolLogFiles.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 4 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_conversion;

package runAutomationDetails_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["description", "id", "guid", "correlationGuid", "properties"]);

procedure Input_runAutomationDetails
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out runAutomationDetails;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
runAutomationDetails_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  description
Value.description := (Is_Set => True, Value => <>);
Input_message (Reader, Value.description.Value, Success);
   when 2 =>  --  id
if Reader.Is_String_Value then
Value.id := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  guid
if Reader.Is_String_Value then
Value.guid := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  correlationGuid
if Reader.Is_String_Value then
Value.correlationGuid := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_runAutomationDetails;

package graph_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["description", "nodes", "edges", "properties"]);

procedure Input_graph
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out graph;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
graph_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  description
Value.description := (Is_Set => True, Value => <>);
Input_message (Reader, Value.description.Value, Success);
   when 2 =>  --  nodes
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : node;
begin
Input_node (Reader, Item, Success);
Value.nodes.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 3 =>  --  edges
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : edge;
begin
Input_edge (Reader, Item, Success);
Value.edges.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 4 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_graph;

package externalProperties_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["schema", "version", "guid", "runGuid", "conversion", "graphs", "externalizedProperties", "artifacts", "invocations", "logicalLocations", "threadFlowLocations", "results", "taxonomies", "driver", "extensions", "policies", "translations", "addresses", "webRequests", "webResponses", "properties"]);

procedure Input_externalProperties
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out externalProperties;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
externalProperties_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  schema
if Reader.Is_String_Value then
Value.schema := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  version
if Reader.Is_String_Value and then Reader.String_Value = "2.1.0" then
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  guid
if Reader.Is_String_Value then
Value.guid := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  runGuid
if Reader.Is_String_Value then
Value.runGuid := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  conversion
Value.conversion := (Is_Set => True, Value => <>);
Input_conversion (Reader, Value.conversion.Value, Success);
   when 6 =>  --  graphs
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : graph;
begin
Input_graph (Reader, Item, Success);
Value.graphs.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 7 =>  --  externalizedProperties
Value.externalizedProperties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.externalizedProperties.Value, Success);
   when 8 =>  --  artifacts
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : artifact;
begin
Input_artifact (Reader, Item, Success);
Value.artifacts.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 9 =>  --  invocations
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : invocation;
begin
Input_invocation (Reader, Item, Success);
Value.invocations.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 10 =>  --  logicalLocations
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : logicalLocation;
begin
Input_logicalLocation (Reader, Item, Success);
Value.logicalLocations.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 11 =>  --  threadFlowLocations
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : threadFlowLocation;
begin
Input_threadFlowLocation (Reader, Item, Success);
Value.threadFlowLocations.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 12 =>  --  results
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : result;
begin
Input_result (Reader, Item, Success);
Value.results.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 13 =>  --  taxonomies
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : toolComponent;
begin
Input_toolComponent (Reader, Item, Success);
Value.taxonomies.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 14 =>  --  driver
Value.driver := (Is_Set => True, Value => <>);
Input_toolComponent (Reader, Value.driver.Value, Success);
   when 15 =>  --  extensions
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : toolComponent;
begin
Input_toolComponent (Reader, Item, Success);
Value.extensions.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 16 =>  --  policies
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : toolComponent;
begin
Input_toolComponent (Reader, Item, Success);
Value.policies.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 17 =>  --  translations
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : toolComponent;
begin
Input_toolComponent (Reader, Item, Success);
Value.translations.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 18 =>  --  addresses
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : address;
begin
Input_address (Reader, Item, Success);
Value.addresses.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 19 =>  --  webRequests
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : webRequest;
begin
Input_webRequest (Reader, Item, Success);
Value.webRequests.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 20 =>  --  webResponses
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : webResponse;
begin
Input_webResponse (Reader, Item, Success);
Value.webResponses.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 21 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_externalProperties;

package rectangle_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["top", "left", "bottom", "right", "message", "properties"]);

procedure Input_rectangle
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out rectangle;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
rectangle_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  top
Value.top := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value then
if Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.top.Value := Float (Reader.Number_Value.Integer_Value);
elsif Reader.Number_Value.Kind = VSS.JSON.JSON_Float then
Value.top.Value := Float (Reader.Number_Value.Float_Value);
else
Success := False;
end if;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  left
Value.left := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value then
if Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.left.Value := Float (Reader.Number_Value.Integer_Value);
elsif Reader.Number_Value.Kind = VSS.JSON.JSON_Float then
Value.left.Value := Float (Reader.Number_Value.Float_Value);
else
Success := False;
end if;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  bottom
Value.bottom := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value then
if Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.bottom.Value := Float (Reader.Number_Value.Integer_Value);
elsif Reader.Number_Value.Kind = VSS.JSON.JSON_Float then
Value.bottom.Value := Float (Reader.Number_Value.Float_Value);
else
Success := False;
end if;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  right
Value.right := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value then
if Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.right.Value := Float (Reader.Number_Value.Integer_Value);
elsif Reader.Number_Value.Kind = VSS.JSON.JSON_Float then
Value.right.Value := Float (Reader.Number_Value.Float_Value);
else
Success := False;
end if;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_message (Reader, Value.message.Value, Success);
   when 6 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_rectangle;

package reportingDescriptor_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["id", "deprecatedIds", "guid", "deprecatedGuids", "name", "deprecatedNames", "shortDescription", "fullDescription", "messageStrings", "defaultConfiguration", "helpUri", "help", "relationships", "properties"]);

procedure Input_reportingDescriptor
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out reportingDescriptor;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
reportingDescriptor_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  id
if Reader.Is_String_Value then
Value.id := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  deprecatedIds
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : VSS.Strings.Virtual_String;
begin
if Reader.Is_String_Value then
Item := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
Value.deprecatedIds.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 3 =>  --  guid
if Reader.Is_String_Value then
Value.guid := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  deprecatedGuids
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : VSS.Strings.Virtual_String;
begin
if Reader.Is_String_Value then
Item := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
Value.deprecatedGuids.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 5 =>  --  name
if Reader.Is_String_Value then
Value.name := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  deprecatedNames
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : VSS.Strings.Virtual_String;
begin
if Reader.Is_String_Value then
Item := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
Value.deprecatedNames.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 7 =>  --  shortDescription
Value.shortDescription := (Is_Set => True, Value => <>);
Input_multiformatMessageString (Reader, Value.shortDescription.Value, Success);
   when 8 =>  --  fullDescription
Value.fullDescription := (Is_Set => True, Value => <>);
Input_multiformatMessageString (Reader, Value.fullDescription.Value, Success);
   when 9 =>  --  messageStrings
Input_Any_Value (Reader, Value.messageStrings, Success);
   when 10 =>  --  defaultConfiguration
Value.defaultConfiguration := (Is_Set => True, Value => <>);
Input_reportingConfiguration (Reader, Value.defaultConfiguration.Value, Success);
   when 11 =>  --  helpUri
if Reader.Is_String_Value then
Value.helpUri := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 12 =>  --  help
Value.help := (Is_Set => True, Value => <>);
Input_multiformatMessageString (Reader, Value.help.Value, Success);
   when 13 =>  --  relationships
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : reportingDescriptorRelationship;
begin
Input_reportingDescriptorRelationship (Reader, Item, Success);
Value.relationships.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 14 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_reportingDescriptor;

package artifact_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["description", "location", "parentIndex", "offset", "length", "roles", "mimeType", "contents", "encoding", "sourceLanguage", "hashes", "lastModifiedTimeUtc", "properties"]);

procedure Input_artifact
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out artifact;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
artifact_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  description
Value.description := (Is_Set => True, Value => <>);
Input_message (Reader, Value.description.Value, Success);
   when 2 =>  --  location
Value.location := (Is_Set => True, Value => <>);
Input_artifactLocation (Reader, Value.location.Value, Success);
   when 3 =>  --  parentIndex
Value.parentIndex := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.parentIndex.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  offset
Value.offset := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.offset.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  length
Value.length := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.length.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  roles
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : Enum.artifact_roles;
begin
Input_artifact_roles (Reader, Item, Success);
Value.roles.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 7 =>  --  mimeType
if Reader.Is_String_Value then
Value.mimeType := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 8 =>  --  contents
Value.contents := (Is_Set => True, Value => <>);
Input_artifactContent (Reader, Value.contents.Value, Success);
   when 9 =>  --  encoding
if Reader.Is_String_Value then
Value.encoding := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 10 =>  --  sourceLanguage
if Reader.Is_String_Value then
Value.sourceLanguage := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 11 =>  --  hashes
Input_Any_Value (Reader, Value.hashes, Success);
   when 12 =>  --  lastModifiedTimeUtc
if Reader.Is_String_Value then
Value.lastModifiedTimeUtc := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 13 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_artifact;

package reportingConfiguration_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["enabled", "level", "rank", "parameters", "properties"]);

procedure Input_reportingConfiguration
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out reportingConfiguration;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
reportingConfiguration_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  enabled
if Reader.Is_Boolean_Value then
Value.enabled := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  level
Value.level := (Is_Set => True, Value => <>);
Input_reportingConfiguration_level (Reader, Value.level.Value, Success);
   when 3 =>  --  rank
Value.rank := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value then
if Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.rank.Value := Float (Reader.Number_Value.Integer_Value);
elsif Reader.Number_Value.Kind = VSS.JSON.JSON_Float then
Value.rank.Value := Float (Reader.Number_Value.Float_Value);
else
Success := False;
end if;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  parameters
Value.parameters := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.parameters.Value, Success);
   when 5 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_reportingConfiguration;

package toolComponentReference_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["name", "index", "guid", "properties"]);

procedure Input_toolComponentReference
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out toolComponentReference;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
toolComponentReference_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  name
if Reader.Is_String_Value then
Value.name := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  index
Value.index := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.index.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  guid
if Reader.Is_String_Value then
Value.guid := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_toolComponentReference;

package tool_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["driver", "extensions", "properties"]);

procedure Input_tool
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out tool;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
tool_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  driver
Input_toolComponent (Reader, Value.driver, Success);
   when 2 =>  --  extensions
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : toolComponent;
begin
Input_toolComponent (Reader, Item, Success);
Value.extensions.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 3 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_tool;

package webRequest_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["index", "protocol", "version", "target", "method", "headers", "parameters", "body", "properties"]);

procedure Input_webRequest
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out webRequest;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
webRequest_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  index
Value.index := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.index.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  protocol
if Reader.Is_String_Value then
Value.protocol := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  version
if Reader.Is_String_Value then
Value.version := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  target
if Reader.Is_String_Value then
Value.target := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  method
if Reader.Is_String_Value then
Value.method := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  headers
Input_Any_Value (Reader, Value.headers, Success);
   when 7 =>  --  parameters
Input_Any_Value (Reader, Value.parameters, Success);
   when 8 =>  --  body
Value.a_body := (Is_Set => True, Value => <>);
Input_artifactContent (Reader, Value.a_body.Value, Success);
   when 9 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_webRequest;

package fix_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["description", "artifactChanges", "properties"]);

procedure Input_fix
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out fix;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
fix_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  description
Value.description := (Is_Set => True, Value => <>);
Input_message (Reader, Value.description.Value, Success);
   when 2 =>  --  artifactChanges
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : artifactChange;
begin
Input_artifactChange (Reader, Item, Success);
Value.artifactChanges.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 3 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_fix;

package result_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["ruleId", "ruleIndex", "rule", "kind", "level", "message", "analysisTarget", "locations", "guid", "correlationGuid", "occurrenceCount", "partialFingerprints", "fingerprints", "stacks", "codeFlows", "graphs", "graphTraversals", "relatedLocations", "suppressions", "baselineState", "rank", "attachments", "hostedViewerUri", "workItemUris", "provenance", "fixes", "taxa", "webRequest", "webResponse", "properties"]);

procedure Input_result
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out result;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
result_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  ruleId
if Reader.Is_String_Value then
Value.ruleId := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  ruleIndex
Value.ruleIndex := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.ruleIndex.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  rule
Value.rule := (Is_Set => True, Value => <>);
Input_reportingDescriptorReference (Reader, Value.rule.Value, Success);
   when 4 =>  --  kind
Value.kind := (Is_Set => True, Value => <>);
Input_result_kind (Reader, Value.kind.Value, Success);
   when 5 =>  --  level
Value.level := (Is_Set => True, Value => <>);
Input_result_level (Reader, Value.level.Value, Success);
   when 6 =>  --  message
Input_message (Reader, Value.message, Success);
   when 7 =>  --  analysisTarget
Value.analysisTarget := (Is_Set => True, Value => <>);
Input_artifactLocation (Reader, Value.analysisTarget.Value, Success);
   when 8 =>  --  locations
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : location;
begin
Input_location (Reader, Item, Success);
Value.locations.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 9 =>  --  guid
if Reader.Is_String_Value then
Value.guid := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 10 =>  --  correlationGuid
if Reader.Is_String_Value then
Value.correlationGuid := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 11 =>  --  occurrenceCount
Value.occurrenceCount := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.occurrenceCount.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 12 =>  --  partialFingerprints
Input_Any_Value (Reader, Value.partialFingerprints, Success);
   when 13 =>  --  fingerprints
Input_Any_Value (Reader, Value.fingerprints, Success);
   when 14 =>  --  stacks
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : stack;
begin
Input_stack (Reader, Item, Success);
Value.stacks.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 15 =>  --  codeFlows
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : codeFlow;
begin
Input_codeFlow (Reader, Item, Success);
Value.codeFlows.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 16 =>  --  graphs
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : graph;
begin
Input_graph (Reader, Item, Success);
Value.graphs.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 17 =>  --  graphTraversals
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : graphTraversal;
begin
Input_graphTraversal (Reader, Item, Success);
Value.graphTraversals.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 18 =>  --  relatedLocations
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : location;
begin
Input_location (Reader, Item, Success);
Value.relatedLocations.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 19 =>  --  suppressions
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : suppression;
begin
Input_suppression (Reader, Item, Success);
Value.suppressions.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 20 =>  --  baselineState
Value.baselineState := (Is_Set => True, Value => <>);
Input_result_baselineState (Reader, Value.baselineState.Value, Success);
   when 21 =>  --  rank
Value.rank := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value then
if Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.rank.Value := Float (Reader.Number_Value.Integer_Value);
elsif Reader.Number_Value.Kind = VSS.JSON.JSON_Float then
Value.rank.Value := Float (Reader.Number_Value.Float_Value);
else
Success := False;
end if;
Reader.Read_Next;
else
Success := False;
end if;
   when 22 =>  --  attachments
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : attachment;
begin
Input_attachment (Reader, Item, Success);
Value.attachments.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 23 =>  --  hostedViewerUri
if Reader.Is_String_Value then
Value.hostedViewerUri := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 24 =>  --  workItemUris
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : VSS.Strings.Virtual_String;
begin
if Reader.Is_String_Value then
Item := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
Value.workItemUris.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 25 =>  --  provenance
Value.provenance := (Is_Set => True, Value => <>);
Input_resultProvenance (Reader, Value.provenance.Value, Success);
   when 26 =>  --  fixes
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : fix;
begin
Input_fix (Reader, Item, Success);
Value.fixes.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 27 =>  --  taxa
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : reportingDescriptorReference;
begin
Input_reportingDescriptorReference (Reader, Item, Success);
Value.taxa.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 28 =>  --  webRequest
Value.webRequest := (Is_Set => True, Value => <>);
Input_webRequest (Reader, Value.webRequest.Value, Success);
   when 29 =>  --  webResponse
Value.webResponse := (Is_Set => True, Value => <>);
Input_webResponse (Reader, Value.webResponse.Value, Success);
   when 30 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_result;

package region_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["startLine", "startColumn", "endLine", "endColumn", "charOffset", "charLength", "byteOffset", "byteLength", "snippet", "message", "sourceLanguage", "properties"]);

procedure Input_region
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out region;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
region_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  startLine
Value.startLine := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.startLine.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  startColumn
Value.startColumn := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.startColumn.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  endLine
Value.endLine := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.endLine.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  endColumn
Value.endColumn := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.endColumn.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  charOffset
Value.charOffset := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.charOffset.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  charLength
Value.charLength := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.charLength.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 7 =>  --  byteOffset
Value.byteOffset := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.byteOffset.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 8 =>  --  byteLength
Value.byteLength := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.byteLength.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 9 =>  --  snippet
Value.snippet := (Is_Set => True, Value => <>);
Input_artifactContent (Reader, Value.snippet.Value, Success);
   when 10 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_message (Reader, Value.message.Value, Success);
   when 11 =>  --  sourceLanguage
if Reader.Is_String_Value then
Value.sourceLanguage := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 12 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_region;

package artifactLocation_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["uri", "uriBaseId", "index", "description", "properties"]);

procedure Input_artifactLocation
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out artifactLocation;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
artifactLocation_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  uri
if Reader.Is_String_Value then
Value.uri := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  uriBaseId
if Reader.Is_String_Value then
Value.uriBaseId := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  index
Value.index := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.index.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  description
Value.description := (Is_Set => True, Value => <>);
Input_message (Reader, Value.description.Value, Success);
   when 5 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_artifactLocation;

package graphTraversal_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["runGraphIndex", "resultGraphIndex", "description", "initialState", "immutableState", "edgeTraversals", "properties"]);

procedure Input_graphTraversal
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out graphTraversal;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
graphTraversal_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  runGraphIndex
Value.runGraphIndex := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.runGraphIndex.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  resultGraphIndex
Value.resultGraphIndex := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.resultGraphIndex.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  description
Value.description := (Is_Set => True, Value => <>);
Input_message (Reader, Value.description.Value, Success);
   when 4 =>  --  initialState
Input_Any_Value (Reader, Value.initialState, Success);
   when 5 =>  --  immutableState
Input_Any_Value (Reader, Value.immutableState, Success);
   when 6 =>  --  edgeTraversals
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : edgeTraversal;
begin
Input_edgeTraversal (Reader, Item, Success);
Value.edgeTraversals.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 7 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_graphTraversal;

package attachment_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["description", "artifactLocation", "regions", "rectangles", "properties"]);

procedure Input_attachment
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out attachment;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
attachment_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  description
Value.description := (Is_Set => True, Value => <>);
Input_message (Reader, Value.description.Value, Success);
   when 2 =>  --  artifactLocation
Input_artifactLocation (Reader, Value.artifactLocation, Success);
   when 3 =>  --  regions
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : region;
begin
Input_region (Reader, Item, Success);
Value.regions.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 4 =>  --  rectangles
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : rectangle;
begin
Input_rectangle (Reader, Item, Success);
Value.rectangles.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 5 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_attachment;

package stack_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["message", "frames", "properties"]);

procedure Input_stack
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out stack;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
stack_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_message (Reader, Value.message.Value, Success);
   when 2 =>  --  frames
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : stackFrame;
begin
Input_stackFrame (Reader, Item, Success);
Value.frames.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 3 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_stack;

package replacement_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["deletedRegion", "insertedContent", "properties"]);

procedure Input_replacement
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out replacement;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
replacement_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  deletedRegion
Input_region (Reader, Value.deletedRegion, Success);
   when 2 =>  --  insertedContent
Value.insertedContent := (Is_Set => True, Value => <>);
Input_artifactContent (Reader, Value.insertedContent.Value, Success);
   when 3 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_replacement;

package run_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["tool", "invocations", "conversion", "language", "versionControlProvenance", "originalUriBaseIds", "artifacts", "logicalLocations", "graphs", "results", "automationDetails", "runAggregates", "baselineGuid", "redactionTokens", "defaultEncoding", "defaultSourceLanguage", "newlineSequences", "columnKind", "externalPropertyFileReferences", "threadFlowLocations", "taxonomies", "addresses", "translations", "policies", "webRequests", "webResponses", "specialLocations", "properties"]);

procedure Input_run
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out run;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
run_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  tool
Input_tool (Reader, Value.tool, Success);
   when 2 =>  --  invocations
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : invocation;
begin
Input_invocation (Reader, Item, Success);
Value.invocations.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 3 =>  --  conversion
Value.conversion := (Is_Set => True, Value => <>);
Input_conversion (Reader, Value.conversion.Value, Success);
   when 4 =>  --  language
if Reader.Is_String_Value then
Value.language := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  versionControlProvenance
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : versionControlDetails;
begin
Input_versionControlDetails (Reader, Item, Success);
Value.versionControlProvenance.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 6 =>  --  originalUriBaseIds
Input_Any_Value (Reader, Value.originalUriBaseIds, Success);
   when 7 =>  --  artifacts
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : artifact;
begin
Input_artifact (Reader, Item, Success);
Value.artifacts.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 8 =>  --  logicalLocations
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : logicalLocation;
begin
Input_logicalLocation (Reader, Item, Success);
Value.logicalLocations.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 9 =>  --  graphs
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : graph;
begin
Input_graph (Reader, Item, Success);
Value.graphs.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 10 =>  --  results
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : result;
begin
Input_result (Reader, Item, Success);
Value.results.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 11 =>  --  automationDetails
Value.automationDetails := (Is_Set => True, Value => <>);
Input_runAutomationDetails (Reader, Value.automationDetails.Value, Success);
   when 12 =>  --  runAggregates
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : runAutomationDetails;
begin
Input_runAutomationDetails (Reader, Item, Success);
Value.runAggregates.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 13 =>  --  baselineGuid
if Reader.Is_String_Value then
Value.baselineGuid := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 14 =>  --  redactionTokens
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : VSS.Strings.Virtual_String;
begin
if Reader.Is_String_Value then
Item := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
Value.redactionTokens.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 15 =>  --  defaultEncoding
if Reader.Is_String_Value then
Value.defaultEncoding := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 16 =>  --  defaultSourceLanguage
if Reader.Is_String_Value then
Value.defaultSourceLanguage := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 17 =>  --  newlineSequences
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : VSS.Strings.Virtual_String;
begin
if Reader.Is_String_Value then
Item := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
Value.newlineSequences.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 18 =>  --  columnKind
Value.columnKind := (Is_Set => True, Value => <>);
Input_run_columnKind (Reader, Value.columnKind.Value, Success);
   when 19 =>  --  externalPropertyFileReferences
Value.externalPropertyFileReferences := (Is_Set => True, Value => <>);
Input_externalPropertyFileReferences (Reader, Value.externalPropertyFileReferences.Value, Success);
   when 20 =>  --  threadFlowLocations
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : threadFlowLocation;
begin
Input_threadFlowLocation (Reader, Item, Success);
Value.threadFlowLocations.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 21 =>  --  taxonomies
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : toolComponent;
begin
Input_toolComponent (Reader, Item, Success);
Value.taxonomies.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 22 =>  --  addresses
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : address;
begin
Input_address (Reader, Item, Success);
Value.addresses.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 23 =>  --  translations
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : toolComponent;
begin
Input_toolComponent (Reader, Item, Success);
Value.translations.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 24 =>  --  policies
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : toolComponent;
begin
Input_toolComponent (Reader, Item, Success);
Value.policies.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 25 =>  --  webRequests
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : webRequest;
begin
Input_webRequest (Reader, Item, Success);
Value.webRequests.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 26 =>  --  webResponses
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : webResponse;
begin
Input_webResponse (Reader, Item, Success);
Value.webResponses.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 27 =>  --  specialLocations
Value.specialLocations := (Is_Set => True, Value => <>);
Input_specialLocations (Reader, Value.specialLocations.Value, Success);
   when 28 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_run;

package externalPropertyFileReferences_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["conversion", "graphs", "externalizedProperties", "artifacts", "invocations", "logicalLocations", "threadFlowLocations", "results", "taxonomies", "addresses", "driver", "extensions", "policies", "translations", "webRequests", "webResponses", "properties"]);

procedure Input_externalPropertyFileReferences
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out externalPropertyFileReferences;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
externalPropertyFileReferences_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  conversion
Value.conversion := (Is_Set => True, Value => <>);
Input_externalPropertyFileReference (Reader, Value.conversion.Value, Success);
   when 2 =>  --  graphs
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : externalPropertyFileReference;
begin
Input_externalPropertyFileReference (Reader, Item, Success);
Value.graphs.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 3 =>  --  externalizedProperties
Value.externalizedProperties := (Is_Set => True, Value => <>);
Input_externalPropertyFileReference (Reader, Value.externalizedProperties.Value, Success);
   when 4 =>  --  artifacts
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : externalPropertyFileReference;
begin
Input_externalPropertyFileReference (Reader, Item, Success);
Value.artifacts.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 5 =>  --  invocations
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : externalPropertyFileReference;
begin
Input_externalPropertyFileReference (Reader, Item, Success);
Value.invocations.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 6 =>  --  logicalLocations
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : externalPropertyFileReference;
begin
Input_externalPropertyFileReference (Reader, Item, Success);
Value.logicalLocations.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 7 =>  --  threadFlowLocations
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : externalPropertyFileReference;
begin
Input_externalPropertyFileReference (Reader, Item, Success);
Value.threadFlowLocations.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 8 =>  --  results
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : externalPropertyFileReference;
begin
Input_externalPropertyFileReference (Reader, Item, Success);
Value.results.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 9 =>  --  taxonomies
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : externalPropertyFileReference;
begin
Input_externalPropertyFileReference (Reader, Item, Success);
Value.taxonomies.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 10 =>  --  addresses
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : externalPropertyFileReference;
begin
Input_externalPropertyFileReference (Reader, Item, Success);
Value.addresses.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 11 =>  --  driver
Value.driver := (Is_Set => True, Value => <>);
Input_externalPropertyFileReference (Reader, Value.driver.Value, Success);
   when 12 =>  --  extensions
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : externalPropertyFileReference;
begin
Input_externalPropertyFileReference (Reader, Item, Success);
Value.extensions.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 13 =>  --  policies
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : externalPropertyFileReference;
begin
Input_externalPropertyFileReference (Reader, Item, Success);
Value.policies.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 14 =>  --  translations
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : externalPropertyFileReference;
begin
Input_externalPropertyFileReference (Reader, Item, Success);
Value.translations.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 15 =>  --  webRequests
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : externalPropertyFileReference;
begin
Input_externalPropertyFileReference (Reader, Item, Success);
Value.webRequests.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 16 =>  --  webResponses
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : externalPropertyFileReference;
begin
Input_externalPropertyFileReference (Reader, Item, Success);
Value.webResponses.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 17 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_externalPropertyFileReferences;

package a_exception_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["kind", "message", "stack", "innerExceptions", "properties"]);

procedure Input_a_exception
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out a_exception;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
a_exception_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  kind
if Reader.Is_String_Value then
Value.kind := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  message
if Reader.Is_String_Value then
Value.message := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  stack
Value.stack := (Is_Set => True, Value => <>);
Input_stack (Reader, Value.stack.Value, Success);
   when 4 =>  --  innerExceptions
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : a_exception;
begin
Input_a_exception (Reader, Item, Success);
Value.innerExceptions.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 5 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_a_exception;

package threadFlowLocation_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["index", "location", "stack", "kinds", "taxa", "module", "state", "nestingLevel", "executionOrder", "executionTimeUtc", "importance", "webRequest", "webResponse", "properties"]);

procedure Input_threadFlowLocation
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out threadFlowLocation;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
threadFlowLocation_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  index
Value.index := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.index.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  location
Value.location := (Is_Set => True, Value => <>);
Input_location (Reader, Value.location.Value, Success);
   when 3 =>  --  stack
Value.stack := (Is_Set => True, Value => <>);
Input_stack (Reader, Value.stack.Value, Success);
   when 4 =>  --  kinds
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : VSS.Strings.Virtual_String;
begin
if Reader.Is_String_Value then
Item := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
Value.kinds.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 5 =>  --  taxa
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : reportingDescriptorReference;
begin
Input_reportingDescriptorReference (Reader, Item, Success);
Value.taxa.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 6 =>  --  module
if Reader.Is_String_Value then
Value.module := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 7 =>  --  state
Input_Any_Value (Reader, Value.state, Success);
   when 8 =>  --  nestingLevel
Value.nestingLevel := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.nestingLevel.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 9 =>  --  executionOrder
Value.executionOrder := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.executionOrder.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 10 =>  --  executionTimeUtc
if Reader.Is_String_Value then
Value.executionTimeUtc := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 11 =>  --  importance
Value.importance := (Is_Set => True, Value => <>);
Input_threadFlowLocation_importance (Reader, Value.importance.Value, Success);
   when 12 =>  --  webRequest
Value.webRequest := (Is_Set => True, Value => <>);
Input_webRequest (Reader, Value.webRequest.Value, Success);
   when 13 =>  --  webResponse
Value.webResponse := (Is_Set => True, Value => <>);
Input_webResponse (Reader, Value.webResponse.Value, Success);
   when 14 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_threadFlowLocation;

package codeFlow_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["message", "threadFlows", "properties"]);

procedure Input_codeFlow
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out codeFlow;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
codeFlow_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_message (Reader, Value.message.Value, Success);
   when 2 =>  --  threadFlows
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : threadFlow;
begin
Input_threadFlow (Reader, Item, Success);
Value.threadFlows.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 3 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_codeFlow;

package multiformatMessageString_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["text", "markdown", "properties"]);

procedure Input_multiformatMessageString
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out multiformatMessageString;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
multiformatMessageString_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  text
if Reader.Is_String_Value then
Value.text := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  markdown
if Reader.Is_String_Value then
Value.markdown := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_multiformatMessageString;

package artifactContent_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["text", "binary", "rendered", "properties"]);

procedure Input_artifactContent
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out artifactContent;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
artifactContent_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  text
if Reader.Is_String_Value then
Value.text := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  binary
if Reader.Is_String_Value then
Value.binary := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  rendered
Value.rendered := (Is_Set => True, Value => <>);
Input_multiformatMessageString (Reader, Value.rendered.Value, Success);
   when 4 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_artifactContent;

package webResponse_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["index", "protocol", "version", "statusCode", "reasonPhrase", "headers", "body", "noResponseReceived", "properties"]);

procedure Input_webResponse
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out webResponse;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
webResponse_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  index
Value.index := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.index.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  protocol
if Reader.Is_String_Value then
Value.protocol := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 3 =>  --  version
if Reader.Is_String_Value then
Value.version := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 4 =>  --  statusCode
Value.statusCode := (Is_Set => True, Value => <>);
if Reader.Is_Number_Value and then Reader.Number_Value.Kind = VSS.JSON.JSON_Integer then
Value.statusCode.Value := Integer (Reader.Number_Value.Integer_Value);
Reader.Read_Next;
else
Success := False;
end if;
   when 5 =>  --  reasonPhrase
if Reader.Is_String_Value then
Value.reasonPhrase := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 6 =>  --  headers
Input_Any_Value (Reader, Value.headers, Success);
   when 7 =>  --  body
Value.a_body := (Is_Set => True, Value => <>);
Input_artifactContent (Reader, Value.a_body.Value, Success);
   when 8 =>  --  noResponseReceived
if Reader.Is_Boolean_Value then
Value.noResponseReceived := Reader.Boolean_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 9 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_webResponse;

package threadFlow_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["id", "message", "initialState", "immutableState", "locations", "properties"]);

procedure Input_threadFlow
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out threadFlow;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
threadFlow_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  id
if Reader.Is_String_Value then
Value.id := Reader.String_Value;
Reader.Read_Next;
else
Success := False;
end if;
   when 2 =>  --  message
Value.message := (Is_Set => True, Value => <>);
Input_message (Reader, Value.message.Value, Success);
   when 3 =>  --  initialState
Input_Any_Value (Reader, Value.initialState, Success);
   when 4 =>  --  immutableState
Input_Any_Value (Reader, Value.immutableState, Success);
   when 5 =>  --  locations
if Success and Reader.Is_Start_Array then
Reader.Read_Next;
while Success and not Reader.Is_End_Array loop
declare
Item : threadFlowLocation;
begin
Input_threadFlowLocation (Reader, Item, Success);
Value.locations.Append (Item);
end;
end loop;
if Success then
Reader.Read_Next;  --  skip End_Array
end if;
else
Success := False;
end if;
   when 6 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_threadFlow;

package configurationOverride_Minimal_Perfect_Hash is new Minimal_Perfect_Hash (["configuration", "descriptor", "properties"]);

procedure Input_configurationOverride
(Reader : in out VSS.JSON.Pull_Readers.JSON_Pull_Reader'Class;
Value : out configurationOverride;
Success : in out Boolean) is
begin
if Success and Reader.Is_Start_Object then
Reader.Read_Next;
else
Success := False;
end if;

while Success and not Reader.Is_End_Object loop
if Reader.Is_Key_Name then
declare
Index : constant Natural :=
configurationOverride_Minimal_Perfect_Hash.Get_Index (Reader.Key_Name);
begin
Reader.Read_Next;

case Index is
   when 1 =>  --  configuration
Input_reportingConfiguration (Reader, Value.configuration, Success);
   when 2 =>  --  descriptor
Input_reportingDescriptorReference (Reader, Value.descriptor, Success);
   when 3 =>  --  properties
Value.properties := (Is_Set => True, Value => <>);
Input_propertyBag (Reader, Value.properties.Value, Success);
when others =>
Reader.Skip_Current_Value;
end case;
end;
else
   Success := False;
end if;
end loop;

if Success then
Reader.Read_Next;  --  skip End_Object
end if;
end Input_configurationOverride;

end SARIF.Types.Inputs;
